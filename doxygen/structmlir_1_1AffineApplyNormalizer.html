<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::AffineApplyNormalizer Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html">AffineApplyNormalizer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structmlir_1_1AffineApplyNormalizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::AffineApplyNormalizer Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <code><a class="el" href="structmlir_1_1AffineApplyNormalizer.html" title="An AffineApplyNormalizer is a helper class that supports renumbering operands of AffineApplyOp. ">AffineApplyNormalizer</a></code> is a helper class that supports renumbering operands of <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>.  
 <a href="structmlir_1_1AffineApplyNormalizer.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/AffineOps/AffineOps.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea23fc31b3e8dcc655330d556400d7b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#aea23fc31b3e8dcc655330d556400d7b6">AffineApplyNormalizer</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:aea23fc31b3e8dcc655330d556400d7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AffineNormalizer composes <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> recursively.  <a href="#aea23fc31b3e8dcc655330d556400d7b6">More...</a><br /></td></tr>
<tr class="separator:aea23fc31b3e8dcc655330d556400d7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bba6a4e0d46d39c891c9e0223cd7dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#a0bba6a4e0d46d39c891c9e0223cd7dc7">getAffineMap</a> ()</td></tr>
<tr class="memdesc:a0bba6a4e0d46d39c891c9e0223cd7dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> resulting from normalization.  <a href="#a0bba6a4e0d46d39c891c9e0223cd7dc7">More...</a><br /></td></tr>
<tr class="separator:a0bba6a4e0d46d39c891c9e0223cd7dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b12370556fb2bc1e4188d821380dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#aa26b12370556fb2bc1e4188d821380dd">getOperands</a> ()</td></tr>
<tr class="separator:aa26b12370556fb2bc1e4188d821380dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0d99ad43ba9dc6f8aa4e1db11321b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#aa0b0d99ad43ba9dc6f8aa4e1db11321b">getNumSymbols</a> ()</td></tr>
<tr class="separator:aa0b0d99ad43ba9dc6f8aa4e1db11321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3db5a0581bf47001d2bdd3ecc6feeef"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#ad3db5a0581bf47001d2bdd3ecc6feeef">getNumDims</a> ()</td></tr>
<tr class="separator:ad3db5a0581bf47001d2bdd3ecc6feeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e132c5e5d87883e4995d6a5577687d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#ac2e132c5e5d87883e4995d6a5577687d">normalize</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *otherMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *otherOperands)</td></tr>
<tr class="memdesc:ac2e132c5e5d87883e4995d6a5577687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes 'otherMap' and its operands 'otherOperands' to map to this normalizer's coordinate space.  <a href="#ac2e132c5e5d87883e4995d6a5577687d">More...</a><br /></td></tr>
<tr class="separator:ac2e132c5e5d87883e4995d6a5577687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c8cc62994b17bec9226f8186bf98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html#ab79c8cc62994b17bec9226f8186bf98a">~AffineApplyNormalizer</a> ()</td></tr>
<tr class="separator:ab79c8cc62994b17bec9226f8186bf98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <code><a class="el" href="structmlir_1_1AffineApplyNormalizer.html" title="An AffineApplyNormalizer is a helper class that supports renumbering operands of AffineApplyOp. ">AffineApplyNormalizer</a></code> is a helper class that supports renumbering operands of <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>. </p>
<p>This acts as a reindexing map of <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to positional dims or symbols and allows simplifications such as:</p>
<div class="fragment"><div class="line">%1 = affine.apply (d0, d1) -&gt; (d0 - d1) (%0, %0)</div></div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%1 = affine.apply () -&gt; (0)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00617">617</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea23fc31b3e8dcc655330d556400d7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea23fc31b3e8dcc655330d556400d7b6">&#9670;&nbsp;</a></span>AffineApplyNormalizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyNormalizer::AffineApplyNormalizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The AffineNormalizer composes <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> recursively. </p>
<p>Its purpose is to keep a correspondence between the mathematical <code>map</code> and the <code>operands</code> of a given <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>. This correspondence is maintained by iterating over the operands and forming an <code>auxiliaryMap</code> that can be composed mathematically with <code>map</code>. To keep this correspondence in cases where symbols are produced by affine.apply operations, we perform a local rewrite of symbols as dims.</p>
<h1>Rationale for locally rewriting symbols as dims: </h1>
<p>The mathematical composition of <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> must always concatenate symbols because it does not have enough information to do otherwise. For example, composing <code>(d0)[s0] -&gt; (d0 + s0)</code> with itself must produce <code>(d0)[s0, s1] -&gt; (d0 + s0 + s1)</code>.</p>
<p>The result is only equivalent to <code>(d0)[s0] -&gt; (d0 + 2 * s0)</code> when applied to the same <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">mlir::Value</a> for both s0 and s1. As a consequence mathematical composition of <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> always concatenates symbols.</p>
<p>When AffineMaps are used in <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> however, they may specify composition via symbols, which is ambiguous mathematically. This corner case is handled by locally rewriting such symbols that come from <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> into dims and composing through dims. TODO(andydavis, ntv): Composition via symbols comes at a significant code complexity. Alternatively we should investigate whether we want to explicitly disallow symbols coming from affine.apply and instead force the user to compose symbols beforehand. The annoyances may be small (i.e. 1 or 2 extra API calls for such uses, which haven't popped up until now) and the benefit potentially big: simpler and more maintainable code for a non-trivial, recursive, procedure. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00456">456</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00225">mlir::AffineMap::compose()</a>, <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02167">mlir::AffineMap::print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00387">promoteComposedSymbolsAsDims()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00280">mlir::simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="ab79c8cc62994b17bec9226f8186bf98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c8cc62994b17bec9226f8186bf98a">&#9670;&nbsp;</a></span>~AffineApplyNormalizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineApplyNormalizer::~AffineApplyNormalizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00672">672</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bba6a4e0d46d39c891c9e0223cd7dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bba6a4e0d46d39c891c9e0223cd7dc7">&#9670;&nbsp;</a></span>getAffineMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineApplyNormalizer::getAffineMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> resulting from normalization. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00621">621</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>.</p>

</div>
</div>
<a id="ad3db5a0581bf47001d2bdd3ecc6feeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3db5a0581bf47001d2bdd3ecc6feeef">&#9670;&nbsp;</a></span>getNumDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineApplyNormalizer::getNumDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00630">630</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00611">canonicalizePromotedSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01624">parseAffineIfOp()</a>.</p>

</div>
</div>
<a id="aa0b0d99ad43ba9dc6f8aa4e1db11321b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b0d99ad43ba9dc6f8aa4e1db11321b">&#9670;&nbsp;</a></span>getNumSymbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineApplyNormalizer::getNumSymbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00629">629</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01624">parseAffineIfOp()</a>.</p>

</div>
</div>
<a id="aa26b12370556fb2bc1e4188d821380dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b12370556fb2bc1e4188d821380dd">&#9670;&nbsp;</a></span>getOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 8&gt; mlir::AffineApplyNormalizer::getOperands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00623">623</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01672">print()</a>.</p>

</div>
</div>
<a id="ac2e132c5e5d87883e4995d6a5577687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e132c5e5d87883e4995d6a5577687d">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineApplyNormalizer::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>otherMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>otherOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes 'otherMap' and its operands 'otherOperands' to map to this normalizer's coordinate space. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00564">564</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/AffineOps/<a class="el" href="AffineOps_8h_source.html">AffineOps.h</a></li>
<li>lib/Dialect/AffineOps/<a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2020 18:24:21 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
