<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1FlatAffineConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A flat list of affine equalities and inequalities in the form.  
 <a href="classmlir_1_1FlatAffineConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Analysis/AffineStructures.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab47fbec6c4aff6faece95521b103fed2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7">Dimension</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372">Symbol</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778">Local</a>
 }</td></tr>
<tr class="separator:ab47fbec6c4aff6faece95521b103fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67d39a02671f878053effe3493e6544a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a67d39a02671f878053effe3493e6544a">FlatAffineConstraints</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; idArgs={})</td></tr>
<tr class="memdesc:a67d39a02671f878053effe3493e6544a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="#a67d39a02671f878053effe3493e6544a">More...</a><br /></td></tr>
<tr class="separator:a67d39a02671f878053effe3493e6544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6c8b02abc69721d025b1ca23db2b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2c6c8b02abc69721d025b1ca23db2b2e">FlatAffineConstraints</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; idArgs={})</td></tr>
<tr class="memdesc:a2c6c8b02abc69721d025b1ca23db2b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="#a2c6c8b02abc69721d025b1ca23db2b2e">More...</a><br /></td></tr>
<tr class="separator:a2c6c8b02abc69721d025b1ca23db2b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ccacf0a047233d064351ff31cd9c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a485ccacf0a047233d064351ff31cd9c1">FlatAffineConstraints</a> (const HyperRectangularSet &amp;set)</td></tr>
<tr class="separator:a485ccacf0a047233d064351ff31cd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4103886f4e5761c76b4073aa1de73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9ed4103886f4e5761c76b4073aa1de73">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="memdesc:a9ed4103886f4e5761c76b4073aa1de73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these.  <a href="#a9ed4103886f4e5761c76b4073aa1de73">More...</a><br /></td></tr>
<tr class="separator:a9ed4103886f4e5761c76b4073aa1de73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4333c62fce350f020f58b6fb0d2faf0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4333c62fce350f020f58b6fb0d2faf0f">FlatAffineConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef)</td></tr>
<tr class="separator:a4333c62fce350f020f58b6fb0d2faf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">FlatAffineConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">More...</a><br /></td></tr>
<tr class="separator:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947eee63586b73c35a239e63248a9bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7947eee63586b73c35a239e63248a9bc">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1IntegerValueSet.html">IntegerValueSet</a> &amp;set)</td></tr>
<tr class="memdesc:a7947eee63586b73c35a239e63248a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine constraint system from an <a class="el" href="classmlir_1_1IntegerValueSet.html" title="An IntegerValueSet is an integer set plus its operands. ">IntegerValueSet</a>.  <a href="#a7947eee63586b73c35a239e63248a9bc">More...</a><br /></td></tr>
<tr class="separator:a7947eee63586b73c35a239e63248a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5f989f74501c929910cc94637209ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4b5f989f74501c929910cc94637209ce">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="separator:a4b5f989f74501c929910cc94637209ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84814b8b20bb9768814270d71952a9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af84814b8b20bb9768814270d71952a9d">FlatAffineConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:af84814b8b20bb9768814270d71952a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074122b77beb705d010169667ae9efe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8074122b77beb705d010169667ae9efe">FlatAffineConstraints</a> (const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;map)</td></tr>
<tr class="separator:a8074122b77beb705d010169667ae9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8824fdedbdc984ff79e3b812016f3b2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8824fdedbdc984ff79e3b812016f3b2c">~FlatAffineConstraints</a> ()</td></tr>
<tr class="separator:a8824fdedbdc984ff79e3b812016f3b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5165263cbbc9080ca858b235f98cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afb5165263cbbc9080ca858b235f98cd7">reset</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims, unsigned numSymbols, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; idArgs={})</td></tr>
<tr class="separator:afb5165263cbbc9080ca858b235f98cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc51d0f0dc264158dd9fd0bb47cd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae0cc51d0f0dc264158dd9fd0bb47cd28">reset</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; idArgs={})</td></tr>
<tr class="separator:ae0cc51d0f0dc264158dd9fd0bb47cd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6e4973d2d62dbf7779d1e350fec9911e">append</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a6e4973d2d62dbf7779d1e350fec9911e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from 'other' into this.  <a href="#a6e4973d2d62dbf7779d1e350fec9911e">More...</a><br /></td></tr>
<tr class="separator:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6ddc2ce92fc0297fbc8bfc62241c4472">isEmpty</a> () const</td></tr>
<tr class="separator:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318337e58529a47cd9c9e38e11b3e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af318337e58529a47cd9c9e38e11b3e67">isEmptyByGCDTest</a> () const</td></tr>
<tr class="separator:af318337e58529a47cd9c9e38e11b3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0932fcc3e8ee32f1af944a1f33a9abc3">clone</a> () const</td></tr>
<tr class="separator:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aaeb4c8e8b0bf86fa1609a32bd9028536">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">More...</a><br /></td></tr>
<tr class="separator:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0b80ebb1a0929a30c4401d297a420d9e">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950735c15d0d1757984210922c7118c0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a950735c15d0d1757984210922c7118c0">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="separator:a950735c15d0d1757984210922c7118c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ba9253168af09117779ede6e1020f"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae02ba9253168af09117779ede6e1020f">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:ae02ba9253168af09117779ede6e1020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd">getNumCols</a> () const</td></tr>
<tr class="memdesc:ad6dafa2401aead0909b87b92d41bfbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="#ad6dafa2401aead0909b87b92d41bfbbd">More...</a><br /></td></tr>
<tr class="separator:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e712e6a344acbadfa413940487704"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a963e712e6a344acbadfa413940487704">getNumEqualities</a> () const</td></tr>
<tr class="separator:a963e712e6a344acbadfa413940487704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a50f382f6a3f7062ff36e3dce1920c4c9">getNumInequalities</a> () const</td></tr>
<tr class="separator:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597e435e789ef833a1e0cc80cd82a388"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a597e435e789ef833a1e0cc80cd82a388">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:a597e435e789ef833a1e0cc80cd82a388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3617c7a6eef7e4c3d1b1845025900adf">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0673b512906bb0fed9e4c7244f9f0217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0673b512906bb0fed9e4c7244f9f0217">getEquality</a> (unsigned idx) const</td></tr>
<tr class="separator:a0673b512906bb0fed9e4c7244f9f0217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a92b9b04e17d80d48a79c0e09710c2be6">getInequality</a> (unsigned idx) const</td></tr>
<tr class="separator:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3713af3279fc39f3630a5a6b89031653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3713af3279fc39f3630a5a6b89031653">toAffineExpr</a> (unsigned idx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:a3713af3279fc39f3630a5a6b89031653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4150bc63be2852d5efbbd31d1b938a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac4150bc63be2852d5efbbd31d1b938a8">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ac4150bc63be2852d5efbbd31d1b938a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps.  <a href="#ac4150bc63be2852d5efbbd31d1b938a8">More...</a><br /></td></tr>
<tr class="separator:ac4150bc63be2852d5efbbd31d1b938a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944078deda4fba2b98635152d2759bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a944078deda4fba2b98635152d2759bfe">addLowerOrUpperBound</a> (unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, bool eq, bool lower=true)</td></tr>
<tr class="memdesc:a944078deda4fba2b98635152d2759bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a lower or an upper bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands.  <a href="#a944078deda4fba2b98635152d2759bfe">More...</a><br /></td></tr>
<tr class="separator:a944078deda4fba2b98635152d2759bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe40151ae13ca4d10c425937ff70f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">getSliceBounds</a> (unsigned offset, unsigned num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="memdesc:a27fe40151ae13ca4d10c425937ff70f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as an affine map of the remaining identifiers (dimensional and symbolic).  <a href="#a27fe40151ae13ca4d10c425937ff70f2">More...</a><br /></td></tr>
<tr class="separator:a27fe40151ae13ca4d10c425937ff70f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d2543f40e0fc1c4701f20d4b891deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad5d2543f40e0fc1c4701f20d4b891deb">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ad5d2543f40e0fc1c4701f20d4b891deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds slice lower bounds represented by lower bounds in 'lbMaps' and upper bounds in 'ubMaps' to each identifier in the constraint system which has a value in 'values'.  <a href="#ad5d2543f40e0fc1c4701f20d4b891deb">More...</a><br /></td></tr>
<tr class="separator:ad5d2543f40e0fc1c4701f20d4b891deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9a440a9b51c09ea27d100fb62fb32a7f">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="separator:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df72c07b67e459ece93a1076344210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a45df72c07b67e459ece93a1076344210">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="separator:a45df72c07b67e459ece93a1076344210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876c2038d87d8df799eb8e8010670da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7876c2038d87d8df799eb8e8010670da">addConstantLowerBound</a> (unsigned pos, int64_t lb)</td></tr>
<tr class="memdesc:a7876c2038d87d8df799eb8e8010670da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant lower bound constraint for the specified identifier.  <a href="#a7876c2038d87d8df799eb8e8010670da">More...</a><br /></td></tr>
<tr class="separator:a7876c2038d87d8df799eb8e8010670da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79201460364553813e818c2f4c47b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae79201460364553813e818c2f4c47b26">addConstantUpperBound</a> (unsigned pos, int64_t ub)</td></tr>
<tr class="memdesc:ae79201460364553813e818c2f4c47b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant upper bound constraint for the specified identifier.  <a href="#ae79201460364553813e818c2f4c47b26">More...</a><br /></td></tr>
<tr class="separator:ae79201460364553813e818c2f4c47b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9d81cc0ca235dba7982f6cecc66f2506">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="memdesc:a9d81cc0ca235dba7982f6cecc66f2506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in 'dividend' and with respect to a positive constant 'divisor'.  <a href="#a9d81cc0ca235dba7982f6cecc66f2506">More...</a><br /></td></tr>
<tr class="separator:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a6c2a425f192f14a650791fb1154c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a05a6c2a425f192f14a650791fb1154c3">addConstantLowerBound</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t lb)</td></tr>
<tr class="memdesc:a05a6c2a425f192f14a650791fb1154c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant lower bound constraint for the specified expression.  <a href="#a05a6c2a425f192f14a650791fb1154c3">More...</a><br /></td></tr>
<tr class="separator:a05a6c2a425f192f14a650791fb1154c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6023d999d0f85e8c9bf105767991199a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6023d999d0f85e8c9bf105767991199a">addConstantUpperBound</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t ub)</td></tr>
<tr class="memdesc:a6023d999d0f85e8c9bf105767991199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant upper bound constraint for the specified expression.  <a href="#a6023d999d0f85e8c9bf105767991199a">More...</a><br /></td></tr>
<tr class="separator:a6023d999d0f85e8c9bf105767991199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a06e4c5fcf51e01bf82d9d82a26ff316a">setIdToConstant</a> (unsigned pos, int64_t val)</td></tr>
<tr class="memdesc:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the identifier at the specified position to a constant.  <a href="#a06e4c5fcf51e01bf82d9d82a26ff316a">More...</a><br /></td></tr>
<tr class="separator:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dee3803932dd1553f52b71f0372b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04dee3803932dd1553f52b71f0372b12">setIdToConstant</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id, int64_t val)</td></tr>
<tr class="memdesc:a04dee3803932dd1553f52b71f0372b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the identifier corresponding to the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> id to a constant.  <a href="#a04dee3803932dd1553f52b71f0372b12">More...</a><br /></td></tr>
<tr class="separator:a04dee3803932dd1553f52b71f0372b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ff9510294db04bfac4065117f27645"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae1ff9510294db04bfac4065117f27645">findId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id, unsigned *pos) const</td></tr>
<tr class="memdesc:ae1ff9510294db04bfac4065117f27645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#ae1ff9510294db04bfac4065117f27645">More...</a><br /></td></tr>
<tr class="separator:ae1ff9510294db04bfac4065117f27645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c40a21ee894ea756e84b90a1420d54d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a5c40a21ee894ea756e84b90a1420d54d">containsId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id) const</td></tr>
<tr class="memdesc:a5c40a21ee894ea756e84b90a1420d54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise.  <a href="#a5c40a21ee894ea756e84b90a1420d54d">More...</a><br /></td></tr>
<tr class="separator:a5c40a21ee894ea756e84b90a1420d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9555bccd54ea166ce653e262797218da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9555bccd54ea166ce653e262797218da">addDimId</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="separator:a9555bccd54ea166ce653e262797218da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66197a3e2cc40803abe7cb12685571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7e66197a3e2cc40803abe7cb12685571">addSymbolId</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="separator:a7e66197a3e2cc40803abe7cb12685571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477866201deff5c6a17201fc8669dc15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a477866201deff5c6a17201fc8669dc15">addLocalId</a> (unsigned pos)</td></tr>
<tr class="separator:a477866201deff5c6a17201fc8669dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faafc96161faad6ec9faf0fb546e4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2faafc96161faad6ec9faf0fb546e4ed">addId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind, unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="memdesc:a2faafc96161faad6ec9faf0fb546e4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dimensional identifier.  <a href="#a2faafc96161faad6ec9faf0fb546e4ed">More...</a><br /></td></tr>
<tr class="separator:a2faafc96161faad6ec9faf0fb546e4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c99c8a9d566c1f7fc37671d531c19a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a66c99c8a9d566c1f7fc37671d531c19a">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id)</td></tr>
<tr class="memdesc:a66c99c8a9d566c1f7fc37671d531c19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system.  <a href="#a66c99c8a9d566c1f7fc37671d531c19a">More...</a><br /></td></tr>
<tr class="separator:a66c99c8a9d566c1f7fc37671d531c19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6350cf623d371e8a91a3a18a08097983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6350cf623d371e8a91a3a18a08097983">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="memdesc:a6350cf623d371e8a91a3a18a08097983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the affine value map with this FlatAffineConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map.  <a href="#a6350cf623d371e8a91a3a18a08097983">More...</a><br /></td></tr>
<tr class="separator:a6350cf623d371e8a91a3a18a08097983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f95bfc66876ee75db55381eafbb8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:a15f95bfc66876ee75db55381eafbb8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions match one to one to the dimensions of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="#a15f95bfc66876ee75db55381eafbb8f2">More...</a><br /></td></tr>
<tr class="separator:a15f95bfc66876ee75db55381eafbb8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1457dc3d54274c1519c6553be921d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a63d1457dc3d54274c1519c6553be921d">projectOut</a> (unsigned pos, unsigned num)</td></tr>
<tr class="memdesc:a63d1457dc3d54274c1519c6553be921d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) 'num' identifiers starting at position 'pos'.  <a href="#a63d1457dc3d54274c1519c6553be921d">More...</a><br /></td></tr>
<tr class="separator:a63d1457dc3d54274c1519c6553be921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8c3d0c1b0bad5d54e4b5f91910c52503">projectOut</a> (unsigned pos)</td></tr>
<tr class="separator:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f74eab80eb71234f457d296716dbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a49f74eab80eb71234f457d296716dbec">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id)</td></tr>
<tr class="memdesc:a49f74eab80eb71234f457d296716dbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> .  <a href="#a49f74eab80eb71234f457d296716dbec">More...</a><br /></td></tr>
<tr class="separator:a49f74eab80eb71234f457d296716dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74219ea7114c7c5ddec36845a7369f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a74219ea7114c7c5ddec36845a7369f6f">removeId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> idKind, unsigned pos)</td></tr>
<tr class="separator:a74219ea7114c7c5ddec36845a7369f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e3fb602c03ba136b94b31a58bca727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa7e3fb602c03ba136b94b31a58bca727">removeId</a> (unsigned pos)</td></tr>
<tr class="separator:aa7e3fb602c03ba136b94b31a58bca727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282561f245c5a8ba5b8467af590d80f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a282561f245c5a8ba5b8467af590d80f8">removeDim</a> (unsigned pos)</td></tr>
<tr class="separator:a282561f245c5a8ba5b8467af590d80f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae3d4894b1c67f1e06424e1453c585bbf">removeEquality</a> (unsigned pos)</td></tr>
<tr class="separator:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e6041df1c8414405c512d50a0da54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab21e6041df1c8414405c512d50a0da54">removeInequality</a> (unsigned pos)</td></tr>
<tr class="separator:ab21e6041df1c8414405c512d50a0da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4924b4c54d6823f8e52933ca960c1ff">setDimSymbolSeparation</a> (unsigned newSymbolCount)</td></tr>
<tr class="memdesc:ad4924b4c54d6823f8e52933ca960c1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="#ad4924b4c54d6823f8e52933ca960c1ff">More...</a><br /></td></tr>
<tr class="separator:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00b3e95728c04dfbc98c2907e3b815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3d00b3e95728c04dfbc98c2907e3b815">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a3d00b3e95728c04dfbc98c2907e3b815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol identifiers which are loop IVs to dim identifiers.  <a href="#a3d00b3e95728c04dfbc98c2907e3b815">More...</a><br /></td></tr>
<tr class="separator:a3d00b3e95728c04dfbc98c2907e3b815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201799397e672780c6bce3674f969f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a201799397e672780c6bce3674f969f3b">setAndEliminate</a> (unsigned pos, int64_t constVal)</td></tr>
<tr class="memdesc:a201799397e672780c6bce3674f969f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified identifier to a constant and removes it.  <a href="#a201799397e672780c6bce3674f969f3b">More...</a><br /></td></tr>
<tr class="separator:a201799397e672780c6bce3674f969f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1041e7db596d628253f1d8d7c8222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a00e1041e7db596d628253f1d8d7c8222">constantFoldId</a> (unsigned pos)</td></tr>
<tr class="memdesc:a00e1041e7db596d628253f1d8d7c8222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system.  <a href="#a00e1041e7db596d628253f1d8d7c8222">More...</a><br /></td></tr>
<tr class="separator:a00e1041e7db596d628253f1d8d7c8222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad67b4c81a969b09cf5c4bc723cda93d5">constantFoldIdRange</a> (unsigned pos, unsigned num)</td></tr>
<tr class="memdesc:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls constantFoldId for the specified range of identifiers, 'num' identifiers starting at position 'pos'.  <a href="#ad67b4c81a969b09cf5c4bc723cda93d5">More...</a><br /></td></tr>
<tr class="separator:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afeb8348eba3bd5c81db503336ae2ebfc">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:afeb8348eba3bd5c81db503336ae2ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of 'this' set and that of 'other', with the symbols being treated specially.  <a href="#afeb8348eba3bd5c81db503336ae2ebfc">More...</a><br /></td></tr>
<tr class="separator:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86efbe8f7101ca9946ef7978194e0549"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a86efbe8f7101ca9946ef7978194e0549">areIdsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a86efbe8f7101ca9946ef7978194e0549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'true' if this constraint system and 'other' are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order.  <a href="#a86efbe8f7101ca9946ef7978194e0549">More...</a><br /></td></tr>
<tr class="separator:a86efbe8f7101ca9946ef7978194e0549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6511f180daae3af295023e7b45336"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60f6511f180daae3af295023e7b45336">mergeAndAlignIdsWithOther</a> (unsigned offset, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *other)</td></tr>
<tr class="memdesc:a60f6511f180daae3af295023e7b45336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align the identifiers of 'this' and 'other' starting at 'offset', so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with this's original identifiers appearing first followed by any of other's identifiers that didn't appear in 'this'.  <a href="#a60f6511f180daae3af295023e7b45336">More...</a><br /></td></tr>
<tr class="separator:a60f6511f180daae3af295023e7b45336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fa3994a809e5994fdc32035b54e4b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a747fa3994a809e5994fdc32035b54e4b">getNumConstraints</a> () const</td></tr>
<tr class="separator:a747fa3994a809e5994fdc32035b54e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0937c7d6a0a23146fbc6d5caf5e95a8b">getNumIds</a> () const</td></tr>
<tr class="separator:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb25117553419fb47427704e6c9bb84"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0bb25117553419fb47427704e6c9bb84">getNumDimIds</a> () const</td></tr>
<tr class="separator:a0bb25117553419fb47427704e6c9bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8074c726e597eb5a963a68451bb7fe"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aff8074c726e597eb5a963a68451bb7fe">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:aff8074c726e597eb5a963a68451bb7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a221a2c98d7a9019f0a93cb1b070152f3">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12365660bdc368e87b6fc73f12e3e86"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab12365660bdc368e87b6fc73f12e3e86">getNumLocalIds</a> () const</td></tr>
<tr class="separator:ab12365660bdc368e87b6fc73f12e3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc5592f55bba9543cb957274d145e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aacc5592f55bba9543cb957274d145e97">getIds</a> () const</td></tr>
<tr class="separator:aacc5592f55bba9543cb957274d145e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df54b69026d3981d00de5ce8e1a4cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6df54b69026d3981d00de5ce8e1a4cd4">getIds</a> ()</td></tr>
<tr class="separator:a6df54b69026d3981d00de5ce8e1a4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa36e5e1a5b66abc593cf169bce4b19e4">getId</a> (unsigned pos) const</td></tr>
<tr class="memdesc:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optional <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the pos^th identifier.  <a href="#aa36e5e1a5b66abc593cf169bce4b19e4">More...</a><br /></td></tr>
<tr class="separator:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142fba494ecf189c0decb4f0c5133eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a142fba494ecf189c0decb4f0c5133eb8">getId</a> (unsigned pos)</td></tr>
<tr class="separator:a142fba494ecf189c0decb4f0c5133eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6825cb13390479a204da6d3b1124ff92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6825cb13390479a204da6d3b1124ff92">getIdValue</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a6825cb13390479a204da6d3b1124ff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a6825cb13390479a204da6d3b1124ff92">More...</a><br /></td></tr>
<tr class="separator:a6825cb13390479a204da6d3b1124ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181c4aa2ddc90806d2b2f86bb6a91f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a181c4aa2ddc90806d2b2f86bb6a91f1a">getIdValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *values) const</td></tr>
<tr class="memdesc:a181c4aa2ddc90806d2b2f86bb6a91f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Values associated with identifiers in range [start, end).  <a href="#a181c4aa2ddc90806d2b2f86bb6a91f1a">More...</a><br /></td></tr>
<tr class="separator:a181c4aa2ddc90806d2b2f86bb6a91f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5669e6de739424cd4e46e8cbc4c9b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae5669e6de739424cd4e46e8cbc4c9b5f">getAllIdValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *values) const</td></tr>
<tr class="separator:ae5669e6de739424cd4e46e8cbc4c9b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a77ff33d7c48f5d8de4f26b95f2a94034">setIdValue</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a77ff33d7c48f5d8de4f26b95f2a94034">More...</a><br /></td></tr>
<tr class="separator:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda84f68040789ebf27848f7bcaa169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8bda84f68040789ebf27848f7bcaa169">setIdValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values)</td></tr>
<tr class="memdesc:a8bda84f68040789ebf27848f7bcaa169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Values associated with identifiers in the range [start, end).  <a href="#a8bda84f68040789ebf27848f7bcaa169">More...</a><br /></td></tr>
<tr class="separator:a8bda84f68040789ebf27848f7bcaa169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac662ea0313d9bcac2e44925b6be670e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac662ea0313d9bcac2e44925b6be670e8">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ac662ea0313d9bcac2e44925b6be670e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this list of constraints and copies other into it.  <a href="#ac662ea0313d9bcac2e44925b6be670e8">More...</a><br /></td></tr>
<tr class="separator:ac662ea0313d9bcac2e44925b6be670e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b9a3d63c5f64c2230e5e661c52217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a159b9a3d63c5f64c2230e5e661c52217">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *lbFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr) const</td></tr>
<tr class="memdesc:a159b9a3d63c5f64c2230e5e661c52217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier.  <a href="#a159b9a3d63c5f64c2230e5e661c52217">More...</a><br /></td></tr>
<tr class="separator:a159b9a3d63c5f64c2230e5e661c52217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a299832c686eb594598d8a61957e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4a299832c686eb594598d8a61957e81">getConstantLowerBound</a> (unsigned pos) const</td></tr>
<tr class="memdesc:ad4a299832c686eb594598d8a61957e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound for the pos^th identifier if there is one; None otherwise.  <a href="#ad4a299832c686eb594598d8a61957e81">More...</a><br /></td></tr>
<tr class="separator:ad4a299832c686eb594598d8a61957e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908b49c8a201df00af8b924064116c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a908b49c8a201df00af8b924064116c19">getConstantUpperBound</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a908b49c8a201df00af8b924064116c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant upper bound for the pos^th identifier if there is one; None otherwise.  <a href="#a908b49c8a201df00af8b924064116c19">More...</a><br /></td></tr>
<tr class="separator:a908b49c8a201df00af8b924064116c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">getLowerAndUpperBound</a> (unsigned pos, unsigned offset, unsigned num, unsigned symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:aad0cdbe1cff606a9b364e734ca09dc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the pos^th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols.  <a href="#aad0cdbe1cff606a9b364e734ca09dc52">More...</a><br /></td></tr>
<tr class="separator:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa635e50de116843fba9c4d6213ce14c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afa635e50de116843fba9c4d6213ce14c">isHyperRectangular</a> (unsigned pos, unsigned num) const</td></tr>
<tr class="memdesc:afa635e50de116843fba9c4d6213ce14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers.  <a href="#afa635e50de116843fba9c4d6213ce14c">More...</a><br /></td></tr>
<tr class="separator:afa635e50de116843fba9c4d6213ce14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab3a710d4a8812b2e76eb3908a5767dac">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:ab3a710d4a8812b2e76eb3908a5767dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="#ab3a710d4a8812b2e76eb3908a5767dac">More...</a><br /></td></tr>
<tr class="separator:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60b9abcf1ae4683b7ed214125d4d05c8">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check to detect redundant inequalities thatn removeTrivialRedundancy.  <a href="#a60b9abcf1ae4683b7ed214125d4d05c8">More...</a><br /></td></tr>
<tr class="separator:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4b4985a33143cd113df0f945c2bb6d8b">clearConstraints</a> ()</td></tr>
<tr class="separator:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2f50452ba560992138f6df070045e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a32f2f50452ba560992138f6df070045e">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:a32f2f50452ba560992138f6df070045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755c04bef03df1b8130b1a4e76ac605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9755c04bef03df1b8130b1a4e76ac605">dump</a> () const</td></tr>
<tr class="separator:a9755c04bef03df1b8130b1a4e76ac605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A flat list of affine equalities and inequalities in the form. </p>
<p>Inequality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} &gt;= 0 Equality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} == 0</p>
<p><a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> stores coefficients in a contiguous buffer (one buffer for equalities and one for inequalities). The size of each buffer is numReservedCols * number of inequalities (or equalities). The reserved size is numReservedCols * numReservedInequalities (or numReservedEqualities). A coefficient (r, c) lives at the location numReservedCols * r + c in the buffer. The extra space between <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd" title="Returns the number of columns in the constraint system. ">getNumCols()</a> and numReservedCols exists to prevent frequent movement of data when adding columns, especially at the end.</p>
<p>The identifiers x_0, x_1, ... appear in the order: dimensional identifiers, symbolic identifiers, and local identifiers. The local identifiers correspond to local/internal variables created when converting from <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s containing mod's and div's; they are thus needed to increase representational power. Each local identifier is always (by construction) a floordiv of a pure add/mul affine function of dimensional, symbolic, and other local identifiers, in a non-mutually recursive way. Hence, every local identifier can ultimately always be recovered as an affine function of dimensional and symbolic identifiers (involving floordiv's); note however that some floordiv combinations are converted to mod's by <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> construction. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00229">229</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab47fbec6c4aff6faece95521b103fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47fbec6c4aff6faece95521b103fed2">&#9670;&nbsp;</a></span>IdKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">mlir::FlatAffineConstraints::IdKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7"></a>Dimension&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372"></a>Symbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778"></a>Local&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00231">231</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67d39a02671f878053effe3493e6544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d39a02671f878053effe3493e6544a">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00235">235</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a2c6c8b02abc69721d025b1ca23db2b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6c8b02abc69721d025b1ca23db2b2e">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00256">256</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

</div>
</div>
<a id="a485ccacf0a047233d064351ff31cd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485ccacf0a047233d064351ff31cd9c1">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const HyperRectangularSet &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed4103886f4e5761c76b4073aa1de73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4103886f4e5761c76b4073aa1de73">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these. </p>
<p>The constructed system will only include equalities. </p>

</div>
</div>
<a id="a4333c62fce350f020f58b6fb0d2faf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4333c62fce350f020f58b6fb0d2faf0f">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04009cfc4f3c97dbff1cf9594c0f7c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00334">334</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00418">addLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

</div>
</div>
<a id="a7947eee63586b73c35a239e63248a9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947eee63586b73c35a239e63248a9bc">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerValueSet.html">IntegerValueSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an affine constraint system from an <a class="el" href="classmlir_1_1IntegerValueSet.html" title="An IntegerValueSet is an integer set plus its operands. ">IntegerValueSet</a>. </p>

</div>
</div>
<a id="a4b5f989f74501c929910cc94637209ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5f989f74501c929910cc94637209ce">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00303">303</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00362">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00571">getIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00366">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumReservedEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00358">getNumReservedInequalities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>.</p>

</div>
</div>
<a id="af84814b8b20bb9768814270d71952a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84814b8b20bb9768814270d71952a9d">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8074122b77beb705d010169667ae9efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8074122b77beb705d010169667ae9efe">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8824fdedbdc984ff79e3b812016f3b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8824fdedbdc984ff79e3b812016f3b2c">&#9670;&nbsp;</a></span>~FlatAffineConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::~FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00293">293</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00151">mlir::MutableAffineMap::reset()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4150bc63be2852d5efbbd31d1b938a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4150bc63be2852d5efbbd31d1b938a8">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps. </p>
<p>The right identifier is first looked up using forOp's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new identifiers that are found in the bound operands of the 'affine.for' operation are added as trailing identifiers (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00833">833</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01894">addConstantLowerBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01904">addConstantUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">mlir::getIndexSet()</a>.</p>

</div>
</div>
<a id="a7876c2038d87d8df799eb8e8010670da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876c2038d87d8df799eb8e8010670da">&#9670;&nbsp;</a></span>addConstantLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant lower bound constraint for the specified identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01894">1894</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">mlir::normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a05a6c2a425f192f14a650791fb1154c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a6c2a425f192f14a650791fb1154c3">&#9670;&nbsp;</a></span>addConstantLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant lower bound constraint for the specified expression. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01914">1914</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

</div>
</div>
<a id="ae79201460364553813e818c2f4c47b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79201460364553813e818c2f4c47b26">&#9670;&nbsp;</a></span>addConstantUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant upper bound constraint for the specified identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01904">1904</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">mlir::boundCheckLoadOrStoreOp()</a>.</p>

</div>
</div>
<a id="a6023d999d0f85e8c9bf105767991199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6023d999d0f85e8c9bf105767991199a">&#9670;&nbsp;</a></span>addConstantUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant upper bound constraint for the specified expression. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01925">1925</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

</div>
</div>
<a id="a9555bccd54ea166ce653e262797218da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9555bccd54ea166ce653e262797218da">&#9670;&nbsp;</a></span>addDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addDimId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00422">422</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a45df72c07b67e459ece93a1076344210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df72c07b67e459ece93a1076344210">&#9670;&nbsp;</a></span>addEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01880">1880</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00584">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>.</p>

</div>
</div>
<a id="a2faafc96161faad6ec9faf0fb546e4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faafc96161faad6ec9faf0fb546e4ed">&#9670;&nbsp;</a></span>addId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a dimensional identifier. </p>
<p>The added column is initialized to zero. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00432">432</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00422">addDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00418">addLocalId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00426">addSymbolId()</a>.</p>

</div>
</div>
<a id="a66c99c8a9d566c1f7fc37671d531c19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c99c8a9d566c1f7fc37671d531c19a">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system. </p>
<p>`id' has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The identifier is added to the end of the existing dims or symbols. Additional information on the identifier is extracted from the IR and added to the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00811">811</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00422">addDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00426">addSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01979">containsId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01566">mlir::isForInductionVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00109">mlir::isTopLevelValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01993">setIdToConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>.</p>

</div>
</div>
<a id="a9a440a9b51c09ea27d100fb62fb32a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a440a9b51c09ea27d100fb62fb32a7f">&#9670;&nbsp;</a></span>addInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inEq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01887">1887</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00584">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a9d81cc0ca235dba7982f6cecc66f2506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d81cc0ca235dba7982f6cecc66f2506">&#9670;&nbsp;</a></span>addLocalFloorDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addLocalFloorDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in 'dividend' and with respect to a positive constant 'divisor'. </p>
<p>Two constraints are added to the system to capture equivalence with the floordiv: q = dividend floordiv c &lt;=&gt; c*q &lt;= dividend &lt;= c*q + c - 1.</p>
<p>Two constraints are added to the system to capture equivalence with the floordiv. q = expr floordiv c &lt;=&gt; c*q &lt;= expr &lt;= c*q + c - 1. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01943">1943</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00418">addLocalId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>.</p>

</div>
</div>
<a id="a477866201deff5c6a17201fc8669dc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477866201deff5c6a17201fc8669dc15">&#9670;&nbsp;</a></span>addLocalId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addLocalId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00418">418</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a944078deda4fba2b98635152d2759bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944078deda4fba2b98635152d2759bfe">&#9670;&nbsp;</a></span>addLowerOrUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addLowerOrUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a lower or an upper bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands. </p>
<p>If <code>eq</code> is true, add a single equality equal to the bound map's first result expr. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01751">1751</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00731">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00589">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00611">setIdValues()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00280">mlir::simplifyAffineMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00779">turnDimIntoSymbol()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01842">addSliceBounds()</a>.</p>

</div>
</div>
<a id="ad5d2543f40e0fc1c4701f20d4b891deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d2543f40e0fc1c4701f20d4b891deb">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds slice lower bounds represented by lower bounds in 'lbMaps' and upper bounds in 'ubMaps' to each identifier in the constraint system which has a value in 'values'. </p>
<p>Note that both lower/upper bounds share the same operand list 'operands'. This function assumes 'values.size' == 'lbMaps.size' == 'ubMaps.size'. Note that both lower/upper bounds use operands from 'operands'. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01842">1842</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00171">mlir::AffineMap::getResult()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="a7e66197a3e2cc40803abe7cb12685571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66197a3e2cc40803abe7cb12685571">&#9670;&nbsp;</a></span>addSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addSymbolId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00426">426</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a6e4973d2d62dbf7779d1e350fec9911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4973d2d62dbf7779d1e350fec9911e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends constraints from 'other' into this. </p>
<p>This is equivalent to an intersection with no simplification of any sort attempted. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00400">400</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00362">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00366">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>.</p>

</div>
</div>
<a id="a86efbe8f7101ca9946ef7978194e0549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86efbe8f7101ca9946ef7978194e0549">&#9670;&nbsp;</a></span>areIdsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::areIdsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 'true' if this constraint system and 'other' are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order. </p>
<p>Calls areIdsAligned to check if two constraint systems have the same set of identifiers in the same order.</p>
<p>Returns 'false' otherwise.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00513">513</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="aaeb4c8e8b0bf86fa1609a32bd9028536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">&#9670;&nbsp;</a></span>atEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value at the specified equality row and column. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00324">324</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02064">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00992">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02295">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="a0b80ebb1a0929a30c4401d297a420d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b80ebb1a0929a30c4401d297a420d9e">&#9670;&nbsp;</a></span>atEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00327">327</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="a950735c15d0d1757984210922c7118c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950735c15d0d1757984210922c7118c0">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00331">331</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01391">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00992">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01464">fillInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01097">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01368">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02295">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01472">negateInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01480">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02356">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="ae02ba9253168af09117779ede6e1020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ba9253168af09117779ede6e1020f">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00335">335</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="ac662ea0313d9bcac2e44925b6be670e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac662ea0313d9bcac2e44925b6be670e8">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears this list of constraints and copies other into it. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02426">2426</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00571">getIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>.</p>

</div>
</div>
<a id="a4b4985a33143cd113df0f945c2bb6d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4985a33143cd113df0f945c2bb6d8b">&#9670;&nbsp;</a></span>clearConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::clearConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02713">2713</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00367">reset()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a0932fcc3e8ee32f1af944a1f33a9abc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0932fcc3e8ee32f1af944a1f33a9abc3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt; FlatAffineConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00329">329</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a6350cf623d371e8a91a3a18a08097983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6350cf623d371e8a91a3a18a08097983">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes the affine value map with this FlatAffineConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. </p>
<p>Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s are used to look up the right positions in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> with which to associate. The dimensional and symbolic operands of vMap should match 1:1 (in the same order) with those of this constraint system, but the latter could have additional trailing operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00641">641</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00422">addDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00294">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00151">mlir::AffineValueMap::getNumOperands()</a>, <a class="el" href="AffineStructures_8h_source.html#l00154">mlir::AffineValueMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">mlir::AffineValueMap::getOperand()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00290">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00611">setIdValues()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

</div>
</div>
<a id="a15f95bfc66876ee75db55381eafbb8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f95bfc66876ee75db55381eafbb8f2">&#9670;&nbsp;</a></span>composeMatchingMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::composeMatchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an affine map whose dimensions match one to one to the dimensions of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>
<p>The results of the map 'other' are added as the leading dimensions of this constraint system. Returns failure if 'other' is a semi-affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00713">713</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00422">addDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00418">addLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

</div>
</div>
<a id="a00e1041e7db596d628253f1d8d7c8222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e1041e7db596d628253f1d8d7c8222">&#9670;&nbsp;</a></span>constantFoldId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::constantFoldId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02064">2064</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02077">constantFoldIdRange()</a>.</p>

</div>
</div>
<a id="ad67b4c81a969b09cf5c4bc723cda93d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b4c81a969b09cf5c4bc723cda93d5">&#9670;&nbsp;</a></span>constantFoldIdRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::constantFoldIdRange </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method calls constantFoldId for the specified range of identifiers, 'num' identifiers starting at position 'pos'. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02077">2077</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02064">constantFoldId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>.</p>

</div>
</div>
<a id="a5c40a21ee894ea756e84b90a1420d54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c40a21ee894ea756e84b90a1420d54d">&#9670;&nbsp;</a></span>containsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::containsId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01979">1979</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="a3d00b3e95728c04dfbc98c2907e3b815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d00b3e95728c04dfbc98c2907e3b815">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol identifiers which are loop IVs to dim identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00798">798</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a9755c04bef03df1b8130b1a4e76ac605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9755c04bef03df1b8130b1a4e76ac605">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02348">2348</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>.</p>

</div>
</div>
<a id="ae1ff9510294db04bfac4065117f27645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ff9510294db04bfac4065117f27645">&#9670;&nbsp;</a></span>findId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::findId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns true if found (false otherwise). `pos' is set to the (column) position of the identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01967">1967</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01842">addSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02705">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02004">setIdToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00779">turnDimIntoSymbol()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="ae5669e6de739424cd4e46e8cbc4c9b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5669e6de739424cd4e46e8cbc4c9b5f">&#9670;&nbsp;</a></span>getAllIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::getAllIdValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00601">601</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="a159b9a3d63c5f64c2230e5e661c52217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159b9a3d63c5f64c2230e5e661c52217">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>lbFloorDivisor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>ub</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier. </p>
<p>Returns the extent (upper bound - lower bound) of the specified identifier if it is found to be a constant; returns None if it's not a constant.</p>
<p>Returns None if it's not a constant. This method employs trivial (low complexity / cost) checks and detection. Symbolic identifiers are treated specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. See comments at function definition for examples. 'lb' and 'lbDivisor', if provided, are used to express the lower bound associated with the constant difference: 'lb' has the coefficients and lbDivisor, the divisor. For eg., if the lower bound is [(s0 + s2 - 1) floordiv 32] for a system with three symbolic identifiers, *lb = [1, 0, 1], lbDivisor = 32.</p>
<p>This methods treats symbolic identifiers specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. See comments at function definition for example. 'lb', if provided, is set to the lower bound associated with the constant difference. Note that 'lb' is purely symbolic and thus will contain the coefficients of the symbolic identifiers and the constant coefficient. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02097">2097</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="MathExtras_8h_source.html#l00023">mlir::ceilDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="MathExtras_8h_source.html#l00031">mlir::floorDiv()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02670">projectOut()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="ad4a299832c686eb594598d8a61957e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a299832c686eb594598d8a61957e81">&#9670;&nbsp;</a></span>getConstantLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant lower bound for the pos^th identifier if there is one; None otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02283">2283</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a908b49c8a201df00af8b924064116c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908b49c8a201df00af8b924064116c19">&#9670;&nbsp;</a></span>getConstantUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant upper bound for the pos^th identifier if there is one; None otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02289">2289</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a0673b512906bb0fed9e4c7244f9f0217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0673b512906bb0fed9e4c7244f9f0217">&#9670;&nbsp;</a></span>getEquality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getEquality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00362">362</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>.</p>

</div>
</div>
<a id="aa36e5e1a5b66abc593cf169bce4b19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36e5e1a5b66abc593cf169bce4b19e4">&#9670;&nbsp;</a></span>getId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::FlatAffineConstraints::getId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optional <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the pos^th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00579">579</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="a142fba494ecf189c0decb4f0c5133eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142fba494ecf189c0decb4f0c5133eb8">&#9670;&nbsp;</a></span>getId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;&amp; mlir::FlatAffineConstraints::getId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00580">580</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="aacc5592f55bba9543cb957274d145e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc5592f55bba9543cb957274d145e97">&#9670;&nbsp;</a></span>getIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineConstraints::getIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00571">571</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00520">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02426">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a6df54b69026d3981d00de5ce8e1a4cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df54b69026d3981d00de5ce8e1a4cd4">&#9670;&nbsp;</a></span>getIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineConstraints::getIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00574">574</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="a6825cb13390479a204da6d3b1124ff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6825cb13390479a204da6d3b1124ff92">&#9670;&nbsp;</a></span>getIdValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineConstraints::getIdValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> identifier was associated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00584">584</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00537">getCommonBlock()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00515">getNumCommonLoops()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a181c4aa2ddc90806d2b2f86bb6a91f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181c4aa2ddc90806d2b2f86bb6a91f1a">&#9670;&nbsp;</a></span>getIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::getIdValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Values associated with identifiers in range [start, end). </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> was associated with one of these identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00591">591</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00210">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a92b9b04e17d80d48a79c0e09710c2be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9b04e17d80d48a79c0e09710c2be6">&#9670;&nbsp;</a></span>getInequality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getInequality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00366">366</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00594">mlir::toAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01518">getLowerAndUpperBound()</a>.</p>

</div>
</div>
<a id="aad0cdbe1cff606a9b364e734ca09dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cdbe1cff606a9b364e734ca09dc52">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; FlatAffineConstraints::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>symStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound of the pos^th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols. </p>
<p>The returned multi-dimensional maps in the pair represent the max and min of potentially multiple affine expressions. The upper bound is exclusive. 'localExprs' holds pre-computed <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s for all local identifiers in the system. </p>
<p>Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01518">1518</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineStructures_8h_source.html#l00366">getInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01368">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00594">mlir::toAffineExpr()</a>.</p>

</div>
</div>
<a id="ad6dafa2401aead0909b87b92d41bfbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dafa2401aead0909b87b92d41bfbbd">&#9670;&nbsp;</a></span>getNumCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00340">340</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01894">addConstantLowerBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01904">addConstantUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01880">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00584">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02064">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01391">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00992">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01464">fillInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02295">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01472">negateInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02670">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01480">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02356">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01993">setIdToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a747fa3994a809e5994fdc32035b54e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747fa3994a809e5994fdc32035b54e4b">&#9670;&nbsp;</a></span>getNumConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00560">560</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01130">isEmpty()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>.</p>

</div>
</div>
<a id="a221a2c98d7a9019f0a93cb1b070152f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221a2c98d7a9019f0a93cb1b070152f3">&#9670;&nbsp;</a></span>getNumDimAndSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumDimAndSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00566">566</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00210">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00798">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01518">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a0bb25117553419fb47427704e6c9bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb25117553419fb47427704e6c9bb84">&#9670;&nbsp;</a></span>getNumDimIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumDimIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00564">564</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00584">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00798">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01518">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00515">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00779">turnDimIntoSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a963e712e6a344acbadfa413940487704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e712e6a344acbadfa413940487704">&#9670;&nbsp;</a></span>getNumEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00342">342</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02295">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02012">removeEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="a0937c7d6a0a23146fbc6d5caf5e95a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0937c7d6a0a23146fbc6d5caf5e95a8b">&#9670;&nbsp;</a></span>getNumIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00563">563</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02426">clearAndCopyFrom()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02064">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01391">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02028">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01097">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01368">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01130">isEmpty()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02670">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="a50f382f6a3f7062ff36e3dce1920c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f382f6a3f7062ff36e3dce1920c4c9">&#9670;&nbsp;</a></span>getNumInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00348">348</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01097">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01368">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02295">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01480">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02356">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00530">swapId()</a>.</p>

</div>
</div>
<a id="ab12365660bdc368e87b6fc73f12e3e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12365660bdc368e87b6fc73f12e3e86">&#9670;&nbsp;</a></span>getNumLocalIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumLocalIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00567">567</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01943">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01518">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01027">shiftColumnsToLeft()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a597e435e789ef833a1e0cc80cd82a388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597e435e789ef833a1e0cc80cd82a388">&#9670;&nbsp;</a></span>getNumReservedEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumReservedEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00354">354</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>.</p>

</div>
</div>
<a id="a3617c7a6eef7e4c3d1b1845025900adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3617c7a6eef7e4c3d1b1845025900adf">&#9670;&nbsp;</a></span>getNumReservedInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumReservedInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00358">358</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>.</p>

</div>
</div>
<a id="aff8074c726e597eb5a963a68451bb7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8074c726e597eb5a963a68451bb7fe">&#9670;&nbsp;</a></span>getNumSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00565">565</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00432">addId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00400">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">FlatAffineConstraints()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02320">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00779">turnDimIntoSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02744">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a27fe40151ae13ca4d10c425937ff70f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fe40151ae13ca4d10c425937ff70f2">&#9670;&nbsp;</a></span>getSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::getSliceBounds </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubMaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as an affine map of the remaining identifiers (dimensional and symbolic). </p>
<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as affine maps of the remaining identifiers (dimensional and symbolic identifiers).</p>
<p>This method is able to detect identifiers as floordiv's and mod's of affine expressions of other identifiers with respect to (positive) constants. Sets bound map to a null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> if such a bound can't be found (or yet unimplemented).</p>
<p>Local identifiers are themselves explicitly computed as affine functions of other identifiers in this process if needed. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01579">1579</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01391">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01286">detectAsMod()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02144">mlir::AffineMap::dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02348">dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8h_source.html#l00235">FlatAffineConstraints()</a>, <a class="el" href="MathExtras_8h_source.html#l00031">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00277">mlir::getAffineConstantExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00252">mlir::getAffineDimExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00262">mlir::getAffineSymbolExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02283">getConstantLowerBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02289">getConstantUpperBound()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00839">mlir::simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">mlir::getComputationSliceState()</a>.</p>

</div>
</div>
<a id="a6ddc2ce92fc0297fbc8bfc62241c4472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc2ce92fc0297fbc8bfc62241c4472">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01130">1130</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01097">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00560">getNumConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">mlir::checkMemrefAccessDependence()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01480">removeRedundantInequalities()</a>.</p>

</div>
</div>
<a id="af318337e58529a47cd9c9e38e11b3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318337e58529a47cd9c9e38e11b3e67">&#9670;&nbsp;</a></span>isEmptyByGCDTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmptyByGCDTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01186">1186</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00992">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00893">findConstraintWithNonZeroAt()</a>, <a class="el" href="MathExtras_8h_source.html#l00031">mlir::floorDiv()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00912">normalizeConstraintByGCD()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02012">removeEquality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01130">isEmpty()</a>.</p>

</div>
</div>
<a id="afa635e50de116843fba9c4d6213ce14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa635e50de116843fba9c4d6213ce14c">&#9670;&nbsp;</a></span>isHyperRectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isHyperRectangular </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02295">2295</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>.</p>

</div>
</div>
<a id="a60f6511f180daae3af295023e7b45336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6511f180daae3af295023e7b45336">&#9670;&nbsp;</a></span>mergeAndAlignIdsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::mergeAndAlignIdsWithOther </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align the identifiers of 'this' and 'other' starting at 'offset', so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with this's original identifiers appearing first followed by any of other's identifiers that didn't appear in 'this'. </p>
<p>Local identifiers of each system are by design separate/local and are placed one after other (this's followed by other's). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00633">633</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a32f2f50452ba560992138f6df070045e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f2f50452ba560992138f6df070045e">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02320">2320</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00560">getNumConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02348">dump()</a>.</p>

</div>
</div>
<a id="a63d1457dc3d54274c1519c6553be921d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d1457dc3d54274c1519c6553be921d">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out (aka eliminates) 'num' identifiers starting at position 'pos'. </p>
<p>The resulting constraint system is the shadow along the dimensions that still exist. This method may not always be integer exact. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02670">2670</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01097">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">mlir::getComputationSliceState()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>.</p>

</div>
</div>
<a id="a8c3d0c1b0bad5d54e4b5f91910c52503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d0c1b0bad5d54e4b5f91910c52503">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00492">492</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00492">projectOut()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00492">projectOut()</a>.</p>

</div>
</div>
<a id="a49f74eab80eb71234f457d296716dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f74eab80eb71234f457d296716dbec">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> . </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02705">2705</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>.</p>

</div>
</div>
<a id="a282561f245c5a8ba5b8467af590d80f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282561f245c5a8ba5b8467af590d80f8">&#9670;&nbsp;</a></span>removeDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeDim </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3d4894b1c67f1e06424e1453c585bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d4894b1c67f1e06424e1453c585bbf">&#9670;&nbsp;</a></span>removeEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeEquality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02012">2012</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01186">isEmptyByGCDTest()</a>.</p>

</div>
</div>
<a id="a74219ea7114c7c5ddec36845a7369f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74219ea7114c7c5ddec36845a7369f6f">&#9670;&nbsp;</a></span>removeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>idKind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02053">setAndEliminate()</a>.</p>

</div>
</div>
<a id="aa7e3fb602c03ba136b94b31a58bca727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e3fb602c03ba136b94b31a58bca727">&#9670;&nbsp;</a></span>removeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02433">2433</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ab21e6041df1c8414405c512d50a0da54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21e6041df1c8414405c512d50a0da54">&#9670;&nbsp;</a></span>removeInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeInequality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60b9abcf1ae4683b7ed214125d4d05c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b9abcf1ae4683b7ed214125d4d05c8">&#9670;&nbsp;</a></span>removeRedundantInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeRedundantInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more expensive check to detect redundant inequalities thatn removeTrivialRedundancy. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01480">1480</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01464">fillInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01130">isEmpty()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01472">negateInequality()</a>.</p>

</div>
</div>
<a id="ab3a710d4a8812b2e76eb3908a5767dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a710d4a8812b2e76eb3908a5767dac">&#9670;&nbsp;</a></span>removeTrivialRedundancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeTrivialRedundancy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part. </p>
<p>A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. This method is a linear time method on the constraints, does a single scan, and updates in place.</p>
<p>A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02356">2356</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>.</p>

</div>
</div>
<a id="afb5165263cbbc9080ca858b235f98cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5165263cbbc9080ca858b235f98cd7">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00367">367</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02713">clearConstraints()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">mlir::getIndexSet()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00393">reset()</a>.</p>

</div>
</div>
<a id="ae0cc51d0f0dc264158dd9fd0bb47cd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cc51d0f0dc264158dd9fd0bb47cd28">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00393">393</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00367">reset()</a>.</p>

</div>
</div>
<a id="a201799397e672780c6bce3674f969f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201799397e672780c6bce3674f969f3b">&#9670;&nbsp;</a></span>setAndEliminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setAndEliminate </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified identifier to a constant and removes it. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02053">2053</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00324">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00331">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00342">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00563">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00348">getNumInequalities()</a>, and <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a74219ea7114c7c5ddec36845a7369f6f">removeId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02064">constantFoldId()</a>.</p>

</div>
</div>
<a id="ad4924b4c54d6823f8e52933ca960c1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4924b4c54d6823f8e52933ca960c1ff">&#9670;&nbsp;</a></span>setDimSymbolSeparation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setDimSymbolSeparation </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>newSymbolCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the partition between dimensions and symbols. </p>
<p>Depending on the new symbol count, either a chunk of trailing dimensional identifiers becomes symbols, or some of the leading symbols become dimensions. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01985">1985</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00779">turnDimIntoSymbol()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00788">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a06e4c5fcf51e01bf82d9d82a26ff316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e4c5fcf51e01bf82d9d82a26ff316a">&#9670;&nbsp;</a></span>setIdToConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setIdToConstant </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the identifier at the specified position to a constant. </p>
<p>Sets the specified identifier to a constant value. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01993">1993</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02004">setIdToConstant()</a>.</p>

</div>
</div>
<a id="a04dee3803932dd1553f52b71f0372b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dee3803932dd1553f52b71f0372b12">&#9670;&nbsp;</a></span>setIdToConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setIdToConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the identifier corresponding to the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> id to a constant. </p>
<p>Sets the specified identifier to a constant value; asserts if the id is not found.</p>
<p>Asserts if the 'id' is not found.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02004">2004</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01967">findId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01993">setIdToConstant()</a>.</p>

</div>
</div>
<a id="a77ff33d7c48f5d8de4f26b95f2a94034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ff33d7c48f5d8de4f26b95f2a94034">&#9670;&nbsp;</a></span>setIdValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::setIdValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00606">606</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a8bda84f68040789ebf27848f7bcaa169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda84f68040789ebf27848f7bcaa169">&#9670;&nbsp;</a></span>setIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::setIdValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets Values associated with identifiers in the range [start, end). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00611">611</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00102">mlir::getFlattenedAffineExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01334">print()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00839">mlir::simplifyAffineExpr()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">addLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">composeMap()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>.</p>

</div>
</div>
<a id="a3713af3279fc39f3630a5a6b89031653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3713af3279fc39f3630a5a6b89031653">&#9670;&nbsp;</a></span>toAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::FlatAffineConstraints::toAffineExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afeb8348eba3bd5c81db503336ae2ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8348eba3bd5c81db503336ae2ebfc">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of 'this' set and that of 'other', with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. `other' is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>Eg: if 'this' is {0 &lt;= d0 &lt;= 127}, 'other' is {16 &lt;= d0 &lt;= 192}, the output is {0 &lt;= d0 &lt;= 192}. 2) 'this' = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, 'other' is {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20}. 3) 'this' = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9}, 'other' = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15}. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02744">2744</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01887">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00504">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02713">clearConstraints()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="AffineStructures_8h_source.html#l00235">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02283">getConstantLowerBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02289">getConstantUpperBound()</a>, <a class="el" href="AffineStructures_8h_source.html#l00571">getIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00340">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00565">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mergeAndAlignIds()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2020 18:40:01 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
