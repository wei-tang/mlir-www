<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::AffineLoadOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1AffineLoadOp.html">AffineLoadOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1AffineLoadOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::AffineLoadOp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The "affine.load" op reads an element from a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols.  
 <a href="classmlir_1_1AffineLoadOp.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/AffineOps/AffineOps.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::AffineLoadOp:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1AffineLoadOp__inherit__graph.png" border="0" usemap="#mlir_1_1AffineLoadOp_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1AffineLoadOp_inherit__map" id="mlir_1_1AffineLoadOp_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::AffineLoadOp:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1AffineLoadOp__coll__graph.png" border="0" usemap="#mlir_1_1AffineLoadOp_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1AffineLoadOp_coll__map" id="mlir_1_1AffineLoadOp_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a8854b873577d15c8c53fa896ef9a8f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a7a8854b873577d15c8c53fa896ef9a8f">getMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:a7a8854b873577d15c8c53fa896ef9a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the memref.  <a href="#a7a8854b873577d15c8c53fa896ef9a8f">More...</a><br /></td></tr>
<tr class="separator:a7a8854b873577d15c8c53fa896ef9a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195cef9b387ae3c93c9dc1f8fecc94e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a195cef9b387ae3c93c9dc1f8fecc94e8">getMemRef</a> ()</td></tr>
<tr class="memdesc:a195cef9b387ae3c93c9dc1f8fecc94e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memref operand.  <a href="#a195cef9b387ae3c93c9dc1f8fecc94e8">More...</a><br /></td></tr>
<tr class="separator:a195cef9b387ae3c93c9dc1f8fecc94e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61e35153d24ed6a8d1352455128be2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#aa61e35153d24ed6a8d1352455128be2a">setMemRef</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:aa61e35153d24ed6a8d1352455128be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e0817a97cdde2afeb8c99242a4814b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a76e0817a97cdde2afeb8c99242a4814b">getMemRefType</a> ()</td></tr>
<tr class="separator:a76e0817a97cdde2afeb8c99242a4814b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5249e32e67b2d700d0e03dc9f717f9"><td class="memItemLeft" align="right" valign="top">operand_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a0a5249e32e67b2d700d0e03dc9f717f9">getMapOperands</a> ()</td></tr>
<tr class="memdesc:a0a5249e32e67b2d700d0e03dc9f717f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get affine map operands.  <a href="#a0a5249e32e67b2d700d0e03dc9f717f9">More...</a><br /></td></tr>
<tr class="separator:a0a5249e32e67b2d700d0e03dc9f717f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5dfa35191531fdb42b74c643e591c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a6ce5dfa35191531fdb42b74c643e591c">getAffineMap</a> ()</td></tr>
<tr class="memdesc:a6ce5dfa35191531fdb42b74c643e591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to index the memref for this operation.  <a href="#a6ce5dfa35191531fdb42b74c643e591c">More...</a><br /></td></tr>
<tr class="separator:a6ce5dfa35191531fdb42b74c643e591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c90e75448a042f7d809da8c79a3f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a51c90e75448a042f7d809da8c79a3f63">getAffineMapAttr</a> ()</td></tr>
<tr class="separator:a51c90e75448a042f7d809da8c79a3f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a76095ec34b9aa41345afe35649feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#ac0a76095ec34b9aa41345afe35649feb">getAffineMapAttrForMemRef</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref)</td></tr>
<tr class="memdesc:ac0a76095ec34b9aa41345afe35649feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> associated with 'memref'.  <a href="#ac0a76095ec34b9aa41345afe35649feb">More...</a><br /></td></tr>
<tr class="separator:ac0a76095ec34b9aa41345afe35649feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7fc05fae0ab04484c530de5cefecbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a0e7fc05fae0ab04484c530de5cefecbf">print</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:a0e7fc05fae0ab04484c530de5cefecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7f29538289961efcf30b9421592e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a2e7f29538289961efcf30b9421592e9a">verify</a> ()</td></tr>
<tr class="separator:a2e7f29538289961efcf30b9421592e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789b540d1b752565b1954c590dbc1ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a789b540d1b752565b1954c590dbc1ea8">fold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="separator:a789b540d1b752565b1954c590dbc1ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;</a></td></tr>
<tr class="memitem:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#acc1633a87c5b5b8e149483a564251c7b">getOperation</a> ()</td></tr>
<tr class="memdesc:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1Op.html#acc1633a87c5b5b8e149483a564251c7b">More...</a><br /></td></tr>
<tr class="separator:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineLoadOp.html">AffineLoadOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">clone</a> ()</td></tr>
<tr class="memdesc:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of this operation.  <a href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">More...</a><br /></td></tr>
<tr class="separator:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineLoadOp.html">AffineLoadOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">cloneWithoutRegions</a> ()</td></tr>
<tr class="memdesc:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial copy of this operation without traversing into attached regions.  <a href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">More...</a><br /></td></tr>
<tr class="separator:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a73d20cdf0c816d7f1b1abec6531fdbf1">getDialect</a> ()</td></tr>
<tr class="memdesc:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dialect that this refers to.  <a href="classmlir_1_1Op.html#a73d20cdf0c816d7f1b1abec6531fdbf1">More...</a><br /></td></tr>
<tr class="separator:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#add3f78c5f7c23acbe779d2e139cded9e">getParentRegion</a> ()</td></tr>
<tr class="memdesc:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parent Region of this operation.  <a href="classmlir_1_1Op.html#add3f78c5f7c23acbe779d2e139cded9e">More...</a><br /></td></tr>
<tr class="separator:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <a href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">More...</a><br /></td></tr>
<tr class="separator:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="separator:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <a href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">More...</a><br /></td></tr>
<tr class="separator:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">More...</a><br /></td></tr>
<tr class="separator:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow implicit conversion to bool.  <a href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">More...</a><br /></td></tr>
<tr class="separator:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <a href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">More...</a><br /></td></tr>
<tr class="separator:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a53d7c891a68c23af6c45fc68ddd89962">getParentOp</a> ()</td></tr>
<tr class="memdesc:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest surrounding operation that contains this operation or nullptr if this is a top-level operation.  <a href="classmlir_1_1OpState.html#a53d7c891a68c23af6c45fc68ddd89962">More...</a><br /></td></tr>
<tr class="separator:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4eed1368f1e3bdc6a8d19166c32a86f5">getParentOfType</a> ()</td></tr>
<tr class="memdesc:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest surrounding parent operation that is of type 'OpTy'.  <a href="classmlir_1_1OpState.html#a4eed1368f1e3bdc6a8d19166c32a86f5">More...</a><br /></td></tr>
<tr class="separator:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">getContext</a> ()</td></tr>
<tr class="memdesc:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <a href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">More...</a><br /></td></tr>
<tr class="separator:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a9a6be08fdf07ed51616a0ca5e19d31c8">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags=llvm::None)</td></tr>
<tr class="memdesc:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <a href="classmlir_1_1OpState.html#a9a6be08fdf07ed51616a0ca5e19d31c8">More...</a><br /></td></tr>
<tr class="separator:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c30361ec520a3ca2a401bb67b42c4c inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a92c30361ec520a3ca2a401bb67b42c4c">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags=llvm::None)</td></tr>
<tr class="separator:a92c30361ec520a3ca2a401bb67b42c4c inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <a href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">More...</a><br /></td></tr>
<tr class="separator:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <a href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">More...</a><br /></td></tr>
<tr class="separator:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c894aaabd1b9c8fab2090735964b9f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac3c894aaabd1b9c8fab2090735964b9f">setLoc</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:ac3c894aaabd1b9c8fab2090735964b9f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a9331db6639d9965f160c08a413492de8">getAttrs</a> ()</td></tr>
<tr class="memdesc:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all of the attributes on this operation.  <a href="classmlir_1_1OpState.html#a9331db6639d9965f160c08a413492de8">More...</a><br /></td></tr>
<tr class="separator:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a12daf70ad798e71edf66e5464bc10404">dialect_attr_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a0aa11c2b98c3ca83f8ecbd06d42326c8">getDialectAttrs</a> ()</td></tr>
<tr class="memdesc:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range corresponding to the dialect attributes for this operation.  <a href="classmlir_1_1OpState.html#a0aa11c2b98c3ca83f8ecbd06d42326c8">More...</a><br /></td></tr>
<tr class="separator:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefb9aeef2eba7850a36c257d4771d03 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aeefb9aeef2eba7850a36c257d4771d03">dialect_attr_begin</a> ()</td></tr>
<tr class="separator:aeefb9aeef2eba7850a36c257d4771d03 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2704824bb2a15eef5b3298cb7ed3a5fd inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a2704824bb2a15eef5b3298cb7ed3a5fd">dialect_attr_end</a> ()</td></tr>
<tr class="separator:a2704824bb2a15eef5b3298cb7ed3a5fd inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96cf73497da1b8c112ebbfdf209e2f02">getAttr</a> (StringRef name)</td></tr>
<tr class="memdesc:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute with the specified name.  <a href="classmlir_1_1OpState.html#a96cf73497da1b8c112ebbfdf209e2f02">More...</a><br /></td></tr>
<tr class="separator:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename AttrClass &gt; </td></tr>
<tr class="memitem:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">AttrClass&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aaaf19eeac15524a32d218c799b45d573">getAttrOfType</a> (StringRef name)</td></tr>
<tr class="memdesc:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the operation has an attribute of the specified type, return it.  <a href="classmlir_1_1OpState.html#aaaf19eeac15524a32d218c799b45d573">More...</a><br /></td></tr>
<tr class="separator:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#acc2cdf5f3afd75b2d941b861700cdb81">setAttr</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> value)</td></tr>
<tr class="memdesc:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the an attribute exists with the specified name, change it to the new value.  <a href="classmlir_1_1OpState.html#acc2cdf5f3afd75b2d941b861700cdb81">More...</a><br /></td></tr>
<tr class="separator:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b78ced11b2926820dbc64ff02a981 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ae06b78ced11b2926820dbc64ff02a981">setAttr</a> (StringRef name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> value)</td></tr>
<tr class="separator:ae06b78ced11b2926820dbc64ff02a981 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a51af7d3f6647b6e190f4f53db72884fe">setAttrs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &gt; attributes)</td></tr>
<tr class="memdesc:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the attributes held by this operation.  <a href="classmlir_1_1OpState.html#a51af7d3f6647b6e190f4f53db72884fe">More...</a><br /></td></tr>
<tr class="separator:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d40da7b953754a26a4a90cf333efc7 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a42d40da7b953754a26a4a90cf333efc7">setAttrs</a> (<a class="el" href="classmlir_1_1NamedAttributeList.html">NamedAttributeList</a> newAttrs)</td></tr>
<tr class="separator:a42d40da7b953754a26a4a90cf333efc7 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename DialectAttrs &gt; </td></tr>
<tr class="memitem:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3018daf1473e86f9f854185ff4991afd">setDialectAttrs</a> (DialectAttrs &amp;&amp;attrs)</td></tr>
<tr class="memdesc:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dialect attributes for this operation, and preserve all dependent.  <a href="classmlir_1_1OpState.html#a3018daf1473e86f9f854185ff4991afd">More...</a><br /></td></tr>
<tr class="separator:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5608d985f19b44085516992970a9597 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1NamedAttributeList.html#a5309c27798e0934435c921ace49dabc5">NamedAttributeList::RemoveResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ae5608d985f19b44085516992970a9597">removeAttr</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> name)</td></tr>
<tr class="memdesc:ae5608d985f19b44085516992970a9597 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the attribute with the specified name if it exists.  <a href="classmlir_1_1OpState.html#ae5608d985f19b44085516992970a9597">More...</a><br /></td></tr>
<tr class="separator:ae5608d985f19b44085516992970a9597 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778da64eef908500a2a908317b8d616e inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1NamedAttributeList.html#a5309c27798e0934435c921ace49dabc5">NamedAttributeList::RemoveResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a778da64eef908500a2a908317b8d616e">removeAttr</a> (StringRef name)</td></tr>
<tr class="separator:a778da64eef908500a2a908317b8d616e inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <a href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">More...</a><br /></td></tr>
<tr class="separator:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <a href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">More...</a><br /></td></tr>
<tr class="separator:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <a href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">More...</a><br /></td></tr>
<tr class="separator:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">More...</a><br /></td></tr>
<tr class="separator:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">More...</a><br /></td></tr>
<tr class="separator:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">More...</a><br /></td></tr>
<tr class="separator:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a38f85a4dbd4e82d94df05a6191571962">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation in postorder, calling the callback for each nested operation(including this one).  <a href="classmlir_1_1OpState.html#a38f85a4dbd4e82d94df05a6191571962">More...</a><br /></td></tr>
<tr class="separator:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpTrait_1_1OneResult')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; AffineLoadOp &gt;</a></td></tr>
<tr class="memitem:af43c26209db9e7fe4a4daac053515abf inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html#af43c26209db9e7fe4a4daac053515abf">getResult</a> ()</td></tr>
<tr class="separator:af43c26209db9e7fe4a4daac053515abf inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3613fcb8cf7c6868a8d18daff06fe0 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html#a7d3613fcb8cf7c6868a8d18daff06fe0">getType</a> ()</td></tr>
<tr class="separator:a7d3613fcb8cf7c6868a8d18daff06fe0 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8395eae3d0d13e38958c665335ac680 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html#ab8395eae3d0d13e38958c665335ac680">replaceAllUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> newValue)</td></tr>
<tr class="memdesc:ab8395eae3d0d13e38958c665335ac680 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of 'this' value with the new value, updating anything in the IR that uses 'this' to use the other value instead.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#ab8395eae3d0d13e38958c665335ac680">More...</a><br /></td></tr>
<tr class="separator:ab8395eae3d0d13e38958c665335ac680 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d3cfd9f437b0ba5cfd5b622bc55679 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html#a47d3cfd9f437b0ba5cfd5b622bc55679">replaceAllUsesWith</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a47d3cfd9f437b0ba5cfd5b622bc55679 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of 'this' value with the result of 'op'.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#a47d3cfd9f437b0ba5cfd5b622bc55679">More...</a><br /></td></tr>
<tr class="separator:a47d3cfd9f437b0ba5cfd5b622bc55679 inherit pub_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1FoldingHook"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1FoldingHook')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1FoldingHook.html">mlir::FoldingHook&lt; AffineLoadOp, llvm::is_one_of&lt; OpTrait::OneResult&lt; AffineLoadOp &gt;, OpTrait::OneResult&lt; AffineLoadOp &gt;... &gt;::value &gt;</a></td></tr>
<tr class="memitem:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook.html#af938ced93f6a45934750ed438228b3be">fold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook implements a generalized folder for this operation.  <a href="classmlir_1_1FoldingHook.html#af938ced93f6a45934750ed438228b3be">More...</a><br /></td></tr>
<tr class="separator:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a758d481c9c37562e9679cc57357145a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a758d481c9c37562e9679cc57357145a8">build</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> *builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a758d481c9c37562e9679cc57357145a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine load op with the specified map and operands.  <a href="#a758d481c9c37562e9679cc57357145a8">More...</a><br /></td></tr>
<tr class="separator:a758d481c9c37562e9679cc57357145a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e04fa99ef0630e5fb3f63770c81c046"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a6e04fa99ef0630e5fb3f63770c81c046">build</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> *builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices={})</td></tr>
<tr class="memdesc:a6e04fa99ef0630e5fb3f63770c81c046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine load op with an identity map and operands.  <a href="#a6e04fa99ef0630e5fb3f63770c81c046">More...</a><br /></td></tr>
<tr class="separator:a6e04fa99ef0630e5fb3f63770c81c046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8865183b840cef64ac373eb6be7480"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a2c8865183b840cef64ac373eb6be7480">build</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> *builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> mapOperands)</td></tr>
<tr class="memdesc:a2c8865183b840cef64ac373eb6be7480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine load op with the specified map and its operands.  <a href="#a2c8865183b840cef64ac373eb6be7480">More...</a><br /></td></tr>
<tr class="separator:a2c8865183b840cef64ac373eb6be7480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96a6b5ff65bf5727ce51c9813812bc"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a7b96a6b5ff65bf5727ce51c9813812bc">getMapAttrName</a> ()</td></tr>
<tr class="separator:a7b96a6b5ff65bf5727ce51c9813812bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083da8613f74c9ec918a80219a0f6176"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a083da8613f74c9ec918a80219a0f6176">getOperationName</a> ()</td></tr>
<tr class="separator:a083da8613f74c9ec918a80219a0f6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aded42cb72318b29cf690f6799f912"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#af9aded42cb72318b29cf690f6799f912">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:af9aded42cb72318b29cf690f6799f912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1115137d146bd8e11ecfa769e37f0bb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html#a1115137d146bd8e11ecfa769e37f0bb2">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:a1115137d146bd8e11ecfa769e37f0bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;</a></td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">hasTrait</a> ()</td></tr>
<tr class="memdesc:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this operation contains the provided trait.  <a href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">More...</a><br /></td></tr>
<tr class="separator:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">classof</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this "op class" can match against the specified operation.  <a href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">More...</a><br /></td></tr>
<tr class="separator:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a9d531e7cead5ce254711081dd928dcb3">parseAssembly</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook used by the AsmParser to parse the custom form of this op from an .mlir file.  <a href="classmlir_1_1Op.html#a9d531e7cead5ce254711081dd928dcb3">More...</a><br /></td></tr>
<tr class="separator:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25eec0f83831173fb40e58d16fedc4cf">printAssembly</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="memdesc:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook used by the AsmPrinter to emit this to the .mlir file.  <a href="classmlir_1_1Op.html#a25eec0f83831173fb40e58d16fedc4cf">More...</a><br /></td></tr>
<tr class="separator:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a81b9d3ca0e62afcf8aee0a047f6fd834">verifyInvariants</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook that checks whether or not this operation is well formed according to the invariants of its opcode.  <a href="classmlir_1_1Op.html#a81b9d3ca0e62afcf8aee0a047f6fd834">More...</a><br /></td></tr>
<tr class="separator:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0222f1ce6e58f3142df4987396875f inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AbstractOperation.html#a57509b6bc9b3471f6a34ecadef4c4634">AbstractOperation::OperationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a8f0222f1ce6e58f3142df4987396875f">getOperationProperties</a> ()</td></tr>
<tr class="separator:a8f0222f1ce6e58f3142df4987396875f inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a2c2c41a61d1531398c6bfc2f2ed1e4e8">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#af8baadd6703443d0275f4839132eb44b">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <a href="classmlir_1_1OpState.html#af8baadd6703443d0275f4839132eb44b">More...</a><br /></td></tr>
<tr class="separator:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpTrait_1_1OneResult"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpTrait_1_1OneResult')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; AffineLoadOp &gt;</a></td></tr>
<tr class="memitem:a315625aabeea0786b72832d8a507b8ab inherit pub_static_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html#a315625aabeea0786b72832d8a507b8ab">verifyTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a315625aabeea0786b72832d8a507b8ab inherit pub_static_methods_classmlir_1_1OpTrait_1_1OneResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1FoldingHook"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1FoldingHook')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1FoldingHook.html">mlir::FoldingHook&lt; AffineLoadOp, llvm::is_one_of&lt; OpTrait::OneResult&lt; AffineLoadOp &gt;, OpTrait::OneResult&lt; AffineLoadOp &gt;... &gt;::value &gt;</a></td></tr>
<tr class="memitem:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook.html#aad50a0fc7560458b00e8a1479aa47bea">foldHook</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation detail of the constant folder hook for AbstractOperation.  <a href="classmlir_1_1FoldingHook.html#aad50a0fc7560458b00e8a1479aa47bea">More...</a><br /></td></tr>
<tr class="separator:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;</a></td></tr>
<tr class="memitem:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> = <a class="el" href="classmlir_1_1AffineLoadOp.html">AffineLoadOp</a></td></tr>
<tr class="memdesc:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation.  <a href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">More...</a><br /></td></tr>
<tr class="separator:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a> = <a class="el" href="classmlir_1_1Operation_1_1dialect__attr__iterator.html">Operation::dialect_attr_iterator</a></td></tr>
<tr class="memdesc:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out non-dialect attributes.  <a href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">More...</a><br /></td></tr>
<tr class="separator:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12daf70ad798e71edf66e5464bc10404 inherit pub_types_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a12daf70ad798e71edf66e5464bc10404">dialect_attr_range</a> = <a class="el" href="classmlir_1_1Operation.html#a7eacb7f04d4808ff4b7da5479113d871">Operation::dialect_attr_range</a></td></tr>
<tr class="separator:a12daf70ad798e71edf66e5464bc10404 inherit pub_types_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fa98061d57976a6cfb301d61c1d376 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa1fa98061d57976a6cfb301d61c1d376">print</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:aa1fa98061d57976a6cfb301d61c1d376 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <a href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">More...</a><br /></td></tr>
<tr class="separator:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; AffineLoadOp, OneResult &gt;</a></td></tr>
<tr class="memitem:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">getOperation</a> ()</td></tr>
<tr class="memdesc:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ultimate Operation being worked on.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">More...</a><br /></td></tr>
<tr class="separator:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless overridden, the custom assembly form of an op is always rejected.  <a href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">More...</a><br /></td></tr>
<tr class="separator:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; AffineLoadOp, OneResult &gt;</a></td></tr>
<tr class="memitem:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#a9105d11a7b603c326049ba2760b60e8b">verifyTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide default implementations of trait hooks.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#a9105d11a7b603c326049ba2760b60e8b">More...</a><br /></td></tr>
<tr class="separator:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2584d29be2078d57d5a33443e6f0d5c inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AbstractOperation.html#a57509b6bc9b3471f6a34ecadef4c4634">AbstractOperation::OperationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#ae2584d29be2078d57d5a33443e6f0d5c">getTraitProperties</a> ()</td></tr>
<tr class="separator:ae2584d29be2078d57d5a33443e6f0d5c inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The "affine.load" op reads an element from a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols. </p>
<p>The output of 'affine.load' is a new value with the same type as the elements of the memref. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword 'symbol' can be used to indicate SSA identifiers which are symbolic. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00392">392</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a758d481c9c37562e9679cc57357145a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758d481c9c37562e9679cc57357145a8">&#9670;&nbsp;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineLoadOp::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine load op with the specified map and operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01742">1742</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00294">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00044">mlir::OperationState::addOperands()</a>, <a class="el" href="Attributes_8cpp_source.html#l00055">mlir::AffineMapAttr::get()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="STLExtras_8h_source.html#l00237">mlir::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::size()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00267">mlir::OperationState::types</a>.</p>

</div>
</div>
<a id="a6e04fa99ef0630e5fb3f63770c81c046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e04fa99ef0630e5fb3f63770c81c046">&#9670;&nbsp;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineLoadOp::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine load op with an identity map and operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01762">1762</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00264">mlir::Type::cast()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00256">mlir::Builder::getEmptyAffineMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00268">mlir::Builder::getMultiDimIdentityMap()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a2c8865183b840cef64ac373eb6be7480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8865183b840cef64ac373eb6be7480">&#9670;&nbsp;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineLoadOp::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>mapOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine load op with the specified map and its operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01752">1752</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00294">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00044">mlir::OperationState::addOperands()</a>, <a class="el" href="Types_8h_source.html#l00264">mlir::Type::cast()</a>, <a class="el" href="Attributes_8cpp_source.html#l00055">mlir::AffineMapAttr::get()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="STLExtras_8h_source.html#l00237">mlir::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::size()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00267">mlir::OperationState::types</a>.</p>

</div>
</div>
<a id="a789b540d1b752565b1954c590dbc1ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789b540d1b752565b1954c590dbc1ea8">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> AffineLoadOp::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>load(memrefcast) -&gt; load </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01833">1833</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00820">foldMemRefCast()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00039">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="a6ce5dfa35191531fdb42b74c643e591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce5dfa35191531fdb42b74c643e591c">&#9670;&nbsp;</a></span>getAffineMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineLoadOp::getAffineMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to index the memref for this operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00421">421</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00285">mlir::lowerAffineUpperBound()</a>.</p>

</div>
</div>
<a id="a51c90e75448a042f7d809da8c79a3f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c90e75448a042f7d809da8c79a3f63">&#9670;&nbsp;</a></span>getAffineMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> mlir::AffineLoadOp::getAffineMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00422">422</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="ac0a76095ec34b9aa41345afe35649feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a76095ec34b9aa41345afe35649feb">&#9670;&nbsp;</a></span>getAffineMapAttrForMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> mlir::AffineLoadOp::getAffineMapAttrForMemRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> associated with 'memref'. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00427">427</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00426">mlir::Identifier::get()</a>, and <a class="el" href="IR_2Dialect_8h_source.html#l00047">mlir::Dialect::getContext()</a>.</p>

</div>
</div>
<a id="a1115137d146bd8e11ecfa769e37f0bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1115137d146bd8e11ecfa769e37f0bb2">&#9670;&nbsp;</a></span>getCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineLoadOp::getCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01828">1828</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a7b96a6b5ff65bf5727ce51c9813812bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b96a6b5ff65bf5727ce51c9813812bc">&#9670;&nbsp;</a></span>getMapAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineLoadOp::getMapAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00433">433</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="a0a5249e32e67b2d700d0e03dc9f717f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5249e32e67b2d700d0e03dc9f717f9">&#9670;&nbsp;</a></span>getMapOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operand_range mlir::AffineLoadOp::getMapOperands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get affine map operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00418">418</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00285">mlir::lowerAffineUpperBound()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00834">mlir::MemRefAccess::MemRefAccess()</a>.</p>

</div>
</div>
<a id="a195cef9b387ae3c93c9dc1f8fecc94e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195cef9b387ae3c93c9dc1f8fecc94e8">&#9670;&nbsp;</a></span>getMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineLoadOp::getMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get memref operand. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00411">411</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00736">mlir::canonicalizeSetAndOperands()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">mlir::createMemRefDataFlowOptPass()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00285">mlir::lowerAffineUpperBound()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00834">mlir::MemRefAccess::MemRefAccess()</a>.</p>

</div>
</div>
<a id="a7a8854b873577d15c8c53fa896ef9a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8854b873577d15c8c53fa896ef9a8f">&#9670;&nbsp;</a></span>getMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineLoadOp::getMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00408">408</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="a76e0817a97cdde2afeb8c99242a4814b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e0817a97cdde2afeb8c99242a4814b">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::AffineLoadOp::getMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00413">413</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00834">mlir::MemRefAccess::MemRefAccess()</a>.</p>

</div>
</div>
<a id="a083da8613f74c9ec918a80219a0f6176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083da8613f74c9ec918a80219a0f6176">&#9670;&nbsp;</a></span>getOperationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineLoadOp::getOperationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00434">434</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01334">print()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00264">mlir::verify()</a>.</p>

</div>
</div>
<a id="af9aded42cb72318b29cf690f6799f912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aded42cb72318b29cf690f6799f912">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> AffineLoadOp::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01773">1773</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00604">mlir::OpAsmParser::addTypeToList()</a>, <a class="el" href="OperationSupport_8h_source.html#l00268">mlir::OperationState::attributes</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a06b1d7cb826bcceb3ce2fe325faff660">mlir::OpAsmParser::getBuilder()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00054">mlir::Builder::getIndexType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00265">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a27699b71e5bba1d92b325b86c386ff0a">mlir::OpAsmParser::parseAffineMapOfSSAIds()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8699060de12635946dc29a848e0d2ecb">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a831b824383364f6f9e2de455a5b3ad13">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac802ed95d542e751b37ce7ece6835c17">mlir::OpAsmParser::parseOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a14acb0e25d0d6adcc98b99467b479bcc">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l00472">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00267">mlir::OperationState::types</a>.</p>

</div>
</div>
<a id="a0e7fc05fae0ab04484c530de5cefecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7fc05fae0ab04484c530de5cefecbf">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineLoadOp::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01792">1792</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

</div>
</div>
<a id="aa61e35153d24ed6a8d1352455128be2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61e35153d24ed6a8d1352455128be2a">&#9670;&nbsp;</a></span>setMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::AffineLoadOp::setMemRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00412">412</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="a2e7f29538289961efcf30b9421592e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7f29538289961efcf30b9421592e9a">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> AffineLoadOp::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01801">1801</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVOps_8cpp_source.html#l00411">getElementType()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00202">isValidAffineIndexOperand()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/AffineOps/<a class="el" href="AffineOps_8h_source.html">AffineOps.h</a></li>
<li>lib/Dialect/AffineOps/<a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 29 2020 16:23:28 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
