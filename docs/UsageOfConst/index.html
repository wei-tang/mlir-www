<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Usage of 'Const' in MLIR, for core IR types - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.63.2"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/UsageOfConst/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Usage of 'Const' in MLIR, for core IR types</h1><p>aka, where&rsquo;d <code>const</code> go?</p><p>The MLIR data structures that represent the IR itself (Instruction, Block, etc)
form a graph-based data structure, and the compiler analyses and passes
frequently walk this graph (e.g. traversing from defs to users). The early
design of MLIR adopted the <code>const</code> model of LLVM, which is familiar and well
understood (even though the LLVM implementation is flawed in many ways).</p><p>The design team since decided to change to a different module, which eschews
<code>const</code> entirely for the core IR types: you should never see a <code>const</code> method on
<code>Operation</code>, should never see the type <code>const Value</code>, and you shouldn&rsquo;t feel bad
about this. That said, you <em>should</em> use <code>const</code> for non-IR types, like
<code>SmallVector</code>'s and many other things.</p><p>The document below explains this design point from the viewpoint of &ldquo;why make a
change&rdquo;, to explain the rationale and the tradeoffs involved that led us to this
potentially controversial design point.</p><p>Bjarke Roune summarized the situation like this:</p><blockquote><p>In my opinion <code>const</code> correctness is highly valuable, catching many bugs and
making it clear in a code base where the mutations happen. In my opinion
<code>const</code> correctness still isn&rsquo;t worth it in particular for IR elements because
of the special uses and properties of IRs, in particular that it is common to
transfer a pointer/reference to an instruction from an analysis to an
optimization which will change the instruction. The analysis should be const,
the optimization needs to get a non-<code>const</code> pointer. So all analyses either
end up being templates (and if they never get instantiated in a const context,
then the point of <code>const</code> correctness has been defeated), you need to somehow
launder the const in a safe way or there will be <code>const_cast</code>s. These options
are all bad, probably so bad as to out-weigh the benefits of const.</p></blockquote><p>This document argues this design is introducing significant sub-optimalities
into the MLIR codebase, argues that the cost/benefit tradeoff of this design is
a poor tradeoff, and proposes switching to a much simpler approach - eliminating
the use of const of these IR types entirely.</p><p><strong>Note:</strong> <strong>This document is only discussing things like <code>const Value</code> and
<code>const Operation*</code>. There is no proposed change for other types, e.g.
<code>SmallVector</code> references, the immutable types like <code>Attribute</code>, etc.</strong></p><h2 id=background-the-llvm-const-model>Background: The LLVM Const Model</h2><p>The LLVM and MLIR data structures provide the IR data structures (like
<code>mlir::Operation</code>s and their users) as a structured cyclic graph data structure.
Clients of the IR typically walk up and down the graph, perform dynamic down
casting (of various sorts) to check for patterns, and use some high-abstraction
pattern matching and binding facilities to do their work.</p><p>The basic idea of LLVM&rsquo;s design is that these traversals of the IR should
preserve the const&rsquo;ness of a pointer: if you have a const pointer to an
instruction and ask for its parent (or operand, users, etc), you should get a
const pointer to the block containing the instruction (or value defining the
operand, instruction using the instruction, etc). The instruction class looks
like this:</p><pre><code>namespace llvm {
class Instruction : ...  {
  BasicBlock *Parent;
public:
  // A const instruction returns a const parent pointer.
  inline const BasicBlock *getParent() const { return Parent; }
  // A non-const instruction returns a non-const parent pointer.
  inline       BasicBlock *getParent()       { return Parent; }
â€¦
};
}
</code></pre><p>The rationale for this design is that it would be const-incorrect to return a
non-const pointer from getParent, because you could then walk the block to find
the instruction again and get non-const references to the same instruction - all
without a <code>const_cast</code>.</p><p>This const model is simple and the C++ type system generally supports it through
code duplication of methods. That said, LLVM is actually inconsistent and buggy
about this. Even the core classes have bugs: <code>llvm::Instruction::getOperand()</code>
isn&rsquo;t currently const correct! There are other subsystems (e.g. the
<code>llvm/IR/PatternMatch.h</code> APIs) where you can perform a pattern match on a const
IR object and bind a non-const IR object.</p><p>LLVM is a mature technology with hundreds of people working on it. The fact that
it still isn&rsquo;t correctly following the const model it set out for strongly hints
that one of: 1) The design is too complicated to be practical, 2) the benefits
of the model aren&rsquo;t worth the cost of the complexity, or 3) both 1 and 2,
together in some combination.</p><h2 id=advantages-of-const-correctness-in-mlir>Advantages of Const-correctness in MLIR</h2><p>Even though this doc argues for eliminating const from MLIR, it is important to
evaluate that as a tradeoff with the advantages the const model provides,
allowing us to do a cost/benefit tradeoff. These are the benefits we see:</p><p>The major advantage of allowing const on MLIR types is as a marker in APIs that
indicate that the function will not modify the specified values. For example,
the dominator APIs have a <code>dominates(const Block*, const Block*)</code> method, and
the consts provide a way of indicating that the call won&rsquo;t modify the blocks
passed in - similarly predicates like <code>Instruction::isTerminator() const</code> do not
modify the receiver object.</p><p>It is also an advantage that MLIR follows the generally prevailing pattern of
C++ code, which generally uses const. Consistency with the community norm is
important.</p><h2 id=costs-of-const-correctness-in-mlir>Costs of Const-correctness in MLIR</h2><p>As mentioned above, early work on MLIR adopted the same design as LLVM intended,
allowing const-correct traversals in the APIs. Here we discuss the various costs
of doing this by looking at some examples, listed in roughly increasing order of
severity.</p><h3 id=pervasively-duplicated-accessors>Pervasively duplicated accessors</h3><p>Just as the getParent() example above shows, achieving this const model requires
that all of the graph traversal accessors be duplicated into const and non-const
versions. This causes API bloat and slows compile time, but these are minor
problems.</p><p>The more significant issue is that this duplication can be so significant that
the signal disappears in the noise, for example <code>mlir::Operation</code> ends up with
things like this, which is twice as much API surface area just to try to satisfy
const.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>operand_iterator</span> <span class=nf>operand_begin</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>operand_iterator</span> <span class=nf>operand_end</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>/// Returns an iterator on the underlying Value&#39;s (Value ).
</span><span class=c1></span>  <span class=n>operand_range</span> <span class=nf>getOperands</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Support const operand iteration.
</span><span class=c1></span>  <span class=k>using</span> <span class=n>const_operand_iterator</span> <span class=o>=</span>
      <span class=n>OperandIterator</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Operation</span><span class=p>,</span> <span class=k>const</span> <span class=n>Value</span><span class=o>&gt;</span><span class=p>;</span>
  <span class=k>using</span> <span class=n>const_operand_range</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>iterator_range</span><span class=o>&lt;</span><span class=n>const_operand_iterator</span><span class=o>&gt;</span><span class=p>;</span>

  <span class=n>const_operand_iterator</span> <span class=nf>operand_begin</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
  <span class=n>const_operand_iterator</span> <span class=nf>operand_end</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>

  <span class=c1>/// Returns a const iterator on the underlying Value&#39;s (Value ).
</span><span class=c1></span>  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>iterator_range</span><span class=o>&lt;</span><span class=n>const_operand_iterator</span><span class=o>&gt;</span> <span class=n>getOperands</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>

  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>OpOperand</span><span class=o>&gt;</span> <span class=n>getOpOperands</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>getOperandStorage</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>getOperands</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>OpOperand</span><span class=o>&gt;</span> <span class=n>getOpOperands</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>getOperandStorage</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>getOperands</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=n>OpOperand</span> <span class=o>&amp;</span><span class=n>getOpOperand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>idx</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>getOpOperands</span><span class=p>(</span><span class=p>)</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=p>;</span> <span class=p>}</span>
  <span class=k>const</span> <span class=n>OpOperand</span> <span class=o>&amp;</span><span class=n>getOpOperand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>idx</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>getOpOperands</span><span class=p>(</span><span class=p>)</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=p>;</span>
  <span class=p>}</span>

</code></pre></div><h3 id=templated-accessors>Templated accessors</h3><p>A related issue is that having to provide both const and non-const versions of
accessors leads to us having to turn more code into templates than would
otherwise be desirable. Things like <code>ResultIterator</code> and <code>ResultTypeIterator</code>
are templates <em><em>only</em></em> because they are generic over const and non-const
versions of types. This leads to them being defined inline in headers (instead
of in .cpp files).</p><p>Thus, our const model is leading to more code in headers and more complexity in
the implementation.</p><h3 id=const-incorrect-in-practice>Const incorrect in practice</h3><p>For some things, const is more trouble than it is worth, so they never get
updated.</p><p>This means that certain API in practice don&rsquo;t provide a const variant, leading
to pervasive use of <code>const_cast</code> to drop the const qualifier. For example the
logic in <code>Matchers.h</code> doesn&rsquo;t support const pointers at all (b/123355851), even
though matching and binding values themselves makes perfect sense for both const
and non-const values. Actually fixing this would cause massive code bloat and
complexity.</p><p>Other parts of the code are just outright incorrect. For example, the operation
cloning methods are defined on Operation like this:</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=n>Operation</span> <span class=o>*</span><span class=nf>clone</span><span class=p>(</span><span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>mapper</span><span class=p>,</span> <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>

<span class=n>Operation</span> <span class=o>*</span><span class=nf>clone</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</code></pre></div><p>While it makes sense for a clone method to be <code>const</code> conceptually (the original
operation isn&rsquo;t modified) this is a violation of the model, since the returned
operation must be mutable, and provides access to the full graph of operands as
the original operation, violating the graph based const model we were shooting
for.</p><h3 id=the-oppointer-and-constoppointer-classes>The <code>OpPointer</code> and <code>ConstOpPointer</code> Classes</h3><p>The &ldquo;typed operation&rdquo; classes for registered operations (e.g. like <code>DimOp</code> for
the &ldquo;std.dim&rdquo; operation in standard ops) contain a pointer to an operation and
provide typed APIs for processing it.</p><p>However, this is a problem for our current <code>const</code> design - <code>const DimOp</code> means
the pointer itself is immutable, not the pointee. The current solution for this
is the <code>OpPointer&lt;></code> and <code>ConstOpPointer&lt;></code> classes, which exist solely to
provide const correctness when referring to a typed operation. Instead of
referring to <code>DimOp</code> directly, we need to use <code>OpPointer&lt;DimOp></code> and
<code>ConstOpPointer&lt;DimOp></code> to preserve this constness.</p><p>While <code>auto</code> hides many instances of these <code>OpPointer</code> classes, their presence
leads to extremely ugly APIs. It also obscures the fact that the user does not
have a direct <code>DimOp</code> object, creating easy pitfalls with subtly incorrect
semantics:</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=c1>// OpPointer encodes unnecessary and superfluous information into the API.
</span><span class=c1></span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span><span class=p>,</span> <span class=mi>8</span><span class=o>&gt;</span> <span class=n>stripmineSink</span><span class=p>(</span>
  <span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>forOp</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>factor</span><span class=p>,</span>
  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span><span class=o>&gt;</span> <span class=n>targets</span><span class=p>)</span><span class=p>;</span>
<span class=c1>// Compared to the much cleaner and easier to read...
</span><span class=c1></span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=p>,</span> <span class=mi>8</span><span class=o>&gt;</span> <span class=n>stripmineSink</span><span class=p>(</span><span class=n>AffineForOp</span> <span class=n>forOp</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>factor</span><span class=p>,</span>
                                          <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>targets</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// OpPointer is easy to misuse.
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=n>dimOp</span> <span class=o>=</span> <span class=n>inst</span><span class=o>-</span><span class=o>&gt;</span><span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>DimOp</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// This is actually undefined behavior because dyn_cast actually returns
</span><span class=c1></span>  <span class=c1>// OpPointer&lt;DimOp&gt;. OpPointer&lt;DimOp&gt; happily implicitly converts to DimOp *
</span><span class=c1></span>  <span class=c1>// creating undefined behavior that will execute correctly most of the time.
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>It would be much better to eliminate them entirely, and just pass around <code>DimOp</code>
directly. For example, instead of:</p><div class=highlight><pre class=chroma><code class=language-C++ data-lang=C++><span class=n>LogicalResult</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>getIndexSet</span><span class=p>(</span><span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span><span class=o>&gt;</span> <span class=n>forOps</span><span class=p>,</span>
                                <span class=n>FlatAffineConstraints</span> <span class=o>*</span><span class=n>domain</span><span class=p>)</span> <span class=p>{</span>

</code></pre></div><p>It would be a lot nicer to just have:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>LogicalResult</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>getIndexSet</span><span class=p>(</span><span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>forOps</span><span class=p>,</span>
                                <span class=n>FlatAffineConstraints</span> <span class=o>*</span><span class=n>domain</span><span class=p>)</span> <span class=p>{</span>
</code></pre></div><p>Particularly since all of the <code>FooOp</code> classes are already semantically a smart
pointer to their underlying operation.</p><h2 id=proposal-remove-const-from-ir-objects>Proposal: Remove <code>const</code> from IR objects</h2><p>As we can see above, there is very little benefit to our const design and
significant cost, and given that the primary purpose of an IR is to represent
transformations of code, const is providing very little benefit.</p><p>As such, we propose eliminating support for const references in MLIR. This
implies the following changes to the codebase:</p><ol><li>All of the const-duplicated accessors would be eliminated, e.g.
<code>Operation::getParent() const</code> would be removed. This is expected to remove
approximately ~130 lines of code from just Operation.h alone.</li><li>Const-only predicates would be changed to be non-const, e.g.
<code>Operation::isTerminator() const</code> would have the const removed.</li><li>Iterators and other types and functions that are templated to support
<code>const</code> can have those template arguments removed.</li><li>Types like <code>OpPointer</code> and <code>ConstOpPointer</code> that exist solely to propagate
const can be entirely removed from the codebase.</li><li>We can close bugs complaining about const incorrectness in the IR.</li></ol><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/OpDefinitions/ title="Table-driven Operation Definition Specification (ODS)"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Table-driven Operation Definition Specification (ODS)</a>
<a class="nav nav-next" href=/docs/WritingAPass/ title="Writing a Pass">Next - Writing a Pass <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/OpenMPOps/>Dialect 'omp' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li class=active><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>