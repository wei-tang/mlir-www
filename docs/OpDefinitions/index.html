<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Table-driven Operation Definition Specification (ODS) - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.63.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/OpDefinitions/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Table-driven Operation Definition Specification (ODS)</h1><p>In addition to specializing the <code>mlir::Op</code> C++ template, MLIR also supports
defining operations in a table-driven manner. This is achieved via
<a href=https://llvm.org/docs/TableGen/index.html>TableGen</a>
, which is both a generic language and its tooling to
maintain records of domain-specific information. Facts regarding an operation
are specified concisely into a TableGen record, which will be expanded into an
equivalent <code>mlir::Op</code> C++ template specialization at compiler build time.</p><p>This manual explains in detail all the available mechanisms for defining
operations in such a table-driven manner. It aims to be a specification instead
of a tutorial. Please refer to
<a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph
rewrite</a>
for the latter.</p><p>In addition to detailing each mechanism, this manual also tries to capture
best practices. They are rendered as quoted bullet points.</p><h2 id=motivation>Motivation</h2><p>MLIR allows pluggable dialects, and dialects contain, among others, a list of
operations. This open and extensible ecosystem leads to the &ldquo;stringly&rdquo; type IR
problem, e.g., repetitive string comparisons during optimization and analysis
passes, unintuitive accessor methods (e.g., generic/error prone <code>getOperand(3)</code>
vs self-documenting <code>getStride()</code>) with more generic return types, verbose and
generic constructors without default arguments, verbose textual IR dump, and
so on. Furthermore, operation verification is:</p><ol><li>best case: a central string-to-verification-function map,</li><li>middle case: duplication of verification across the code base, or</li><li>worst case: no verification functions.</li></ol><p>The fix is to support defining ops in a table-driven manner. Then for each
dialect, we can have a central place that contains everything you need to know
about each op, including its constraints, custom assembly form, etc. This
description is also used to generate helper functions and classes to allow
building, verification, parsing, printing, analysis, and many more.</p><h2 id=benefits>Benefits</h2><p>Compared to the C++ template, this table-driven approach has several benefits
including but not limited to:</p><ul><li><strong>Single source of truth</strong>: We strive to encode all facts regarding an
operation into the record, so that readers don&rsquo;t need to jump among code
snippets to fully understand an operation.</li><li><strong>Removing boilerplate</strong>: We can automatically generate
operand/attribute/result getter methods, operation build methods, operation
verify methods, and many more utilities from the record. This greatly reduces
the boilerplate needed for defining a new op.</li><li><strong>Facilitating auto-generation</strong>: The usage of these operation information
records are by no means limited to op definition itself. We can use them to
drive the auto-generation of many other components, like computation graph
serialization.</li></ul><h2 id=tablegen-syntax>TableGen Syntax</h2><p>We use TableGen as the language for specifying operation information. TableGen
itself just provides syntax for writing records; the syntax and constructs
allowed in a TableGen file (typically with filename suffix <code>.td</code>) can be found
<a href=https://llvm.org/docs/TableGen/LangIntro.html>here</a>
. The formal language specification can be found
<a href=https://llvm.org/docs/TableGen/LangRef.html>here</a>
. <em>Roughly</em> speaking,</p><ul><li>TableGen <code>class</code> is similar to C++ class; it can be templated and
subclassed.</li><li>TableGen <code>def</code> is similar to C++ object; it can be declared by specializing
a TableGen <code>class</code> (e.g., <code>def MyDef : MyClass&lt;...>;</code>) or completely
independently (e.g., <code>def MyDef;</code>). It cannot be further templated or
subclassed.</li><li>TableGen <code>dag</code> is a dedicated type for directed acyclic graph of elements. A
<code>dag</code> has one operator and zero or more arguments. Its syntax is <code>(operator arg0, arg1, argN)</code>. The operator can be any TableGen <code>def</code>; an argument can
be anything, including <code>dag</code> itself. We can have names attached to both the
operator and the arguments like <code>(MyOp:$op_name MyArg:$arg_name)</code>.</li></ul><p>Please see the
<a href=https://llvm.org/docs/TableGen/LangIntro.html>language introduction</a>
to learn about all the
types and expressions supported by TableGen.</p><h2 id=operation-definition>Operation Definition</h2><p>MLIR defines several common constructs to help operation definition and provide
their semantics via a special
<a href=https://llvm.org/docs/TableGen/BackEnds.html#introduction>TableGen backend</a>
:
<a href=../tools/mlir-tblgen/OpDefinitionsGen.cpp><code>OpDefinitionsGen</code></a>
. These constructs are defined in
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
. The main ones are</p><ul><li>The <code>Op</code> class: It is the main construct for defining operations. All facts
regarding the operation are specified when specializing this class, with the
help of the following constructs.</li><li>The <code>Dialect</code> class: Operations belonging to one logical group are placed in
the same dialect. The <code>Dialect</code> class contains dialect-level information.</li><li>The <code>OpTrait</code> class hierarchy: They are used to specify special properties
and constraints of the operation, including whether the operation has side
effect or whether its output has the same shape as the input.</li><li>The <code>ins</code>/<code>outs</code> marker: These are two special makers builtin to the
<code>OpDefinitionsGen</code> backend. They lead the definitions of operands/attributes
and results respectively.</li><li>The <code>TypeConstraint</code> class hierarchy: They are used to specify the
constraints over operands or results. A notable subclass hierarchy is
<code>Type</code>, which stands for constraints for common C++ types.</li><li>The <code>AttrConstraint</code> class hierarchy: They are used to specify the
constraints over attributes. A notable subclass hierarchy is <code>Attr</code>, which
stands for constraints for attributes whose values are of common types.</li></ul><p>An operation is defined by specializing the <code>Op</code> class with concrete contents
for all the fields it requires. For example, <code>tf.AvgPool</code> is defined as</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>TF_AvgPoolOp</span> <span class=p>:</span> <span class=nv>TF_Op</span><span class=p>&lt;</span><span class=s>&#34;AvgPool&#34;</span><span class=p>,</span> <span class=p>[</span><span class=nv>NoSideEffect</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Performs average pooling on the input.&#34;</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>Each entry in `output` is the mean of the corresponding size `ksize`
</span><span class=s>window in `value`.
</span><span class=s>  }]</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
    <span class=nv>TF_FpTensor</span><span class=p>:</span><span class=nv>$value</span><span class=p>,</span>

    <span class=nv>Confined</span><span class=p>&lt;</span><span class=nv>I64ArrayAttr</span><span class=p>,</span> <span class=p>[</span><span class=nv>ArrayMinCount</span><span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span><span class=p>]</span><span class=p>&gt;</span><span class=p>:</span><span class=nv>$ksize</span><span class=p>,</span>
    <span class=nv>Confined</span><span class=p>&lt;</span><span class=nv>I64ArrayAttr</span><span class=p>,</span> <span class=p>[</span><span class=nv>ArrayMinCount</span><span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span><span class=p>]</span><span class=p>&gt;</span><span class=p>:</span><span class=nv>$strides</span><span class=p>,</span>
    <span class=nv>TF_AnyStrAttrOf</span><span class=p>&lt;</span><span class=p>[</span><span class=s>&#34;SAME&#34;</span><span class=p>,</span> <span class=s>&#34;VALID&#34;</span><span class=p>]</span><span class=p>&gt;</span><span class=p>:</span><span class=nv>$padding</span><span class=p>,</span>
    <span class=nv>DefaultValuedAttr</span><span class=p>&lt;</span><span class=nv>TF_ConvertDataFormatAttr</span><span class=p>,</span> <span class=s>&#34;NHWC&#34;</span><span class=p>&gt;</span><span class=p>:</span><span class=nv>$data_format</span>
  <span class=p>)</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
    <span class=nv>TF_FpTensor</span><span class=p>:</span><span class=nv>$output</span>
  <span class=p>)</span><span class=p>;</span>

  <span class=nv>TF_DerivedOperandTypeAttr</span> <span class=nv>T</span> <span class=p>=</span> <span class=nv>TF_DerivedOperandTypeAttr</span><span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>In the following we describe all the fields needed. Please see the definition
of the <code>Op</code> class for the complete list of fields supported.</p><h3 id=operation-name>Operation name</h3><p>The operation name is a unique identifier of the operation within MLIR, e.g.,
<code>tf.Add</code> for addition operation in the TensorFlow dialect. This is the
equivalent of the mnemonic in assembly language. It is used for parsing and
printing in the textual format. It is also used for pattern matching in graph
rewrites.</p><p>The full operation name is composed of the dialect name and the op name, with
the former provided via the dialect and the latter provided as the second
template parameter to the <code>Op</code> class.</p><h3 id=operation-documentation>Operation documentation</h3><p>This includes both an one-line <code>summary</code> and a longer human-readable
<code>description</code>. They will be used to drive automatic generation of dialect
documentation. They need to be provided in the operation&rsquo;s definition body:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;...&#34;</span><span class=p>;</span>

<span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>...
</span><span class=s>}]</span><span class=p>;</span>
</code></pre></div><p><code>description</code> should be written in Markdown syntax.</p><p>Placing the documentation at the beginning is recommended since
it helps in understanding the operation.</p><blockquote><ul><li>Place documentation at the beginning of the operation definition</li><li>The summary should be short and concise. It should be a one-liner without
trailing punctuation. Put expanded explanation in description.</li></ul></blockquote><h3 id=operation-arguments>Operation arguments</h3><p>There are two kinds of arguments: operands and attributes. Operands are runtime
values produced by other ops; while attributes are compile-time known constant
values, including two categories:</p><ol><li>Natural attributes: these attributes affect the behavior of the operations
(e.g., padding for convolution);</li><li>Derived attributes: these attributes are not needed to define the operation
but are instead derived from information of the operation. E.g., the output
shape of type. This is mostly used for convenience interface generation or
interaction with other frameworks/translation.</li></ol><p>Both operands and attributes are specified inside the <code>dag</code>-typed <code>arguments</code>,
led by <code>ins</code>:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
  <span class=p>&lt;</span><span class=nv>type</span><span class=err>-</span><span class=nv>constraint</span><span class=p>&gt;</span><span class=p>:</span><span class=err>$</span><span class=p>&lt;</span><span class=nv>operand</span><span class=err>-</span><span class=nv>name</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>&lt;</span><span class=nv>attr</span><span class=err>-</span><span class=nv>constraint</span><span class=p>&gt;</span><span class=p>:</span><span class=err>$</span><span class=p>&lt;</span><span class=nv>attr</span><span class=err>-</span><span class=nv>name</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>)</span><span class=p>;</span>
</code></pre></div><p>Here <code>&lt;type-constraint></code> is a TableGen <code>def</code> from the <code>TypeConstraint</code> class
hierarchy. Similarly, <code>&lt;attr-constraint></code> is a TableGen <code>def</code> from the
<code>AttrConstraint</code> class hierarchy. See
<a href=#constraints>Constraints</a>
for more
information.</p><p>There is no requirements on the relative order of operands and attributes; they
can mix freely. The relative order of operands themselves matters. From each
named argument a named getter will be generated that returns the argument with
the return type (in the case of attributes the return type will be
constructed from the storage type, while for operands it will be <code>Value</code>). Each
attribute&rsquo;s raw value (e.g., as stored) can also be accessed via generated
<code>&lt;name>Attr</code> getters for use in transformation passes where the more user
friendly return type is less suitable.</p><p>All the arguments should be named to 1) provide documentation, 2) drive
auto-generation of getter methods, 3) provide a handle to reference for other
places like constraints.</p><h4 id=variadic-operands>Variadic operands</h4><p>To declare a variadic operand, wrap the <code>TypeConstraint</code> for the operand with
<code>Variadic&lt;...></code>.</p><p>Normally operations have no variadic operands or just one variadic operand. For
the latter case, it is easy to deduce which dynamic operands are for the static
variadic operand definition. But if an operation has more than one variadic
operands, it would be impossible to attribute dynamic operands to the
corresponding static variadic operand definitions without further information
from the operation. Therefore, the <code>SameVariadicOperandSize</code> trait is needed to
indicate that all variadic operands have the same number of dynamic values.</p><h4 id=optional-attributes>Optional attributes</h4><p>To declare an optional attribute, wrap the <code>AttrConstraint</code> for the attribute
with <code>OptionalAttr&lt;...></code>.</p><h4 id=attributes-with-default-values>Attributes with default values</h4><p>To declare an attribute with a default value, wrap the <code>AttrConstraint</code> for the
attribute with <code>DefaultValuedAttr&lt;..., "..."></code>.</p><p>The second parameter to <code>DefaultValuedAttr</code> should be a string containing the
C++ default value. For example, a float default value should be specified as
like <code>"0.5f"</code>, and an integer array default value should be specified as like
<code>"{1, 2, 3}"</code>.</p><h4 id=confining-attributes>Confining attributes</h4><p><code>Confined</code> is provided as a general mechanism to help modelling further
constraints on attributes beyond the ones brought by value types. You can use
<code>Confined</code> to compose complex constraints out of more primitive ones. For
example, a 32-bit integer attribute whose minimum value must be 10 can be
expressed as <code>Confined&lt;I32Attr, [IntMinValue&lt;10>]></code>.</p><p>Right now, the following primitive constraints are supported:</p><ul><li><code>IntMinValue&lt;N></code>: Specifying an integer attribute to be greater than or
equal to <code>N</code></li><li><code>IntMaxValue&lt;N></code>: Specifying an integer attribute to be less than or equal
to <code>N</code></li><li><code>ArrayMinCount&lt;N></code>: Specifying an array attribute to have at least <code>N</code>
elements</li><li><code>IntArrayNthElemEq&lt;I, N></code>: Specifying an integer array attribute&rsquo;s <code>I</code>-th
element to be equal to <code>N</code></li><li><code>IntArrayNthElemMinValue&lt;I, N></code>: Specifying an integer array attribute&rsquo;s
<code>I</code>-th element to be greater than or equal to <code>N</code></li></ul><p>TODO: Design and implement more primitive constraints</p><h3 id=operation-results>Operation results</h3><p>Similar to operands, results are specified inside the <code>dag</code>-typed <code>results</code>, led
by <code>outs</code>:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
  <span class=p>&lt;</span><span class=nv>type</span><span class=err>-</span><span class=nv>constraint</span><span class=p>&gt;</span><span class=p>:</span><span class=err>$</span><span class=p>&lt;</span><span class=nv>result</span><span class=err>-</span><span class=nv>name</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>)</span><span class=p>;</span>
</code></pre></div><h4 id=variadic-results>Variadic results</h4><p>Similar to variadic operands, <code>Variadic&lt;...></code> can also be used for results.
And similarly, <code>SameVariadicResultSize</code> for multiple variadic results in the
same operation.</p><h3 id=operation-traits-and-constraints>Operation traits and constraints</h3><p>Traits are operation properties that affect syntax or semantics. MLIR C++
models various traits in the <code>mlir::OpTrait</code> namespace.</p><p>Both operation traits,
<a href=#operation-interfaces>interfaces</a>
, and constraints
involving multiple operands/attributes/results are provided as the second
template parameter to the <code>Op</code> class. They should be deriving from the <code>OpTrait</code>
class. See
<a href=#constraints>Constraints</a>
for more information.</p><h3 id=operation-interfaces>Operation interfaces</h3><p><a href=/docs/Interfaces/#operation-interfaces>Operation interfaces</a>
are a mechanism by
which to opaquely call methods and access information on an <em>Op instance</em>,
without knowing the exact operation type. Operation interfaces defined in C++
can be accessed in the ODS framework via the <code>OpInterfaceTrait</code> class. Aside
from using pre-existing interfaces in the C++ API, the ODS framework also
provides a simplified mechanism for defining such interfaces; that removes much
of the boilerplate necessary.</p><p>Providing a definition of the <code>OpInterface</code> class will auto-generate the C++
classes for the interface. An <code>OpInterface</code> includes a name, for the C++ class,
a description, and a list of interface methods.</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyInterface</span> <span class=p>:</span> <span class=nv>OpInterface</span><span class=p>&lt;</span><span class=s>&#34;MyInterface&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
  <span class=k>let</span> <span class=nv>methods</span> <span class=p>=</span> <span class=p>[</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>]</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>There are two types of methods that can be used with an interface,
<code>InterfaceMethod</code> and <code>StaticInterfaceMethod</code>. They are both comprised of the
same core components, with the distinction that <code>StaticInterfaceMethod</code> models a
static method on the derived operation.</p><p>An <code>InterfaceMethod</code> is comprised of the following components:</p><ul><li>Description<ul><li>A string description of what this method does and its invariants.</li></ul></li><li>ReturnType<ul><li>A string corresponding to the C++ return type of the method.</li></ul></li><li>MethodName<ul><li>A string corresponding to the desired name of the method.</li></ul></li><li>Arguments (Optional)<ul><li>A dag of strings that correspond to a C++ type and variable name
respectively.</li></ul></li><li>MethodBody (Optional)<ul><li>An optional explicit implementation of the interface method.</li><li><code>ConcreteOp</code> is an implicitly defined typename that can be used to refer
to the type of the derived operation currently being operated on.</li><li>In non-static methods, a variable &lsquo;ConcreteOp op&rsquo; is defined and may be
used to refer to an instance of the derived operation.</li></ul></li><li>DefaultImplementation (Optional)<ul><li>An optional explicit default implementation of the interface method.</li><li>This method is placed within the <code>Trait</code> class that is attached to the
operation. As such, this method has the same characteristics as any
other
<a href=/docs/Traits/><code>Trait</code></a>
method.</li><li><code>ConcreteOp</code> is an implicitly defined typename that can be used to refer
to the type of the derived operation currently being operated on.</li></ul></li></ul><p>ODS also allows generating the declarations for the <code>InterfaceMethod</code> of the op
if one specifies the interface with <code>DeclareOpInterfaceMethods</code> (see example
below).</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyInterface</span> <span class=p>:</span> <span class=nv>OpInterface</span><span class=p>&lt;</span><span class=s>&#34;MyInterface&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>    My interface is very interesting. ...
</span><span class=s>  }]</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>methods</span> <span class=p>=</span> <span class=p>[</span>
    <span class=c>// A simple non-static method with no inputs.
</span><span class=c></span>    <span class=nv>InterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;&#39;foo&#39; is a non-static method with no inputs.&#34;</span><span class=p>,</span>
      <span class=s>&#34;unsigned&#34;</span><span class=p>,</span> <span class=s>&#34;foo&#34;</span>
    <span class=p>&gt;</span><span class=p>,</span>

    <span class=c>// A new non-static method accepting an input argument.
</span><span class=c></span>    <span class=nv>InterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;/*insert doc here*/&#34;</span><span class=p>,</span>
      <span class=s>&#34;Value &#34;</span><span class=p>,</span> <span class=s>&#34;bar&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nv>ins</span> <span class=s>&#34;unsigned&#34;</span><span class=p>:</span><span class=nv>$i</span><span class=p>)</span>
    <span class=p>&gt;</span><span class=p>,</span>

    <span class=c>// Query a static property of the derived operation.
</span><span class=c></span>    <span class=nv>StaticInterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;&#39;fooStatic&#39; is a static method with no inputs.&#34;</span><span class=p>,</span>
      <span class=s>&#34;unsigned&#34;</span><span class=p>,</span> <span class=s>&#34;fooStatic&#34;</span>
    <span class=p>&gt;</span><span class=p>,</span>

    <span class=c>// Provide the definition of a static interface method.
</span><span class=c></span>    <span class=c>// Note: `ConcreteOp` corresponds to the derived operation typename.
</span><span class=c></span>    <span class=nv>StaticInterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;/*insert doc here*/&#34;</span><span class=p>,</span>
      <span class=s>&#34;Operation *&#34;</span><span class=p>,</span> <span class=s>&#34;create&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nv>ins</span> <span class=s>&#34;OpBuilder &amp;&#34;</span><span class=p>:</span><span class=nv>$builder</span><span class=p>,</span> <span class=s>&#34;Location&#34;</span><span class=p>:</span><span class=nv>$loc</span><span class=p>)</span><span class=p>,</span> <span class=s>[{
</span><span class=s>        return builder.create&lt;ConcreteOp&gt;(loc);
</span><span class=s>    }]</span><span class=p>&gt;</span><span class=p>,</span>

    <span class=c>// Provide a definition of the non-static method.
</span><span class=c></span>    <span class=c>// Note: `op` corresponds to the derived operation variable.
</span><span class=c></span>    <span class=nv>InterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;/*insert doc here*/&#34;</span><span class=p>,</span>
      <span class=s>&#34;unsigned&#34;</span><span class=p>,</span> <span class=s>&#34;getNumInputsAndOutputs&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nv>ins</span><span class=p>)</span><span class=p>,</span> <span class=s>[{
</span><span class=s>        return op.getNumInputs() + op.getNumOutputs();
</span><span class=s>    }]</span><span class=p>&gt;</span><span class=p>,</span>

    <span class=c>// Provide only a default definition of the method.
</span><span class=c></span>    <span class=c>// Note: `ConcreteOp` corresponds to the derived operation typename.
</span><span class=c></span>    <span class=nv>InterfaceMethod</span><span class=p>&lt;</span><span class=s>&#34;/*insert doc here*/&#34;</span><span class=p>,</span>
      <span class=s>&#34;unsigned&#34;</span><span class=p>,</span> <span class=s>&#34;getNumInputsAndOutputs&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nv>ins</span><span class=p>)</span><span class=p>,</span> <span class=err>/</span><span class=p>*</span><span class=nv>methodBody</span><span class=p>=</span><span class=p>*</span><span class=err>/</span><span class=s>[{}]</span><span class=p>,</span> <span class=s>[{
</span><span class=s>        ConcreteOp op = cast&lt;ConcreteOp&gt;(getOperation());
</span><span class=s>        return op.getNumInputs() + op.getNumOutputs();
</span><span class=s>    }]</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=p>]</span><span class=p>;</span>
<span class=p>}</span>

<span class=c>// Interfaces can optionally be wrapped inside DeclareOpInterfaceMethods. This
</span><span class=c></span><span class=c>// would result in autogenerating declarations for members `foo`, `bar` and
</span><span class=c></span><span class=c>// `fooStatic`. Methods with bodies are not declared inside the op
</span><span class=c></span><span class=c>// declaration but instead handled by the op interface trait directly.
</span><span class=c></span><span class=k>def</span> <span class=nv>OpWithInferTypeInterfaceOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=p>.</span><span class=p>.</span><span class=p>.</span>
    <span class=p>[</span><span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MyInterface</span><span class=p>&gt;</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>{</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>}</span>
</code></pre></div><p>A verification method can also be specified on the <code>OpInterface</code> by setting
<code>verify</code>. Setting <code>verify</code> results in the generated trait having a <code>verifyTrait</code>
method that is applied to all operations implementing the trait.</p><h3 id=builder-methods>Builder methods</h3><p>For each operation, there are a few builders automatically generated based on
the arguments and returns types. For example, given the following op definition:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
    <span class=nv>I32</span><span class=p>:</span><span class=nv>$i32_operand</span><span class=p>,</span>
    <span class=nv>F32</span><span class=p>:</span><span class=nv>$f32_operand</span><span class=p>,</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>

    <span class=nv>I32Attr</span><span class=p>:</span><span class=nv>$i32_attr</span><span class=p>,</span>
    <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$f32_attr</span><span class=p>,</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>)</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
    <span class=nv>I32</span><span class=p>:</span><span class=nv>$i32_result</span><span class=p>,</span>
    <span class=nv>F32</span><span class=p>:</span><span class=nv>$f32_result</span><span class=p>,</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The following builders are generated:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// All result-types/operands/attributes have one aggregate parameter.
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span>
                  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>resultTypes</span><span class=p>,</span>
                  <span class=n>ValueRange</span> <span class=n>operands</span><span class=p>,</span>
                  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>NamedAttribute</span><span class=o>&gt;</span> <span class=n>attributes</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Each result-type/operand/attribute has a separate parameter. The parameters
</span><span class=c1></span><span class=c1>// for attributes are of mlir::Attribute types.
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span>
                  <span class=n>Type</span> <span class=n>i32_result</span><span class=p>,</span> <span class=n>Type</span> <span class=n>f32_result</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>
                  <span class=n>Value</span> <span class=n>i32_operand</span><span class=p>,</span> <span class=n>Value</span> <span class=n>f32_operand</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>
                  <span class=n>IntegerAttr</span> <span class=n>i32_attr</span><span class=p>,</span> <span class=n>FloatAttr</span> <span class=n>f32_attr</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Each result-type/operand/attribute has a separate parameter. The parameters
</span><span class=c1></span><span class=c1>// for attributes are raw values unwrapped with mlir::Attribute instances.
</span><span class=c1></span><span class=c1>// (Note that this builder will not always be generated. See the following
</span><span class=c1></span><span class=c1>// explanation for more details.)
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span>
                  <span class=n>Type</span> <span class=n>i32_result</span><span class=p>,</span> <span class=n>Type</span> <span class=n>f32_result</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>
                  <span class=n>Value</span> <span class=n>i32_operand</span><span class=p>,</span> <span class=n>Value</span> <span class=n>f32_operand</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>
                  <span class=n>APInt</span> <span class=n>i32_attr</span><span class=p>,</span> <span class=n>StringRef</span> <span class=n>f32_attr</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Each operand/attribute has a separate parameter but result type is aggregate.
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span>
                  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>resultTypes</span><span class=p>,</span>
                  <span class=n>Value</span> <span class=n>i32_operand</span><span class=p>,</span> <span class=n>Value</span> <span class=n>f32_operand</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span>
                  <span class=n>IntegerAttr</span> <span class=n>i32_attr</span><span class=p>,</span> <span class=n>FloatAttr</span> <span class=n>f32_attr</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// All operands/attributes have aggregate parameters.
</span><span class=c1></span><span class=c1>// Generated if InferTypeOpInterface interface is specified.
</span><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span>
                  <span class=n>ValueRange</span> <span class=n>operands</span><span class=p>,</span>
                  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>NamedAttribute</span><span class=o>&gt;</span> <span class=n>attributes</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// (And manually specified builders depending on the specific op.)
</span></code></pre></div><p>The first form provides basic uniformity so that we can create ops using the
same form regardless of the exact op. This is particularly useful for
implementing declarative pattern rewrites.</p><p>The second and third forms are good for use in manually written code given that
they provide better guarantee via signatures.</p><p>The third form will be generated if any of the op&rsquo;s attribute has different
<code>Attr.returnType</code> from <code>Attr.storageType</code> and we know how to build an attribute
from an unwrapped value (i.e., <code>Attr.constBuilderCall</code> is defined.)
Additionally, for the third form, if an attribute appearing later in the
<code>arguments</code> list has a default value, the default value will be supplied in the
declaration. This works for <code>BoolAttr</code>, <code>StrAttr</code>, <code>EnumAttr</code> for now and the
list can grow in the future. So if possible, default valued attribute should be
placed at the end of the <code>arguments</code> list to leverage this feature. (This
behavior is essentially due to C++ function parameter default value placement
restrictions.) Otherwise, the builder of the third form will still be generated
but default values for the attributes not at the end of the <code>arguments</code> list
will not be supplied in the builder&rsquo;s signature.</p><p>And there may potentially exist other builders depending on the specific op;
please refer to the
<a href=#run-mlir-tblgen-to-see-the-generated-content>generated C++ file</a>
for the
complete list.</p><h4 id=custom-builder-methods>Custom builder methods</h4><p>However, if the above cases cannot satisfy all needs, you can define additional
convenience build methods with <code>OpBuilder</code>.</p><p><code>OpBuilder</code> is a class that takes the parameter list and the optional <code>build()</code>
method body. They are separated because we need to generate op declaration and
definition into separate files. The parameter list should <em>include</em> <code>Builder *builder, OperationState &state</code>. If the <code>body</code> is not provided, <em>only</em> the
builder declaration will be generated; this provides a way to define complicated
builders entirely in C++ files.</p><p>For example, for the following op:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;my_op&#34;</span><span class=p>,</span> <span class=p>[</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$attr</span><span class=p>)</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>If we want to define a builder with a default value for the only attribute, we
can add into <code>MyOp</code>:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=k>let</span> <span class=nv>builders</span> <span class=p>=</span> <span class=p>[</span>
    <span class=nv>OpBuilder</span><span class=p>&lt;</span><span class=s>&#34;Builder *builder, OperationState &amp;state, float val = 0.5f&#34;</span><span class=p>,</span> <span class=s>[{
</span><span class=s>      state.addAttribute(&#34;attr&#34;, builder-&gt;getF32FloatAttr(val));
</span><span class=s>    }]</span><span class=p>&gt;</span>
  <span class=p>]</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The generated builder will look like:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=n>Builder</span> <span class=o>*</span><span class=n>builder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=kt>float</span> <span class=n>val</span> <span class=o>=</span> <span class=mf>0.5f</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>state</span><span class=p>.</span><span class=n>addAttribute</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>attr</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>builder</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getF32FloatAttr</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=custom-parser-and-printer-methods>Custom parser and printer methods</h3><p>Functions to parse and print the operation&rsquo;s custom assembly form.</p><h3 id=custom-verifier-code>Custom verifier code</h3><p>Verification code will be automatically generated for
<a href=#constraints>constraints</a>
specified on various entities of the op. To
perform <em>additional</em> verification, you can use</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>let</span> <span class=nv>verifier</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>  ...
</span><span class=s>}]</span><span class=p>;</span>
</code></pre></div><p>Code placed in <code>verifier</code> will be called after the auto-generated verification
code.</p><h3 id=hascanonicalizer><code>hasCanonicalizer</code></h3><p>This boolean field indicate whether canonicalization patterns have been defined
for this operation. If it is <code>1</code>, then <code>::getCanonicalizationPatterns()</code> should
be defined.</p><h3 id=hasfolder><code>hasFolder</code></h3><p>This boolean field indicate whether general folding rules have been defined
for this operation. If it is <code>1</code>, then <code>::fold()</code> should be defined.</p><h3 id=extra-declarations>Extra declarations</h3><p>One of the goals of table-driven op definition is to auto-generate as much logic
and methods needed for each op as possible. With that said, there will always be
long-tail cases that won&rsquo;t be covered. For such cases, you can use
<code>extraClassDeclaration</code>. Code in <code>extraClassDeclaration</code> will be copied
literally to the generated C++ op class.</p><p>Note that <code>extraClassDeclaration</code> is a mechanism intended for long-tail cases
by power users; for not-yet-implemented widely-applicable cases, improving the
infrastructure is preferable.</p><h3 id=generated-c-code>Generated C++ code</h3><p><a href=../tools/mlir-tblgen/OpDefinitionsGen.cpp>OpDefinitionsGen</a>
processes the op definition spec file and
generates two files containing the corresponding C++ code: one for declarations,
the other for definitions. The former is generated via the <code>-gen-op-decls</code>
command-line option, while the latter is via the <code>-gen-op-defs</code> option.</p><p>The definition file contains all the op method definitions, which can be
included and enabled by defining <code>GET_OP_CLASSES</code>. For each operation,
OpDefinitionsGen generates an operation class and an
<a href=#operand-adaptors>operand adaptor</a>
class. Besides, it also contains a
comma-separated list of all defined ops, which can be included and enabled by
defining <code>GET_OP_LIST</code>.</p><h4 id=class-name-and-namespaces>Class name and namespaces</h4><p>For each operation, its generated C++ class name is the symbol <code>def</code>ed with
TableGen with dialect prefix removed. The first <code>_</code> serves as the delimiter.
For example, for <code>def TF_AddOp</code>, the C++ class name would be <code>AddOp</code>.
We remove the <code>TF</code> prefix because it is for scoping ops; other dialects
may as well define their own <code>AddOp</code>s.</p><p>The namespaces of the generated C++ class will come from the dialect&rsquo;s
<code>cppNamespace</code> field. For example, if a dialect&rsquo;s <code>cppNamespace</code> is <code>A::B</code>,
then an op of that dialect will be placed in
<code>namespace A { namespace B { ... } }</code>. If a dialect does not specify a
<code>cppNamespace</code>, we then use the dialect&rsquo;s name as the namespace.</p><p>This means the qualified name of the generated C++ class does not necessarily
match exactly with the operation name as explained in
<a href=#operation-name>Operation name</a>
. This is to allow flexible naming to satisfy
coding style requirements.</p><h4 id=operand-adaptors>Operand adaptors</h4><p>For each operation, we automatically generate an <em>operand adaptor</em>. This class
solves the problem of accessing operands provided as a list of <code>Value</code>s without
using &ldquo;magic&rdquo; constants. The operand adaptor takes a reference to an array of
<code>Value</code> and provides methods with the same names as those in the operation class
to access them. For example, for a binary arithmetic operation, it may provide
<code>.lhs()</code> to access the first operand and <code>.rhs()</code> to access the second operand.</p><p>The operand adaptor class lives in the same namespace as the operation class,
and has the name of the operation followed by <code>OperandAdaptor</code>. A template
declaration <code>OperandAdaptor&lt;></code> is provided to look up the operand adaptor for
the given operation.</p><p>Operand adaptors can be used in function templates that also process operations:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>BinaryOpTy</span><span class=o>&gt;</span>
<span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>Value</span><span class=p>,</span> <span class=n>Value</span><span class=o>&gt;</span> <span class=n>zip</span><span class=p>(</span><span class=n>BinaryOpTy</span> <span class=o>&amp;</span><span class=o>&amp;</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>make_pair</span><span class=p>(</span><span class=n>op</span><span class=p>.</span><span class=n>lhs</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>op</span><span class=p>.</span><span class=n>rhs</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>AddOp</span> <span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>newOperands</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>zip</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>;</span>
  <span class=n>zip</span><span class=p>(</span><span class=n>OperandAdaptor</span><span class=o>&lt;</span><span class=n>AddOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>newOperands</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=cm>/*...*/</span>
<span class=p>}</span>
</code></pre></div><h2 id=constraints>Constraints</h2><p>Constraint is a core concept in table-driven operation definition: operation
verification and graph operation matching are all based on satisfying
constraints. So both the operation definition and rewrite rules specification
significantly involve writing constraints. We have the <code>Constraint</code> class in
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
has the common base class for all constraints.</p><p>An operation&rsquo;s constraint can cover different range; it may</p><ul><li>Only concern a single attribute (e.g. being an 32-bit integer greater than 5),</li><li>Multiple operands and results (e.g., the 1st result&rsquo;s shape must be the same
as the 1st operand), or</li><li>Intrinsic to the operation itself (e.g., having no side effect).</li></ul><p>We call them as single-entity constraint, multi-entity constraint, and traits,
respectively.</p><h3 id=single-entity-constraint>Single-entity constraint</h3><p>Constraints scoped to a single operand, attribute, or result are specified at
the entity&rsquo;s declaration place as described in
<a href=#operation-arguments>Operation arguments</a>
and
<a href=#operation-results>Operation results</a>
.</p><p>To help modelling constraints of common types, a set of <code>TypeConstraint</code>s are
created; they are the <code>Type</code> subclass hierarchy. It includes <code>F32</code> for the
constraints of being a float, <code>TensorOf&lt;[F32]></code> for the constraints of being
a float tensor, and so on.</p><p>Similarly, a set of <code>AttrConstraint</code>s are created for helping modelling
constraints of common attribute kinds. They are the <code>Attr</code> subclass hierarchy.
It includes <code>F32Attr</code> for the constraints of being a float attribute,
<code>F32ArrayAttr</code> for the constraints of being a float array attribute, and so on.</p><h3 id=multi-entity-constraint>Multi-entity constraint</h3><p>Constraints involving more than one operand/attribute/result are quite common
on operations, like the element type and shape relation between operands and
results. These constraints should be specified as the <code>Op</code> class template
parameter as described in
<a href=#operation-traits-and-constraints>Operation traits and constraints</a>
.</p><p>Multi-entity constraints are modeled as <code>PredOpTrait</code> (a subclass of <code>OpTrait</code>)
in
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
.A bunch of constraint primitives are provided to help
specification. See
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
for the complete list.</p><h3 id=trait>Trait</h3><p>Traits are intrinsic properties of the operation like having side effect or not,
commutative or not, whether is a terminator, etc. These constraints should be
specified as the <code>Op</code> class template parameter as described in
<a href=#operation-traits-and-constraints>Operation traits and constraints</a>
.</p><p>Traits are modeled as <code>NativeOpTrait</code> (a subclass of <code>OpTrait</code>) in
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
. They are backed and will be translated into the
corresponding C++ <code>mlir::OpTrait</code> classes.</p><h3 id=how-to-specify-new-constraint>How to specify new constraint</h3><p>To write a constraint, you need to provide its predicates and give it a
descriptive name. Predicates, modeled with the <code>Pred</code> class, are the workhorse
for composing constraints. The predicate for a constraint is typically built up
in a nested manner, using the two categories of predicates:</p><ol><li><code>CPred</code>: the primitive leaf predicate.</li><li>Compound predicate: a predicate composed from child predicates using
predicate combiners (conjunction: <code>And</code>, disjunction: <code>Or</code>, negation: <code>Neg</code>,
substitution: <code>SubstLeaves</code>, concatenation: <code>Concat</code>).</li></ol><p><code>CPred</code> is the basis for composing more complex predicates. It is the &ldquo;atom&rdquo;
predicate from the perspective of TableGen and the &ldquo;interface&rdquo; between
TableGen and C++. What is inside is already C++ code, which will be treated
as opaque strings with special placeholders to be substituted.</p><p>You can put any C++ code that returns a boolean value inside a <code>CPred</code>,
including evaluating expressions, calling functions, calling class methods,
and so on.</p><p>To help interaction with the C++ environment, there are a few special
placeholders provided to refer to entities in the context where this predicate
is used. They serve as &ldquo;hooks&rdquo; to the enclosing environment. This includes
<code>$_builder</code>, <code>$_op</code>, and <code>$_self</code>:</p><ul><li><code>$_builder</code> will be replaced by a <code>mlir::Builder</code> instance so that you can
access common build methods.</li><li><code>$_op</code> will be replaced by the current operation so that you can access
information of the current operation.</li><li><code>$_self</code> will be replaced with the entity this predicate is attached to.
E.g., <code>BoolAttr</code> is an attribute constraint that wraps a
<code>CPred&lt;"$_self.isa&lt;BoolAttr>()"></code>. Then for <code>F32:$attr</code>,<code>$_self</code> will be
replaced by <code>$attr</code>. For type constraints, it&rsquo;s a little bit special since
we want the constraints on each type definition reads naturally and we want
to attach type constraints directly to an operand/result, <code>$_self</code> will be
replaced by the operand/result&rsquo;s type. E.g., for <code>F32</code> in <code>F32:$operand</code>, its
<code>$_self</code> will be expanded as <code>getOperand(...).getType()</code>.</li></ul><p>TODO(b/130663252): Reconsider the leading symbol for special placeholders.
Eventually we want to allow referencing operand/result $-names; such $-names
can start with underscore.</p><p>For example, to write an attribute <code>attr</code> is an <code>IntegerAttr</code>, in C++ you can
just call <code>attr.isa&lt;IntegerAttr>()</code>. The code can be wrapped in a <code>CPred</code> as
<code>$_self.isa&lt;IntegerAttr>()</code>, with <code>$_self</code> as the special placeholder to be
replaced by the current attribute <code>attr</code> at expansion time.</p><p>For more complicated predicates, you can wrap it in a single <code>CPred</code>, or you
can use predicate combiners to combine them. For example, to write the
constraint that an attribute <code>attr</code> is a 32-bit or 64-bit integer, you can
write it as</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=nv>And</span><span class=p>&lt;</span><span class=p>[</span>
  <span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;$_self.isa&lt;IntegerAttr&gt;()&#34;</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>Or</span><span class=p>&lt;</span><span class=p>[</span>
    <span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(32)&#34;</span><span class=p>&gt;</span><span class=p>,</span>
    <span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(64)&#34;</span><span class=p>&gt;</span>
  <span class=p>]</span><span class=p>&gt;</span>
<span class=p>]</span><span class=p>&gt;</span>
</code></pre></div><p>(Note that the above is just to show with a familiar example how you can use
<code>CPred</code> and predicate combiners to write complicated predicates. For integer
attributes specifically,
<a href=../include/mlir/IR/OpBase.td><code>OpBase.td</code></a>
already defines <code>I32Attr</code> and
<code>I64Attr</code>. So you can actually reuse them to write it as <code>Or&lt;[I32Attr.predicate, I64Attr.predicate]></code>.)</p><p>TODO: Build up a library of reusable primitive constraints</p><p>If the predicate is very complex to write with <code>CPred</code> together with predicate
combiners, you can also write it as a normal C++ function and use the <code>CPred</code>
as a way to &ldquo;invoke&rdquo; the function. For example, to verify an attribute <code>attr</code>
has some property, you can write a C++ function like</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>bool</span> <span class=nf>HasSomeProperty</span><span class=p>(</span><span class=n>Attribute</span> <span class=n>attr</span><span class=p>)</span> <span class=p>{</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>}</span>
</code></pre></div><p>and then define the op as:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>HasSomeProperty</span> <span class=p>:</span> <span class=nv>AttrConstraint</span><span class=p>&lt;</span><span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;HasSomeProperty($_self)&#34;</span><span class=p>&gt;</span><span class=p>,</span>
                                     <span class=s>&#34;has some property&#34;</span><span class=p>&gt;</span><span class=p>;</span>

<span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
    <span class=nv>HasSomeProperty</span><span class=p>:</span><span class=nv>$attr</span>
  <span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>As to whether we should define the predicate using a single <code>CPred</code> wrapping
the whole expression, multiple <code>CPred</code>s with predicate combiners, or a single
<code>CPred</code> &ldquo;invoking&rdquo; a function, there are no clear-cut criteria. Defining using
<code>CPred</code> and predicate combiners is preferable since it exposes more information
(instead hiding all the logic behind a C++ function) into the op definition spec
so that it can potentially drive more auto-generation cases. But it will
require a nice library of common predicates as the building blocks to avoid the
duplication, which is being worked on right now.</p><h2 id=attribute-definition>Attribute Definition</h2><h3 id=enum-attributes>Enum attributes</h3><p>Some attributes can only take values from an predefined enum, e.g., the
comparison kind of a comparison op. To define such attributes, ODS provides
several mechanisms: <code>StrEnumAttr</code>, <code>IntEnumAttr</code>, and <code>BitEnumAttr</code>.</p><ul><li><code>StrEnumAttr</code>: each enum case is a string, the attribute is stored as a
<a href=/docs/LangRef/#string-attribute><code>StringAttr</code></a>
in the op.</li><li><code>IntEnumAttr</code>: each enum case is an integer, the attribute is stored as a
<a href=/docs/LangRef/#integer-attribute><code>IntegerAttr</code></a>
in the op.</li><li><code>BitEnumAttr</code>: each enum case is a bit, the attribute is stored as a
<a href=/docs/LangRef/#integer-attribute><code>IntegerAttr</code></a>
in the op.</li></ul><p>All these <code>*EnumAttr</code> attributes require fully specifying all of the allowed
cases via their corresponding <code>*EnumAttrCase</code>. With this, ODS is able to
generate additional verification to only accept allowed cases. To facilitate the
interaction between <code>*EnumAttr</code>s and their C++ consumers, the
<a href=../tools/mlir-tblgen/EnumsGen.cpp><code>EnumsGen</code></a>
TableGen backend can generate a few common utilities: a
C++ enum class, <code>llvm::DenseMapInfo</code> for the enum class, conversion functions
from/to strings. This is controlled via the <code>-gen-enum-decls</code> and
<code>-gen-enum-defs</code> command-line options of <code>mlir-tblgen</code>.</p><p>For example, given the following <code>EnumAttr</code>:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>Case15</span><span class=p>:</span> <span class=nv>I32EnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;Case15&#34;</span><span class=p>,</span> <span class=m>15</span><span class=p>&gt;</span><span class=p>;</span>
<span class=k>def</span> <span class=nv>Case20</span><span class=p>:</span> <span class=nv>I32EnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;Case20&#34;</span><span class=p>,</span> <span class=m>20</span><span class=p>&gt;</span><span class=p>;</span>

<span class=k>def</span> <span class=nv>MyIntEnum</span><span class=p>:</span> <span class=nv>I32EnumAttr</span><span class=p>&lt;</span><span class=s>&#34;MyIntEnum&#34;</span><span class=p>,</span> <span class=s>&#34;An example int enum&#34;</span><span class=p>,</span>
                           <span class=p>[</span><span class=nv>Case15</span><span class=p>,</span> <span class=nv>Case20</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>cppNamespace</span> <span class=p>=</span> <span class=s>&#34;Outer::Inner&#34;</span><span class=p>;</span>
  <span class=k>let</span> <span class=nv>stringToSymbolFnName</span> <span class=p>=</span> <span class=s>&#34;ConvertToEnum&#34;</span><span class=p>;</span>
  <span class=k>let</span> <span class=nv>symbolToStringFnName</span> <span class=p>=</span> <span class=s>&#34;ConvertToString&#34;</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The following will be generated via <code>mlir-tblgen -gen-enum-decls</code>:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=n>Outer</span> <span class=p>{</span>
<span class=k>namespace</span> <span class=n>Inner</span> <span class=p>{</span>
<span class=c1>// An example int enum
</span><span class=c1></span><span class=k>enum</span> <span class=k>class</span> <span class=nc>MyIntEnum</span> <span class=o>:</span> <span class=kt>uint32_t</span> <span class=p>{</span>
  <span class=n>Case15</span> <span class=o>=</span> <span class=mi>15</span><span class=p>,</span>
  <span class=n>Case20</span> <span class=o>=</span> <span class=mi>20</span><span class=p>,</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyIntEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyIntEnum</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=p>;</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span> <span class=n>ConvertToString</span><span class=p>(</span><span class=n>MyIntEnum</span><span class=p>)</span><span class=p>;</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyIntEnum</span><span class=o>&gt;</span> <span class=n>ConvertToEnum</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span><span class=p>)</span><span class=p>;</span>
<span class=kr>inline</span> <span class=k>constexpr</span> <span class=kt>unsigned</span> <span class=nf>getMaxEnumValForMyIntEnum</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=mi>20</span><span class=p>;</span>
<span class=p>}</span>

<span class=p>}</span> <span class=c1>// namespace Inner
</span><span class=c1></span><span class=p>}</span> <span class=c1>// namespace Outer
</span><span class=c1></span>
<span class=k>namespace</span> <span class=n>llvm</span> <span class=p>{</span>
<span class=k>template</span><span class=o>&lt;</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>DenseMapInfo</span><span class=o>&lt;</span><span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=k>using</span> <span class=n>StorageInfo</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>DenseMapInfo</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>;</span>

  <span class=k>static</span> <span class=kr>inline</span> <span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span> <span class=n>getEmptyKey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getEmptyKey</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kr>inline</span> <span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span> <span class=n>getTombstoneKey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getTombstoneKey</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getHashValue</span><span class=p>(</span><span class=k>const</span> <span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getHashValue</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kt>bool</span> <span class=nf>isEqual</span><span class=p>(</span><span class=k>const</span> <span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=n>Outer</span><span class=o>:</span><span class=o>:</span><span class=n>Inner</span><span class=o>:</span><span class=o>:</span><span class=n>MyIntEnum</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>lhs</span> <span class=o>=</span><span class=o>=</span> <span class=n>rhs</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The following will be generated via <code>mlir-tblgen -gen-enum-defs</code>:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=n>Outer</span> <span class=p>{</span>
<span class=k>namespace</span> <span class=n>Inner</span> <span class=p>{</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span> <span class=n>ConvertToString</span><span class=p>(</span><span class=n>MyIntEnum</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>switch</span> <span class=p>(</span><span class=n>val</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>case</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=nl>Case15</span><span class=p>:</span> <span class=k>return</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Case15</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>case</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=nl>Case20</span><span class=p>:</span> <span class=k>return</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Case20</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=sa></span><span class=s>&#34;</span><span class=s>&#34;</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyIntEnum</span><span class=o>&gt;</span> <span class=n>ConvertToEnum</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringSwitch</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyIntEnum</span><span class=o>&gt;</span><span class=o>&gt;</span><span class=p>(</span><span class=n>str</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Case</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Case15</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=n>Case15</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Case</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Case20</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=n>Case20</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Default</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyIntEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyIntEnum</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>switch</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>case</span> <span class=mi>15</span><span class=o>:</span> <span class=k>return</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=n>Case15</span><span class=p>;</span>
  <span class=k>case</span> <span class=mi>20</span><span class=o>:</span> <span class=k>return</span> <span class=n>MyIntEnum</span><span class=o>:</span><span class=o>:</span><span class=n>Case20</span><span class=p>;</span>
  <span class=k>default</span><span class=o>:</span> <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=p>}</span> <span class=c1>// namespace Inner
</span><span class=c1></span><span class=p>}</span> <span class=c1>// namespace Outer
</span></code></pre></div><p>Similarly for the following <code>BitEnumAttr</code> definition:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>None</span><span class=p>:</span> <span class=nv>BitEnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;None&#34;</span><span class=p>,</span> <span class=nv>0x0000</span><span class=p>&gt;</span><span class=p>;</span>
<span class=k>def</span> <span class=nv>Bit1</span><span class=p>:</span> <span class=nv>BitEnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;Bit1&#34;</span><span class=p>,</span> <span class=nv>0x0001</span><span class=p>&gt;</span><span class=p>;</span>
<span class=k>def</span> <span class=nv>Bit2</span><span class=p>:</span> <span class=nv>BitEnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;Bit2&#34;</span><span class=p>,</span> <span class=nv>0x0002</span><span class=p>&gt;</span><span class=p>;</span>
<span class=k>def</span> <span class=nv>Bit3</span><span class=p>:</span> <span class=nv>BitEnumAttrCase</span><span class=p>&lt;</span><span class=s>&#34;Bit3&#34;</span><span class=p>,</span> <span class=nv>0x0004</span><span class=p>&gt;</span><span class=p>;</span>

<span class=k>def</span> <span class=nv>MyBitEnum</span><span class=p>:</span> <span class=nv>BitEnumAttr</span><span class=p>&lt;</span><span class=s>&#34;MyBitEnum&#34;</span><span class=p>,</span> <span class=s>&#34;An example bit enum&#34;</span><span class=p>,</span>
                           <span class=p>[</span><span class=nv>None</span><span class=p>,</span> <span class=nv>Bit1</span><span class=p>,</span> <span class=nv>Bit2</span><span class=p>,</span> <span class=nv>Bit3</span><span class=p>]</span><span class=p>&gt;</span><span class=p>;</span>
</code></pre></div><p>We can have:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// An example bit enum
</span><span class=c1></span><span class=k>enum</span> <span class=k>class</span> <span class=nc>MyBitEnum</span> <span class=o>:</span> <span class=kt>uint32_t</span> <span class=p>{</span>
  <span class=n>None</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>Bit1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
  <span class=n>Bit2</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span>
  <span class=n>Bit3</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyBitEnum</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=p>;</span>
<span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>string</span> <span class=n>stringifyMyBitEnum</span><span class=p>(</span><span class=n>MyBitEnum</span><span class=p>)</span><span class=p>;</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyBitEnum</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span><span class=p>)</span><span class=p>;</span>
<span class=kr>inline</span> <span class=n>MyBitEnum</span> <span class=k>operator</span><span class=o>|</span><span class=p>(</span><span class=n>MyBitEnum</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>MyBitEnum</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span> <span class=o>|</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=kr>inline</span> <span class=n>MyBitEnum</span> <span class=k>operator</span><span class=o>&amp;</span><span class=p>(</span><span class=n>MyBitEnum</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>MyBitEnum</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span> <span class=o>&amp;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=kr>inline</span> <span class=kt>bool</span> <span class=nf>bitEnumContains</span><span class=p>(</span><span class=n>MyBitEnum</span> <span class=n>bits</span><span class=p>,</span> <span class=n>MyBitEnum</span> <span class=n>bit</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>bits</span><span class=p>)</span> <span class=o>&amp;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>bit</span><span class=p>)</span><span class=p>)</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>namespace</span> <span class=n>llvm</span> <span class=p>{</span>
<span class=k>template</span><span class=o>&lt;</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>DenseMapInfo</span><span class=o>&lt;</span><span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=k>using</span> <span class=n>StorageInfo</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>DenseMapInfo</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>;</span>

  <span class=k>static</span> <span class=kr>inline</span> <span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span> <span class=n>getEmptyKey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getEmptyKey</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kr>inline</span> <span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span> <span class=n>getTombstoneKey</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getTombstoneKey</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getHashValue</span><span class=p>(</span><span class=k>const</span> <span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>StorageInfo</span><span class=o>:</span><span class=o>:</span><span class=n>getHashValue</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>static</span> <span class=kt>bool</span> <span class=nf>isEqual</span><span class=p>(</span><span class=k>const</span> <span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=k>const</span> <span class=o>:</span><span class=o>:</span><span class=n>MyBitEnum</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>lhs</span> <span class=o>=</span><span class=o>=</span> <span class=n>rhs</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>string</span> <span class=n>stringifyMyBitEnum</span><span class=p>(</span><span class=n>MyBitEnum</span> <span class=n>symbol</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=n>val</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>symbol</span><span class=p>)</span><span class=p>;</span>
  <span class=c1>// Special case for all bits unset.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>val</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=sa></span><span class=s>&#34;</span><span class=s>None</span><span class=s>&#34;</span><span class=p>;</span>

  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span> <span class=n>strs</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=mi>1u</span> <span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span> <span class=n>strs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit1</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span> <span class=n>val</span> <span class=o>&amp;</span><span class=o>=</span> <span class=o>~</span><span class=mi>1u</span><span class=p>;</span> <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=mi>2u</span> <span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span> <span class=n>strs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit2</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span> <span class=n>val</span> <span class=o>&amp;</span><span class=o>=</span> <span class=o>~</span><span class=mi>2u</span><span class=p>;</span> <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=mi>4u</span> <span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span> <span class=n>strs</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit3</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span> <span class=n>val</span> <span class=o>&amp;</span><span class=o>=</span> <span class=o>~</span><span class=mi>4u</span><span class=p>;</span> <span class=p>}</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>val</span><span class=p>)</span> <span class=k>return</span> <span class=sa></span><span class=s>&#34;</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>join</span><span class=p>(</span><span class=n>strs</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>|</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyBitEnum</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Special case for all bits unset.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>str</span> <span class=o>=</span><span class=o>=</span> <span class=sa></span><span class=s>&#34;</span><span class=s>None</span><span class=s>&#34;</span><span class=p>)</span> <span class=k>return</span> <span class=n>MyBitEnum</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>;</span>

  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringRef</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span> <span class=n>symbols</span><span class=p>;</span>
  <span class=n>str</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>symbols</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>|</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>

  <span class=kt>uint32_t</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>symbol</span> <span class=p>:</span> <span class=n>symbols</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>bit</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>StringSwitch</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=o>&gt;</span><span class=p>(</span><span class=n>symbol</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Case</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit1</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Case</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit2</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Case</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>Bit3</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
      <span class=p>.</span><span class=n>Default</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bit</span><span class=p>)</span> <span class=p>{</span> <span class=n>val</span> <span class=o>|</span><span class=o>=</span> <span class=o>*</span><span class=n>bit</span><span class=p>;</span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>;</span> <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span> <span class=n>symbolizeMyBitEnum</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Special case for all bits unset.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>MyBitEnum</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>;</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=mi>1u</span> <span class=o>|</span> <span class=mi>2u</span> <span class=o>|</span> <span class=mi>4u</span><span class=p>)</span><span class=p>)</span> <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>None</span><span class=p>;</span>
  <span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>MyBitEnum</span><span class=o>&gt;</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>TODO(b/132506080): This following is outdated. Update it.</p><p>An attribute is a compile time known constant of an operation. Attributes are
required to be known to construct an operation (e.g., the padding behavior is
required to fully define the <code>conv2d</code> op).</p><p>Attributes are defined as having a storage type (corresponding to a derived
class of <code>mlir::Attribute</code>), a return type (that corresponds to the C++ type to
use in the generation of the helper accessors) as well as method to convert
between the internal storage and the helper method. Derived attributes are a
special class of attributes that do not have storage but are instead calculated
based on the operation and its attributes.</p><h2 id=debugging-tips>Debugging Tips</h2><h3 id=run-mlir-tblgen-to-see-the-generated-content>Run <code>mlir-tblgen</code> to see the generated content</h3><p>TableGen syntax sometimes can be obscure; reading the generated content can be
a very helpful way to understand and debug issues. To build <code>mlir-tblgen</code>, run
<code>cmake --build . --target mlir-tblgen</code> in your build directory and find the
<code>mlir-tblgen</code> binary in the <code>bin/</code> subdirectory. All the supported generators
can be found via <code>mlir-tblgen --help</code>. For example, <code>--gen-op-decls</code> and
<code>--gen-op-defs</code> as explained in
<a href=#generated-c++-code>Generated C++ code</a>
.</p><p>To see the generated code, invoke <code>mlir-tblgen</code> with a specific generator by
providing include paths via <code>-I</code>. For example,</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>mlir-tblgen --gen-op-decls -I /path/to/mlir/include /path/to/input/td/file
mlir-tblgen --gen-op-defs -I /path/to/mlir/include /path/to/input/td/file
mlir-tblgen --gen-op-doc -I /path/to/mlir/include /path/to/input/td/file

mlir-tblgen --gen-op-interface-decls -I /path/to/mlir/include /path/to/input/td/file
mlir-tblgen --gen-op-interface-defs -I /path/to/mlir/include /path/to/input/td/file
mlir-tblgen --gen-op-interface-doc -I /path/to/mlir/include /path/to/input/td/file
</code></pre></div><h2 id=appendix>Appendix</h2><h3 id=requirements-and-existing-mechanisms-analysis>Requirements and existing mechanisms analysis</h3><p>The op description should as declarative as possible to allow a wide range of
tools to work with them and query methods generated from them. In particular
this means specifying traits, constraints and shape inference information in
a way that is easily analyzable (e.g., avoid opaque calls to C++ functions where
possible).</p><p>We considered the approaches of several contemporary systems and focused on
requirements that were desirable:</p><ul><li><p>Ops registered using a registry separate from C++ code.</p><ul><li>Unknown ops are allowed in MLIR, so ops need not be registered. The
ability of the compiler to optimize those ops or graphs containing those
ops is constrained but correct.</li><li>The current proposal does not include a runtime op description, but it
does not preclude such description, it can be added later.</li><li>The op registry is essential for generating C++ classes that make
manipulating ops, verifying correct construction etc. in C++ easier by
providing a typed representation and accessors.</li></ul></li><li><p>The op registry will be defined in
<a href=https://llvm.org/docs/TableGen/index.html>TableGen</a>
and be used to
generate C++ classes and utility functions
(builder/verifier/parser/printer).</p><ul><li>TableGen is a modelling specification language used by LLVM&rsquo;s backends
and fits in well with trait-based modelling. This is an implementation
decision and there are alternative ways of doing this. But the
specification language is good for the requirements of modelling the
traits (as seen from usage in LLVM processor backend modelling) and easy
to extend, so a practical choice. If another good option comes up, we
will consider it.</li></ul></li><li><p>MLIR allows both defined and undefined ops.</p><ul><li>Defined ops should have fixed semantics and could have a corresponding
reference implementation defined using, for example, EDSC.</li><li>Dialects are under full control of the dialect owner and normally live
with the framework of the dialect.</li></ul></li><li><p>The op&rsquo;s traits (e.g., commutative) are modelled along with the op in the
registry.</p></li><li><p>The op&rsquo;s operand/return type constraints are modelled along with the op in
the registry (see
<a href=/docs/ShapeInference/>Shape inference</a>
discussion below),
this allows (e.g.) optimized concise syntax in textual dumps.</p></li><li><p>Behavior of the op is documented along with the op with a summary and a
description. The description is written in markdown and extracted for
inclusion in the generated LangRef section of the dialect.</p></li><li><p>The generic assembly form of printing and parsing is available as normal,
but a custom parser and printer can either be specified or automatically
generated from an optional string representation showing the mapping of the
&ldquo;assembly&rdquo; string to operands/type.</p><ul><li>Parser-level remappings (e.g., <code>eq</code> to enum) will be supported as part
of the parser generation.</li></ul></li><li><p>Matching patterns are specified separately from the op description.</p><ul><li>Contrasted with LLVM there is no &ldquo;base&rdquo; set of ops that every backend
needs to be aware of. Instead there are many different dialects and the
transformations/legalizations between these dialects form a graph of
transformations.</li></ul></li><li><p>Reference implementation may be provided along with the op definition.</p><ul><li>The reference implementation may be in terms of either standard ops or
other reference implementations.</li></ul><p>TODO: document expectation if the dependent op&rsquo;s definition changes.</p></li></ul><h3 id=a-proposal-for-auto-generating-printer-and-parser-methods>A proposal for auto-generating printer and parser methods</h3><p>NOTE: Auto-generating printing/parsing (as explained in the below) has <em>not</em>
been prototyped, and potentially just being able to specify custom printer/
parser methods are sufficient. This should presumably be influenced by the
design of the assembler/disassembler logic that LLVM backends get for free
for machine instructions.</p><p>The custom assembly form of the operation is specified using a string with
matching operation name, operands and attributes. With the ability
to express additional information that needs to be parsed to build the
operation:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=nv>tfl</span><span class=p>.</span><span class=nv>add</span> <span class=nv>$lhs</span><span class=p>,</span> <span class=nv>$rhs</span> <span class=p>{</span><span class=nv>fused_activation_function</span><span class=p>:</span> <span class=nv>$fused_activation_function</span><span class=p>}</span><span class=p>:</span> <span class=err>$</span><span class=p>{</span><span class=nv>type</span><span class=p>(</span><span class=nv>self</span><span class=p>)</span><span class=p>}</span>
</code></pre></div><ol><li>The output is never shown in the &ldquo;mnemonics&rdquo; string as that is fixed form
and cannot be altered.</li><li>Custom parsing of ops may include some punctuation (e.g., parenthesis).</li><li>The operands/results are added to the created operation in the order that
they are shown in the input and output dags.</li><li>The <code>${type(self)}</code> operator is used to represent the type of the operator.
The type of operands can also be queried.</li><li>Attributes names are matched to the placeholders in the mnemonic strings.
E.g., attribute axis is matched with <code>$axis</code>. Custom parsing for attribute
type can be defined along with the attribute definition.</li><li>The information in the custom assembly form should be sufficient to invoke
the builder generated. That may require being able to propagate information
(e.g., the <code>$lhs</code> has the same type as the result).</li></ol><p>Printing is effectively the inverse of the parsing function generated with the
mnemonic string serving as a template.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/DeclarativeRewrites/ title="Table-driven Declarative Rewrite Rule (DRR)"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Table-driven Declarative Rewrite Rule (DRR)</a>
<a class="nav nav-next" href=/docs/UsageOfConst/ title="Usage of 'Const' in MLIR, for core IR types">Next - Usage of 'Const' in MLIR, for core IR types <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=active><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>