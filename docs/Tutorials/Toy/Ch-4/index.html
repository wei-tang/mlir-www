<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 4: Enabling Generic Transformation with Interfaces - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.62.2"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 4: Enabling Generic Transformation with Interfaces</h1><p>[TOC]</p><h2 id=background-grappling-with-an-extensible-ir>Background: Grappling with an Extensible IR</h2><p>Through dialects, MLIR allows for the representation of many different levels of
abstraction; the Toy dialect that we have previously defined is one such
example. Though these different dialects may represent different abstractions,
there is often a set of common transformations and analyses that we would like
to perform. The problem that arises is that naively implementing each
transformation for each dialect leads to large amounts of code duplication, as
the internal algorithms are generally very similar, if not the same. We would
like to provide the ability for transformations to opaquely hook into dialects
like Toy to get the information they need.</p><p>MLIR provides a set of always available-hooks for certain core transformations,
as seen in the
<a href=/docs/Tutorials/Toy/Ch-3/>previous chapter</a>
, where we registered some
canonicalizations via a hook on our operations (<code>getCanonicalizationPatterns</code>).
However, these types of hooks don't really scale well. Therefore, a more generic
solution was designed, in the form of
<a href=/docs/Interfaces/>interfaces</a>
, to make
the MLIR infrastructure as extensible as the representation. Interfaces provide
a generic mechanism for dialects and operations to provide information to a
transformation or analysis.</p><h2 id=shape-inference-preparing-for-code-generation>Shape Inference: Preparing for Code Generation</h2><p>Our Toy IR currently operates on generic tensors, meaning that we don't know the
shape of tensors other than during the initialization of constants. This
complicates optimizations, as well as code generation. Fortunately, we can
simply propagate the shapes through the computation until they are all known.
The issue is how to handle calls to user-defined generic functions: every call
site could deduce different shapes. One possibility would be to perform symbolic
inference based on the argument types, but this would be hard to generalize if
we were to introduce more control flow in the language. Another approach would
be function specialization, where every call site with new argument shapes
duplicates the called function and specializes it. The approach we take for Toy
is to inline all of the function calls, then perform intraprocedural shape
propagation.</p><h3 id=inlining>Inlining</h3><p>Here we could write an inlining algorithm specifically designed for the Toy
dialect, but that can become quite complicated depending on the level of
complexity that we want. Disregarding cost modeling, the pure structural
transformation is already complex to implement from scratch. Thankfully, MLIR
provides a generic inliner algorithm that dialects can plug into. All we need to
do in Toy is to provide the
<a href=/docs/Interfaces/>interfaces</a>
for the inliner to
hook into.</p><p>The first thing we need to do is to define the constraints on inlining
operations in the Toy dialect. This information is provided through a
<a href=/docs/Interfaces/#dialect-interfaces>dialect interface</a>
. This is essentially
a class containing a set of virtual hooks for which a dialect may provide a
specialization. In this case, the interface is <code>DialectInlinerInterface</code>.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// This class defines the interface for handling inlining with Toy operations.
</span><span class=c1></span><span class=c1>/// We simplify inherit from the base interface class and provide a
</span><span class=c1></span><span class=c1>/// specialization of the necessary methods.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>ToyInlinerInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>DialectInlinerInterface</span> <span class=p>{</span>
  <span class=k>using</span> <span class=n>DialectInlinerInterface</span><span class=o>:</span><span class=o>:</span><span class=n>DialectInlinerInterface</span><span class=p>;</span>

  <span class=c1>/// This hook checks to see if the given operation is legal to inline into the
</span><span class=c1></span>  <span class=c1>/// given region. For Toy this hook can simply return true, as all Toy
</span><span class=c1></span>  <span class=c1>/// operations are inlinable.
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>isLegalToInline</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=p>,</span>
                       <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>/// This hook is called when a terminator operation has been inlined. The only
</span><span class=c1></span>  <span class=c1>/// terminator that we have in the Toy dialect is the return
</span><span class=c1></span>  <span class=c1>/// operation(toy.return). We handle the return by replacing the values
</span><span class=c1></span>  <span class=c1>/// previously returned by the call operation with the operands of the
</span><span class=c1></span>  <span class=c1>/// return.
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>handleTerminator</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span>
                        <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>valuesToRepl</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=c1>// Only &#34;toy.return&#34; needs to be handled here.
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>returnOp</span> <span class=o>=</span> <span class=n>cast</span><span class=o>&lt;</span><span class=n>ReturnOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>;</span>

    <span class=c1>// Replace the values directly with the return operands.
</span><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>returnOp</span><span class=p>.</span><span class=n>getNumOperands</span><span class=p>(</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=n>valuesToRepl</span><span class=p>.</span><span class=n>size</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>it</span> <span class=p>:</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>enumerate</span><span class=p>(</span><span class=n>returnOp</span><span class=p>.</span><span class=n>getOperands</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
      <span class=n>valuesToRepl</span><span class=p>[</span><span class=n>it</span><span class=p>.</span><span class=n>index</span><span class=p>(</span><span class=p>)</span><span class=p>]</span><span class=p>.</span><span class=n>replaceAllUsesWith</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>value</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>We then register our dialect interface directly on the Toy dialect, similarly to
how we did for operations.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ToyDialect</span><span class=o>:</span><span class=o>:</span><span class=n>ToyDialect</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=o>:</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Dialect</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>toy</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>addInterfaces</span><span class=o>&lt;</span><span class=n>ToyInlinerInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Next, we need to provide a way for the inliner to know that <code>toy.generic_call</code>
represents a call to a function. MLIR provides an
<a href=/docs/Interfaces/#operation-interfaces>operation interface</a>
that can be used
to mark an operation as being &ldquo;call-like&rdquo;. Unlike dialect interfaces, operation
interfaces provide a more refined granularity of information that is specific
and core to a single operation. The interface that we will be adding here is the
<code>CallOpInterface</code>.</p><p>To add this interface we just need to include the definition into our operation
specification file (<code>Ops.td</code>):</p><pre><code class=language-tablegen data-lang=tablegen>#ifdef MLIR_CALLINTERFACES
#else
include &quot;mlir/Analysis/CallInterfaces.td&quot;
#endif // MLIR_CALLINTERFACES
</code></pre><p>and add it to the traits list of <code>GenericCallOp</code>:</p><pre><code class=language-tablegen data-lang=tablegen>def GenericCallOp : Toy_Op&lt;&quot;generic_call&quot;,
    [DeclareOpInterfaceMethods&lt;CallOpInterface&gt;]&gt; {
  ...
}
</code></pre><p>In the above we also use the <code>DeclareOpInterfaceMethods</code> directive to
auto-declare all of the interface methods in the class declaration of
GenericCallOp. This means that we just need to provide a definition:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Return the callee of the generic call operation, this is required by the
</span><span class=c1></span><span class=c1>/// call interface.
</span><span class=c1></span><span class=n>CallInterfaceCallable</span> <span class=n>GenericCallOp</span><span class=o>:</span><span class=o>:</span><span class=n>getCallableForCallee</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=n>getAttrOfType</span><span class=o>&lt;</span><span class=n>SymbolRefAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>callee</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>/// Get the argument operands to the called function, this is required by the
</span><span class=c1></span><span class=c1>/// call interface.
</span><span class=c1></span><span class=n>Operation</span><span class=o>:</span><span class=o>:</span><span class=n>operand_range</span> <span class=n>GenericCallOp</span><span class=o>:</span><span class=o>:</span><span class=n>getArgOperands</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>inputs</span><span class=p>(</span><span class=p>)</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>Now that the inliner has been informed about the Toy dialect, we can add the
inliner pass to the pass manager for Toy:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>createInlinerPass</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><p>Now let's look at a working example:</p><pre><code class=language-mlir data-lang=mlir>func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = &quot;toy.transpose&quot;(%arg0) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %1 = &quot;toy.transpose&quot;(%arg1) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %2 = &quot;toy.mul&quot;(%0, %1) : (tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  &quot;toy.return&quot;(%2) : (tensor&lt;*xf64&gt;) -&gt; ()
}
func @main() {
  %0 = &quot;toy.constant&quot;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %1 = &quot;toy.reshape&quot;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;2x3xf64&gt;
  %2 = &quot;toy.constant&quot;() {value = dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt;} : () -&gt; tensor&lt;6xf64&gt;
  %3 = &quot;toy.reshape&quot;(%2) : (tensor&lt;6xf64&gt;) -&gt; tensor&lt;2x3xf64&gt;
  %4 = &quot;toy.generic_call&quot;(%1, %3) {callee = @multiply_transpose} : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %5 = &quot;toy.generic_call&quot;(%3, %1) {callee = @multiply_transpose} : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  &quot;toy.print&quot;(%5) : (tensor&lt;*xf64&gt;) -&gt; ()
  &quot;toy.return&quot;() : () -&gt; ()
}
</code></pre><p>We have two calls to multiple_transpose that we would like to inline into main,
but if we look at the output nothing has changed. We are missing one last subtle
piece: there is a hidden type conversion on the edge of the call. If we look at
the above, the operands to the generic_call are of type <code>tensor&lt;2x3xf64></code>, while
the inputs to the function expect <code>tensor&lt;*xf64></code>. To resolve this difference,
the inliner expects an explicit cast operation to be inserted. For this, we need
to add a new operation to the Toy dialect, <code>ToyCastOp</code>(toy.cast), to represent
casts between two different shapes.</p><pre><code class=language-tablegen data-lang=tablegen>def CastOp : Toy_Op&lt;&quot;cast&quot;, [NoSideEffect, SameOperandsAndResultShape]&gt; {
  let summary = &quot;shape cast operation&quot;;
  let description = [{
    The &quot;cast&quot; operation converts a tensor from one type to an equivalent type
    without changing any data elements. The source and destination types
    must both be tensor types with the same element type. If both are ranked
    then the rank should be the same and static dimensions should match. The
    operation is invalid if converting to a mismatching constant dimension.
  }];

  let arguments = (ins F64Tensor:$input);
  let results = (outs F64Tensor:$output);

  // Set the folder bit so that we can fold redundant cast operations.
  let hasFolder = 1;
}
</code></pre><p>We can then override the necessary hook on the ToyInlinerInterface to insert
this for us when necessary:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>ToyInlinerInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>DialectInlinerInterface</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=c1>/// Attempts to materialize a conversion for a type mismatch between a call
</span><span class=c1></span>  <span class=c1>/// from this dialect, and a callable region. This method should generate an
</span><span class=c1></span>  <span class=c1>/// operation that takes &#39;input&#39; as the only operand, and produces a single
</span><span class=c1></span>  <span class=c1>/// result of &#39;resultType&#39;. If a conversion can not be generated, nullptr
</span><span class=c1></span>  <span class=c1>/// should be returned.
</span><span class=c1></span>  <span class=n>Operation</span> <span class=o>*</span><span class=n>materializeCallConversion</span><span class=p>(</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>builder</span><span class=p>,</span> <span class=n>Value</span> <span class=n>input</span><span class=p>,</span>
                                       <span class=n>Type</span> <span class=n>resultType</span><span class=p>,</span>
                                       <span class=n>Location</span> <span class=n>conversionLoc</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>builder</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>CastOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>conversionLoc</span><span class=p>,</span> <span class=n>resultType</span><span class=p>,</span> <span class=n>input</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>If we run the working example through the pipeline again, we get the expected:</p><pre><code class=language-mlir data-lang=mlir>func @main() {
  %0 = &quot;toy.constant&quot;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %1 = &quot;toy.constant&quot;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %2 = &quot;toy.cast&quot;(%1) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %3 = &quot;toy.cast&quot;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %4 = &quot;toy.transpose&quot;(%2) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %5 = &quot;toy.transpose&quot;(%3) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %6 = &quot;toy.mul&quot;(%4, %5) : (tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  &quot;toy.print&quot;(%6) : (tensor&lt;*xf64&gt;) -&gt; ()
  &quot;toy.return&quot;() : () -&gt; ()
}
</code></pre><p>NOTE: The generic inliner will also perform simplifications, so the output may
be a bit cleaner than expected.</p><h3 id=intraprocedural-shape-inference>Intraprocedural Shape Inference</h3><p>Now that we have inlined all of the functions, we are left with a main function
containing a mix of static and dynamically shaped operations. We can now write a
simple shape inference pass to propagate shapes intraprocedurally (within a
single function). We could write this as a pass that directly encodes the
constraints of the operations within the Toy dialect, but this seems like a good
candidate for a transformation that could be written generically. As a good rule
of thumb, it is best to express a transformation as generically as possible,
such that it can be extended to other dialects in the future. There is no
telling how many other dialects may have similar needs or encounter the same
problems.</p><p>For shape inference, if we break down the problem to its core, we really just
want operations to tell us the expected outputs given a set of statically known
inputs. (We can definitely get more complex than that, but for our needs we can
keep it simple.) Given that this property is core to a specific operation, we
can define an operation interface that can be specified on operations that need
to have their result shapes inferred.</p><p>Similarly to operations, we can also
<a href=/docs/OpDefinitions/#operation-interfaces>define operation interfaces</a>
using
the operation definition specification (ODS) framework.</p><p>The interface is defined by inheriting from <code>OpInterface</code>, which takes the name
to be given to the generated C++ interface class as a template argument. For our
purposes, we will name the generated class a simpler <code>ShapeInference</code>. We also
provide a description for the interface.</p><pre><code class=language-tablegen data-lang=tablegen>def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; {
  let description = [{
    Interface to access a registered method to infer the return types for an
    operation that can be used during type inference.
  }];
}
</code></pre><p>Next, we define the interface methods that the operations will need to provide.
An interface method is comprised of: a description; a C++ return type in string
form; a method name in string form; and a few optional components, depending on
the need. See the
<a href=/docs/OpDefinitions/#operation-interfaces>ODS documentation</a>
for more
information.</p><pre><code class=language-tablegen data-lang=tablegen>def ShapeInferenceOpInterface : OpInterface&lt;&quot;ShapeInference&quot;&gt; {
  let description = [{
    Interface to access a registered method to infer the return types for an
    operation that can be used during type inference.
  }];

  let methods = [
    InterfaceMethod&lt;&quot;Infer and set the output shape for the current operation.&quot;,
                    &quot;void&quot;, &quot;inferShapes&quot;&gt;
  ];
}
</code></pre><p>Now that the interface is defined, we can add it to the necessary Toy operations
in a similar way to how we added the <code>CallOpInterface</code> to the GenericCallOp:</p><pre><code class=language-tablegen data-lang=tablegen>def MulOp : Toy_Op&lt;&quot;mul&quot;,
    [..., DeclareOpInterfaceMethods&lt;ShapeInferenceOpInterface&gt;]&gt; {
  ...
}
</code></pre><p>Each of these operations will then need to provide a definition for the
<code>inferShapes()</code> method. As an example, for the mul op, the result shape is
inferred as the shape of the inputs.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Infer the output shape of the MulOp, this is required by the shape inference
</span><span class=c1></span><span class=c1>/// interface.
</span><span class=c1></span><span class=kt>void</span> <span class=n>MulOp</span><span class=o>:</span><span class=o>:</span><span class=n>inferShapes</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=n>getResult</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>setType</span><span class=p>(</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=p>.</span><span class=n>getType</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>At this point, each of the necessary Toy operations provide a mechanism by which
to infer their output shapes. The ShapeInferencePass is a FunctionPass: it will
runs on each Function in isolation. MLIR also supports general
<a href=/docs/WritingAPass/#operation-pass>OperationPasses</a>
that run on any isolated
operation (i.e. other function-like operations), but here our module only
contains functions, so there is no need to generalize to all operations.</p><p>Implementing such a pass is done by creating a class inheriting from
<code>mlir::FunctionPass</code> and overriding the <code>runOnFunction()</code> method:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>ShapeInferencePass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>FunctionPass</span><span class=o>&lt;</span><span class=n>ShapeInferencePass</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=kt>void</span> <span class=nf>runOnFunction</span><span class=p>(</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
    <span class=n>FuncOp</span> <span class=n>function</span> <span class=o>=</span> <span class=n>getFunction</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>The algorithm operates as follows:</p><ol><li>Build a worklist containing all the operations that return a dynamically
shaped tensor: these are the operations that need shape inference.</li><li>Iterate on the worklist:<ul><li>find an operation to process: the next ready operation in the worklist
has all of its arguments non-generic,</li><li>if no operation is found, break out of the loop,</li><li>remove the operation from the worklist,</li><li>infer the shape of its output from the argument types.</li></ul></li><li>If the worklist is empty, the algorithm succeeded.</li></ol><p>When processing an operation, we query if it registered the <code>ShapeInference</code>
interface.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// Ask the operation to infer its output shapes.
</span><span class=c1></span>  <span class=n>LLVM_DEBUG</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>dbgs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Inferring shape for: </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=o>*</span><span class=n>op</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>/// We check if an operation has a particular interface by casting.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>ShapeInference</span> <span class=n>shapeOp</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>ShapeInference</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>shapeOp</span><span class=p>.</span><span class=n>inferShapes</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>emitError</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>unable to infer shape of operation without shape </span><span class=s>&#34;</span>
                  <span class=sa></span><span class=s>&#34;</span><span class=s>inference interface</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=nf>signalPassFailure</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
</code></pre></div><p>We can then add our pass to the pass manager:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>createShapeInferencePass</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><p>If we rerun our original example, we now get the following:</p><pre><code class=language-mlir data-lang=mlir>func @main() {
  %0 = &quot;toy.constant&quot;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %1 = &quot;toy.transpose&quot;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  %2 = &quot;toy.mul&quot;(%1, %1) : (tensor&lt;3x2xf64&gt;, tensor&lt;3x2xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  &quot;toy.print&quot;(%2) : (tensor&lt;3x2xf64&gt;) -&gt; ()
  &quot;toy.return&quot;() : () -&gt; ()
}
</code></pre><p>You can build <code>toyc-ch4</code> and try yourself: <code>toyc-ch4 test/Examples/Toy/Ch4/codegen.toy -emit=mlir -opt</code>.</p><p>In the
<a href=/docs/Tutorials/Toy/Ch-5/>next chapter</a>
, we will start the process of code generation by
targeting a lower level dialect for optimizing some of the more compute-heavy
Toy operations.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Tutorials/Toy/Ch-3/ title="Chapter 3: High-level Language-Specific Analysis and Transformation"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 3: High-level Language-Specific Analysis and Transformation</a>
<a class="nav nav-next" href=/docs/Tutorials/Toy/Ch-5/ title="Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization">Next - Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Tutorials/Toy/>Toy<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li class=active><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>