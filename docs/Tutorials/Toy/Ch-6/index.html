<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 6: Lowering to LLVM and CodeGeneration - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.62.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 6: Lowering to LLVM and CodeGeneration</h1><p>[TOC]</p><p>In the
<a href=/docs/Tutorials/Toy/Ch-5/>previous chapter</a>
, we introduced the
<a href=/docs/DialectConversion/>dialect conversion</a>
framework and partially lowered
many of the <code>Toy</code> operations to affine loop nests for optimization. In this
chapter, we will finally lower to LLVM for code generation.</p><p>For this lowering, we will again use the dialect conversion framework to perform
the heavy lifting. However, this time, we will be performing a full conversion
to the
<a href=/docs/Dialects/LLVM/>LLVM dialect</a>
. Thankfully, we have already
lowered all but one of the <code>toy</code> operations, with the last being <code>toy.print</code>.
Before going over the conversion to LLVM, let's lower the <code>toy.print</code> operation.
We will lower this operation to a non-affine loop nest that invokes <code>printf</code> for
each element. Note that, because the dialect conversion framework supports
<a href=/getting_started/Glossary/#transitive-lowering>transitive lowering</a>
, we don't need to
directly emit operations in the LLVM dialect. By transitive lowering, we mean
that the conversion framework may apply multiple patterns to fully legalize an
operation. In this example, we are generating a structured loop nest instead of
the branch-form in the LLVM dialect. As long as we then have a lowering from the
loop operations to LLVM, the lowering will still succeed.</p><p>During lowering we can get, or build, the declaration for printf as so:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Return a symbol reference to the printf function, inserting it into the
</span><span class=c1></span><span class=c1>/// module if necessary.
</span><span class=c1></span><span class=k>static</span> <span class=n>FlatSymbolRefAttr</span> <span class=nf>getOrInsertPrintf</span><span class=p>(</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
                                           <span class=n>ModuleOp</span> <span class=n>module</span><span class=p>,</span>
                                           <span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMDialect</span> <span class=o>*</span><span class=n>llvmDialect</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=o>*</span><span class=n>context</span> <span class=o>=</span> <span class=n>module</span><span class=p>.</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>lookupSymbol</span><span class=o>&lt;</span><span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMFuncOp</span><span class=o>&gt;</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>printf</span><span class=s>&#34;</span><span class=p>)</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>SymbolRefAttr</span><span class=o>:</span><span class=o>:</span><span class=n>get</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>printf</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>context</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Create a function declaration for printf, the signature is:
</span><span class=c1></span>  <span class=c1>//   * `i32 (i8*, ...)`
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>llvmI32Ty</span> <span class=o>=</span> <span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMType</span><span class=o>:</span><span class=o>:</span><span class=n>getInt32Ty</span><span class=p>(</span><span class=n>llvmDialect</span><span class=p>)</span><span class=p>;</span>
  <span class=k>auto</span> <span class=n>llvmI8PtrTy</span> <span class=o>=</span> <span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMType</span><span class=o>:</span><span class=o>:</span><span class=n>getInt8PtrTy</span><span class=p>(</span><span class=n>llvmDialect</span><span class=p>)</span><span class=p>;</span>
  <span class=k>auto</span> <span class=n>llvmFnType</span> <span class=o>=</span> <span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMType</span><span class=o>:</span><span class=o>:</span><span class=n>getFunctionTy</span><span class=p>(</span><span class=n>llvmI32Ty</span><span class=p>,</span> <span class=n>llvmI8PtrTy</span><span class=p>,</span>
                                                  <span class=cm>/*isVarArg=*/</span><span class=nb>true</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Insert the printf function into the body of the parent module.
</span><span class=c1></span>  <span class=n>PatternRewriter</span><span class=o>:</span><span class=o>:</span><span class=n>InsertionGuard</span> <span class=n>insertGuard</span><span class=p>(</span><span class=n>rewriter</span><span class=p>)</span><span class=p>;</span>
  <span class=n>rewriter</span><span class=p>.</span><span class=n>setInsertionPointToStart</span><span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>getBody</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>rewriter</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMFuncOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>getLoc</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>printf</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>llvmFnType</span><span class=p>)</span><span class=p>;</span>
  <span class=k>return</span> <span class=n>SymbolRefAttr</span><span class=o>:</span><span class=o>:</span><span class=n>get</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>printf</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>context</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Now that the lowering for the printf operation has been defined, we can specify
the components necessary for the lowering. These are largely the same as the
components defined in the
<a href=/docs/Tutorials/Toy/Ch-5/>previous chapter</a>
.</p><h2 id=conversion-target>Conversion Target</h2><p>For this conversion, aside from the top-level module, we will be lowering
everything to the LLVM dialect.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ConversionTarget</span> <span class=n>target</span><span class=p>(</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>target</span><span class=p>.</span><span class=n>addLegalDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>LLVM</span><span class=o>:</span><span class=o>:</span><span class=n>LLVMDialect</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>target</span><span class=p>.</span><span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ModuleOp</span><span class=p>,</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ModuleTerminatorOp</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h2 id=type-converter>Type Converter</h2><p>This lowering will also transform the MemRef types which are currently being
operated on into a representation in LLVM. To perform this conversion, we use a
TypeConverter as part of the lowering. This converter specifies how one type
maps to another. This is necessary now that we are performing more complicated
lowerings involving block arguments. Given that we don't have any
Toy-dialect-specific types that need to be lowered, the default converter is
enough for our use case.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>LLVMTypeConverter</span> <span class=nf>typeConverter</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h2 id=conversion-patterns>Conversion Patterns</h2><p>Now that the conversion target has been defined, we need to provide the patterns
used for lowering. At this point in the compilation process, we have a
combination of <code>toy</code>, <code>affine</code>, and <code>std</code> operations. Luckily, the <code>std</code> and
<code>affine</code> dialects already provide the set of patterns needed to transform them
into LLVM dialect. These patterns allow for lowering the IR in multiple stages
by relying on
<a href=/getting_started/Glossary/#transitive-lowering>transitive lowering</a>
.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>OwningRewritePatternList</span> <span class=n>patterns</span><span class=p>;</span>
  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>populateAffineToStdConversionPatterns</span><span class=p>(</span><span class=n>patterns</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>populateLoopToStdConversionPatterns</span><span class=p>(</span><span class=n>patterns</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>populateStdToLLVMConversionPatterns</span><span class=p>(</span><span class=n>typeConverter</span><span class=p>,</span> <span class=n>patterns</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// The only remaining operation to lower from the `toy` dialect, is the
</span><span class=c1></span>  <span class=c1>// PrintOp.
</span><span class=c1></span>  <span class=n>patterns</span><span class=p>.</span><span class=n>insert</span><span class=o>&lt;</span><span class=n>PrintOpLowering</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h2 id=full-lowering>Full Lowering</h2><p>We want to completely lower to LLVM, so we use a <code>FullConversion</code>. This ensures
that only legal operations will remain after the conversion.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ModuleOp</span> <span class=n>module</span> <span class=o>=</span> <span class=n>getModule</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>failed</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>applyFullConversion</span><span class=p>(</span><span class=n>module</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>patterns</span><span class=p>,</span>
                                             <span class=o>&amp;</span><span class=n>typeConverter</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
    <span class=n>signalPassFailure</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><p>Looking back at our current working example:</p><pre><code class=language-mlir data-lang=mlir>func @main() {
  %0 = &quot;toy.constant&quot;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %2 = &quot;toy.transpose&quot;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  %3 = &quot;toy.mul&quot;(%2, %2) : (tensor&lt;3x2xf64&gt;, tensor&lt;3x2xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  &quot;toy.print&quot;(%3) : (tensor&lt;3x2xf64&gt;) -&gt; ()
  &quot;toy.return&quot;() : () -&gt; ()
}
</code></pre><p>We can now lower down to the LLVM dialect, which produces the following code:</p><pre><code class=language-mlir data-lang=mlir>llvm.func @free(!llvm&lt;&quot;i8*&quot;&gt;)
llvm.func @printf(!llvm&lt;&quot;i8*&quot;&gt;, ...) -&gt; !llvm.i32
llvm.func @malloc(!llvm.i64) -&gt; !llvm&lt;&quot;i8*&quot;&gt;
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+00 : f64) : !llvm.double
  %1 = llvm.mlir.constant(2.000000e+00 : f64) : !llvm.double

  ...

^bb16:
  %221 = llvm.extractvalue %25[0 : index] : !llvm&lt;&quot;{ double*, i64, [2 x i64], [2 x i64] }&quot;&gt;
  %222 = llvm.mlir.constant(0 : index) : !llvm.i64
  %223 = llvm.mlir.constant(2 : index) : !llvm.i64
  %224 = llvm.mul %214, %223 : !llvm.i64
  %225 = llvm.add %222, %224 : !llvm.i64
  %226 = llvm.mlir.constant(1 : index) : !llvm.i64
  %227 = llvm.mul %219, %226 : !llvm.i64
  %228 = llvm.add %225, %227 : !llvm.i64
  %229 = llvm.getelementptr %221[%228] : (!llvm&lt;&quot;double*&quot;&gt;, !llvm.i64) -&gt; !llvm&lt;&quot;double*&quot;&gt;
  %230 = llvm.load %229 : !llvm&lt;&quot;double*&quot;&gt;
  %231 = llvm.call @printf(%207, %230) : (!llvm&lt;&quot;i8*&quot;&gt;, !llvm.double) -&gt; !llvm.i32
  %232 = llvm.add %219, %218 : !llvm.i64
  llvm.br ^bb15(%232 : !llvm.i64)

  ...

^bb18:
  %235 = llvm.extractvalue %65[0 : index] : !llvm&lt;&quot;{ double*, i64, [2 x i64], [2 x i64] }&quot;&gt;
  %236 = llvm.bitcast %235 : !llvm&lt;&quot;double*&quot;&gt; to !llvm&lt;&quot;i8*&quot;&gt;
  llvm.call @free(%236) : (!llvm&lt;&quot;i8*&quot;&gt;) -&gt; ()
  %237 = llvm.extractvalue %45[0 : index] : !llvm&lt;&quot;{ double*, i64, [2 x i64], [2 x i64] }&quot;&gt;
  %238 = llvm.bitcast %237 : !llvm&lt;&quot;double*&quot;&gt; to !llvm&lt;&quot;i8*&quot;&gt;
  llvm.call @free(%238) : (!llvm&lt;&quot;i8*&quot;&gt;) -&gt; ()
  %239 = llvm.extractvalue %25[0 : index] : !llvm&lt;&quot;{ double*, i64, [2 x i64], [2 x i64] }&quot;&gt;
  %240 = llvm.bitcast %239 : !llvm&lt;&quot;double*&quot;&gt; to !llvm&lt;&quot;i8*&quot;&gt;
  llvm.call @free(%240) : (!llvm&lt;&quot;i8*&quot;&gt;) -&gt; ()
  llvm.return
}
</code></pre><p>See
<a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM IR Dialect</a>
for
more in-depth details on lowering to the LLVM dialect.</p><p>At this point we are right at the cusp of code generation. We can generate code
in the LLVM dialect, so now we just need to export to LLVM IR and setup a JIT to
run it.</p><h2 id=emitting-llvm-ir>Emitting LLVM IR</h2><p>Now that our module is comprised only of operations in the LLVM dialect, we can
export to LLVM IR. To do this programmatically, we can invoke the following
utility:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>Module</span><span class=o>&gt;</span> <span class=n>llvmModule</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>translateModuleToLLVMIR</span><span class=p>(</span><span class=n>module</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>llvmModule</span><span class=p>)</span>
    <span class=cm>/* ... an error was encountered ... */</span>
</code></pre></div><p>Exporting our module to LLVM IR generates:</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=k>define</span> <span class=kt>void</span> <span class=vg>@main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

<span class=m>102</span><span class=err>:</span>
  <span class=n>%103</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%8</span><span class=p>,</span> <span class=m>0</span>
  <span class=n>%104</span> <span class=p>=</span> <span class=k>mul</span> <span class=k>i64</span> <span class=n>%96</span><span class=p>,</span> <span class=m>2</span>
  <span class=n>%105</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=n>%104</span>
  <span class=n>%106</span> <span class=p>=</span> <span class=k>mul</span> <span class=k>i64</span> <span class=n>%100</span><span class=p>,</span> <span class=m>1</span>
  <span class=n>%107</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=n>%105</span><span class=p>,</span> <span class=n>%106</span>
  <span class=n>%108</span> <span class=p>=</span> <span class=k>getelementptr</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%103</span><span class=p>,</span> <span class=k>i64</span> <span class=n>%107</span>
  <span class=n>%109</span> <span class=p>=</span> <span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%108</span>
  <span class=n>%110</span> <span class=p>=</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=n>%109</span><span class=p>)</span>
  <span class=n>%111</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=n>%100</span><span class=p>,</span> <span class=m>1</span>
  <span class=k>br</span> <span class=kt>label</span> <span class=n>%99</span>

  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

<span class=m>115</span><span class=err>:</span>
  <span class=n>%116</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%24</span><span class=p>,</span> <span class=m>0</span>
  <span class=n>%117</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%116</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%117</span><span class=p>)</span>
  <span class=n>%118</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%16</span><span class=p>,</span> <span class=m>0</span>
  <span class=n>%119</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%118</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%119</span><span class=p>)</span>
  <span class=n>%120</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%8</span><span class=p>,</span> <span class=m>0</span>
  <span class=n>%121</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%120</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%121</span><span class=p>)</span>
  <span class=k>ret</span> <span class=kt>void</span>
<span class=p>}</span>
</code></pre></div><p>If we enable optimization on the generated LLVM IR, we can trim this down quite
a bit:</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=k>define</span> <span class=kt>void</span> <span class=vg>@main</span><span class=p>(</span><span class=p>)</span>
  <span class=n>%0</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>1.000000e+00</span><span class=p>)</span>
  <span class=n>%1</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>1.600000e+01</span><span class=p>)</span>
  <span class=nv>%putchar</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
  <span class=n>%2</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>4.000000e+00</span><span class=p>)</span>
  <span class=n>%3</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>2.500000e+01</span><span class=p>)</span>
  <span class=nv>%putchar.1</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
  <span class=n>%4</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>9.000000e+00</span><span class=p>)</span>
  <span class=n>%5</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>(</span><span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]</span><span class=p>*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>)</span><span class=p>,</span> <span class=kt>double</span> <span class=m>3.600000e+01</span><span class=p>)</span>
  <span class=nv>%putchar.2</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
  <span class=k>ret</span> <span class=kt>void</span>
<span class=p>}</span>
</code></pre></div><p>The full code listing for dumping LLVM IR can be found in <code>Ch6/toy.cpp</code> in the
<code>dumpLLVMIR()</code> function:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>
<span class=kt>int</span> <span class=nf>dumpLLVMIR</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ModuleOp</span> <span class=n>module</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Translate the module, that contains the LLVM dialect, to LLVM IR.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>llvmModule</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>translateModuleToLLVMIR</span><span class=p>(</span><span class=n>module</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>llvmModule</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Failed to emit LLVM IR</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Initialize LLVM targets.
</span><span class=c1></span>  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>InitializeNativeTarget</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>InitializeNativeTargetAsmPrinter</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ExecutionEngine</span><span class=o>:</span><span class=o>:</span><span class=n>setupTargetTriple</span><span class=p>(</span><span class=n>llvmModule</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>/// Optionally run an optimization pipeline over the llvm module.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>optPipeline</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>makeOptimizingTransformer</span><span class=p>(</span>
      <span class=cm>/*optLevel=*/</span><span class=n>EnableOpt</span> <span class=o>?</span> <span class=mi>3</span> <span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/*sizeLevel=*/</span><span class=mi>0</span><span class=p>,</span>
      <span class=cm>/*targetMachine=*/</span><span class=k>nullptr</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>err</span> <span class=o>=</span> <span class=n>optPipeline</span><span class=p>(</span><span class=n>llvmModule</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Failed to optimize LLVM IR </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>err</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=o>*</span><span class=n>llvmModule</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h2 id=setting-up-a-jit>Setting up a JIT</h2><p>Setting up a JIT to run the module containing the LLVM dialect can be done using
the <code>mlir::ExecutionEngine</code> infrastructure. This is a utility wrapper around
LLVM's JIT that accepts <code>.mlir</code> as input. The full code listing for setting up
the JIT can be found in <code>Ch6/toy.cpp</code> in the <code>runJit()</code> function:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=nf>runJit</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ModuleOp</span> <span class=n>module</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Initialize LLVM targets.
</span><span class=c1></span>  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>InitializeNativeTarget</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>InitializeNativeTargetAsmPrinter</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// An optimization pipeline to use within the execution engine.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>optPipeline</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>makeOptimizingTransformer</span><span class=p>(</span>
      <span class=cm>/*optLevel=*/</span><span class=n>EnableOpt</span> <span class=o>?</span> <span class=mi>3</span> <span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/*sizeLevel=*/</span><span class=mi>0</span><span class=p>,</span>
      <span class=cm>/*targetMachine=*/</span><span class=k>nullptr</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Create an MLIR execution engine. The execution engine eagerly JIT-compiles
</span><span class=c1></span>  <span class=c1>// the module.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>maybeEngine</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ExecutionEngine</span><span class=o>:</span><span class=o>:</span><span class=n>create</span><span class=p>(</span><span class=n>module</span><span class=p>,</span> <span class=n>optPipeline</span><span class=p>)</span><span class=p>;</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>maybeEngine</span> <span class=o>&amp;</span><span class=o>&amp;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>failed to construct an execution engine</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
  <span class=k>auto</span> <span class=o>&amp;</span><span class=n>engine</span> <span class=o>=</span> <span class=n>maybeEngine</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Invoke the JIT-compiled function.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>invocationResult</span> <span class=o>=</span> <span class=n>engine</span><span class=o>-</span><span class=o>&gt;</span><span class=n>invoke</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>main</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>invocationResult</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>JIT invocation failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>You can play around with it from the build directory:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ <span class=nb>echo</span> <span class=s1>&#39;def main() { print([[1, 2], [3, 4]]); }&#39;</span> <span class=p>|</span> ./bin/toyc-ch6 -emit<span class=o>=</span>jit
1.000000 2.000000
3.000000 4.000000
</code></pre></div><p>You can also play with <code>-emit=mlir</code>, <code>-emit=mlir-affine</code>, <code>-emit=mlir-llvm</code>, and
<code>-emit=llvm</code> to compare the various levels of IR involved. Also try options like
<a href=/docs/WritingAPass/#ir-printing><code>--print-ir-after-all</code></a>
to track the
evolution of the IR throughout the pipeline.</p><p>So far, we have worked with primitive data types. In the
<a href=/docs/Tutorials/Toy/Ch-7/>next chapter</a>
, we will add a composite <code>struct</code> type.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Tutorials/Toy/Ch-5/ title="Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
<a class="nav nav-next" href=/docs/Tutorials/Toy/Ch-7/ title="Chapter 7: Adding a Composite Type to Toy">Next - Chapter 7: Adding a Composite Type to Toy <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Tutorials/Toy/>Toy<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li class=active><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>