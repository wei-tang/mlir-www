<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</h1><p><nav id=TableOfContents><ul><li><a href=#conversion-target>Conversion Target</a></li><li><a href=#conversion-patterns>Conversion Patterns</a></li><li><a href=#partial-lowering>Partial Lowering</a><ul><li><a href=#design-considerations-with-partial-lowering>Design Considerations With Partial Lowering</a></li></ul></li><li><a href=#complete-toy-example>Complete Toy Example</a></li><li><a href=#taking-advantage-of-affine-optimization>Taking Advantage of Affine Optimization</a></li></ul></nav><p>At this point, we are eager to generate actual code and see our Toy language
take life. We will use LLVM to generate code, but just showing the LLVM builder
interface here wouldn&rsquo;t be very exciting. Instead, we will show how to perform
progressive lowering through a mix of dialects coexisting in the same function.</p><p>To make it more interesting, in this chapter we will consider that we want to
reuse existing optimizations implemented in a dialect optimizing affine
transformations: <code>Affine</code>. This dialect is tailored to the computation-heavy
part of the program and is limited: it doesn&rsquo;t support representing our
<code>toy.print</code> builtin, for instance, neither should it! Instead, we can target
<code>Affine</code> for the computation heavy part of Toy, and in the
<a href=/docs/Tutorials/Toy/Ch-6/>next chapter</a>
directly the <code>LLVM IR</code> dialect for lowering <code>print</code>. As
part of this lowering, we will be lowering from the
<a href=/docs/LangRef/#tensor-type>TensorType</a>
that <code>Toy</code> operates on to the
<a href=/docs/LangRef/#memref-type>MemRefType</a>
that is indexed via an affine
loop-nest. Tensors represent an abstract value-typed sequence of data, meaning
that they don&rsquo;t live in any memory. MemRefs, on the other hand, represent lower
level buffer access, as they are concrete references to a region of memory.</p><h1 id=dialect-conversions>Dialect Conversions</h1><p>MLIR has many different dialects, so it is important to have a unified framework
for
<a href=/getting_started/Glossary/#conversion>converting</a>
between them. This is where the
<code>DialectConversion</code> framework comes into play. This framework allows for
transforming a set of <em>illegal</em> operations to a set of <em>legal</em> ones. To use this
framework, we need to provide two things (and an optional third):</p><ul><li><p>A
<a href=/docs/DialectConversion/#conversion-target>Conversion Target</a></p><ul><li>This is the formal specification of what operations or dialects are
legal for the conversion. Operations that aren&rsquo;t legal will require
rewrite patterns to perform
<a href=/getting_started/Glossary/#legalization>legalization</a>
.</li></ul></li><li><p>A set of
<a href=/docs/DialectConversion/#rewrite-pattern-specification>Rewrite Patterns</a></p><ul><li>This is the set of
<a href=/docs/QuickstartRewrites/>patterns</a>
used to
convert <em>illegal</em> operations into a set of zero or more <em>legal</em> ones.</li></ul></li><li><p>Optionally, a
<a href=/docs/DialectConversion/#type-conversion>Type Converter</a>
.</p><ul><li>If provided, this is used to convert the types of block arguments. We
won&rsquo;t be needing this for our conversion.</li></ul></li></ul><h2 id=conversion-target>Conversion Target</h2><p>For our purposes, we want to convert the compute-intensive <code>Toy</code> operations into
a combination of operations from the <code>Affine</code> <code>Standard</code> dialects for further
optimization. To start off the lowering, we first define our conversion target:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>ToyToAffineLoweringPass</span><span class=o>:</span><span class=o>:</span><span class=n>runOnFunction</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// The first thing to define is the conversion target. This will define the
</span><span class=c1></span>  <span class=c1>// final target for this lowering.
</span><span class=c1></span>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ConversionTarget</span> <span class=n>target</span><span class=p>(</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// We define the specific operations, or dialects, that are legal targets for
</span><span class=c1></span>  <span class=c1>// this lowering. In our case, we are lowering to a combination of the
</span><span class=c1></span>  <span class=c1>// `Affine` and `Standard` dialects.
</span><span class=c1></span>  <span class=n>target</span><span class=p>.</span><span class=n>addLegalDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>AffineOpsDialect</span><span class=p>,</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>StandardOpsDialect</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// We also define the Toy dialect as Illegal so that the conversion will fail
</span><span class=c1></span>  <span class=c1>// if any of these operations are *not* converted. Given that we actually want
</span><span class=c1></span>  <span class=c1>// a partial lowering, we explicitly mark the Toy operations that don&#39;t want
</span><span class=c1></span>  <span class=c1>// to lower, `toy.print`, as *legal*.
</span><span class=c1></span>  <span class=n>target</span><span class=p>.</span><span class=n>addIllegalDialect</span><span class=o>&lt;</span><span class=n>ToyDialect</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=n>target</span><span class=p>.</span><span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>PrintOp</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Above, we first set the toy dialect to illegal, and then the print operation
as legal. We could have done this the other way around.
Individual operations always take precendence over the (more generic) dialect
definitions, so the order doesn&rsquo;t matter. See <code>ConversionTarget::getOpInfo</code>
for the details.</p><h2 id=conversion-patterns>Conversion Patterns</h2><p>After the conversion target has been defined, we can define how to convert the
<em>illegal</em> operations into <em>legal</em> ones. Similarly to the canonicalization
framework introduced in
<a href=/docs/Tutorials/Toy/Ch-3/>chapter 3</a>
, the
<a href=/docs/DialectConversion/><code>DialectConversion</code> framework</a>
also uses
<a href=/docs/QuickstartRewrites/>RewritePatterns</a>
to perform the conversion logic.
These patterns may be the <code>RewritePatterns</code> seen before or a new type of pattern
specific to the conversion framework <code>ConversionPattern</code>. <code>ConversionPatterns</code>
are different from traditional <code>RewritePatterns</code> in that they accept an
additional <code>operands</code> parameter containing operands that have been
remapped/replaced. This is used when dealing with type conversions, as the
pattern will want to operate on values of the new type but match against the
old. For our lowering, this invariant will be useful as it translates from the
<a href=/docs/LangRef/#tensor-type>TensorType</a>
currently being operated on to the
<a href=/docs/LangRef/#memref-type>MemRefType</a>
. Let&rsquo;s look at a snippet of lowering
the <code>toy.transpose</code> operation:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Lower the `toy.transpose` operation to an affine loop nest.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>TransposeOpLowering</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ConversionPattern</span> <span class=p>{</span>
  <span class=n>TransposeOpLowering</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span>
      <span class=o>:</span> <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ConversionPattern</span><span class=p>(</span><span class=n>TransposeOp</span><span class=o>:</span><span class=o>:</span><span class=n>getOperationName</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>ctx</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>

  <span class=c1>/// Match and rewrite the given `toy.transpose` operation, with the given
</span><span class=c1></span>  <span class=c1>/// operands that have been remapped from `tensor&lt;...&gt;` to `memref&lt;...&gt;`.
</span><span class=c1></span>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>PatternMatchResult</span>
  <span class=n>matchAndRewrite</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>operands</span><span class=p>,</span>
                  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>ConversionPatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>loc</span> <span class=o>=</span> <span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getLoc</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

    <span class=c1>// Call to a helper function that will lower the current operation to a set
</span><span class=c1></span>    <span class=c1>// of affine loops. We provide a functor that operates on the remapped
</span><span class=c1></span>    <span class=c1>// operands, as well as the loop induction variables for the inner most
</span><span class=c1></span>    <span class=c1>// loop body.
</span><span class=c1></span>    <span class=n>lowerOpToLoops</span><span class=p>(</span>
        <span class=n>op</span><span class=p>,</span> <span class=n>operands</span><span class=p>,</span> <span class=n>rewriter</span><span class=p>,</span>
        <span class=p>[</span><span class=n>loc</span><span class=p>]</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
              <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>memRefOperands</span><span class=p>,</span>
              <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>loopIvs</span><span class=p>)</span> <span class=p>{</span>
          <span class=c1>// Generate an adaptor for the remapped operands of the TransposeOp.
</span><span class=c1></span>          <span class=c1>// This allows for using the nice named accessors that are generated
</span><span class=c1></span>          <span class=c1>// by the ODS. This adaptor is automatically provided by the ODS
</span><span class=c1></span>          <span class=c1>// framework.
</span><span class=c1></span>          <span class=n>TransposeOpOperandAdaptor</span> <span class=nf>transposeAdaptor</span><span class=p>(</span><span class=n>memRefOperands</span><span class=p>)</span><span class=p>;</span>
          <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Value</span> <span class=n>input</span> <span class=o>=</span> <span class=n>transposeAdaptor</span><span class=p>.</span><span class=n>input</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

          <span class=c1>// Transpose the elements by generating a load from the reverse
</span><span class=c1></span>          <span class=c1>// indices.
</span><span class=c1></span>          <span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>Value</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span> <span class=n>reverseIvs</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>reverse</span><span class=p>(</span><span class=n>loopIvs</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
          <span class=k>return</span> <span class=n>rewriter</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>AffineLoadOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span> <span class=n>input</span><span class=p>,</span> <span class=n>reverseIvs</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=nf>matchSuccess</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>Now we can prepare the list of patterns to use during the lowering process:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>ToyToAffineLoweringPass</span><span class=o>:</span><span class=o>:</span><span class=n>runOnFunction</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=c1>// Now that the conversion target has been defined, we just need to provide
</span><span class=c1></span>  <span class=c1>// the set of patterns that will lower the Toy operations.
</span><span class=c1></span>  <span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>OwningRewritePatternList</span> <span class=n>patterns</span><span class=p>;</span>
  <span class=n>patterns</span><span class=p>.</span><span class=n>insert</span><span class=o>&lt;</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span> <span class=n>TransposeOpLowering</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>

  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
</code></pre></div><h2 id=partial-lowering>Partial Lowering</h2><p>Once the patterns have been defined, we can perform the actual lowering. The
<code>DialectConversion</code> framework provides several different modes of lowering, but,
for our purposes, we will perform a partial lowering, as we will not convert
<code>toy.print</code> at this time.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>ToyToAffineLoweringPass</span><span class=o>:</span><span class=o>:</span><span class=n>runOnFunction</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=c1>// With the target and rewrite patterns defined, we can now attempt the
</span><span class=c1></span>  <span class=c1>// conversion. The conversion will signal failure if any of our *illegal*
</span><span class=c1></span>  <span class=c1>// operations were not converted successfully.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>function</span> <span class=o>=</span> <span class=n>getFunction</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>failed</span><span class=p>(</span><span class=n>mlir</span><span class=o>:</span><span class=o>:</span><span class=n>applyPartialConversion</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>patterns</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
    <span class=n>signalPassFailure</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=design-considerations-with-partial-lowering>Design Considerations With Partial Lowering</h3><p>Before diving into the result of our lowering, this is a good time to discuss
potential design considerations when it comes to partial lowering. In our
lowering, we transform from a value-type, TensorType, to an allocated
(buffer-like) type, MemRefType. However, given that we do not lower the
<code>toy.print</code> operation, we need to temporarily bridge these two worlds. There are
many ways to go about this, each with their own tradeoffs:</p><ul><li><p>Generate <code>load</code> operations from the buffer</p><p>One option is to generate <code>load</code> operations from the buffer type to materialize
an instance of the value type. This allows for the definition of the <code>toy.print</code>
operation to remain unchanged. The downside to this approach is that the
optimizations on the <code>affine</code> dialect are limited, because the <code>load</code> will
actually involve a full copy that is only visible <em>after</em> our optimizations have
been performed.</p></li><li><p>Generate a new version of <code>toy.print</code> that operates on the lowered type</p><p>Another option would be to have another, lowered, variant of <code>toy.print</code> that
operates on the lowered type. The benefit of this option is that there is no
hidden, unnecessary copy to the optimizer. The downside is that another
operation definition is needed that may duplicate many aspects of the first.
Defining a base class in
<a href=/docs/OpDefinitions/>ODS</a>
may simplify this, but
you still need to treat these operations separately.</p></li><li><p>Update <code>toy.print</code> to allow for operating on the lowered type</p><p>A third option is to update the current definition of <code>toy.print</code> to allow for
operating the on the lowered type. The benefit of this approach is that it is
simple, does not introduce an additional hidden copy, and does not require
another operation definition. The downside to this option is that it requires
mixing abstraction levels in the <code>Toy</code> dialect.</p></li></ul><p>For the sake of simplicity, we will use the third option for this lowering. This
involves updating the type constraints on the PrintOp in the operation
definition file:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>PrintOp</span> <span class=p>:</span> <span class=nv>Toy_Op</span><span class=p>&lt;</span><span class=s>&#34;print&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=c>// The print operation takes an input tensor to print.
</span><span class=c></span>  <span class=c>// We also allow a F64MemRef to enable interop during partial lowering.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>AnyTypeOf</span><span class=p>&lt;</span><span class=p>[</span><span class=nv>F64Tensor</span><span class=p>,</span> <span class=nv>F64MemRef</span><span class=p>]</span><span class=p>&gt;</span><span class=p>:</span><span class=nv>$input</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h2 id=complete-toy-example>Complete Toy Example</h2><p>Looking back at our current working example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> toy<span class=p>.</span><span class=kt>constant</span> dense<span class=p>&lt;</span><span class=p>[</span><span class=p>[</span><span class=m>1.000000e+00</span><span class=p>,</span> <span class=m>2.000000e+00</span><span class=p>,</span> <span class=m>3.000000e+00</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=m>4.000000e+00</span><span class=p>,</span> <span class=m>5.000000e+00</span><span class=p>,</span> <span class=m>6.000000e+00</span><span class=p>]</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> toy<span class=p>.</span>transpose<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span><span class=p>)</span> to <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> toy<span class=p>.</span>mul <span class=nv>%2</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  toy<span class=p>.</span>print <span class=nv>%3</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  toy<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>With affine lowering added to our pipeline, we can now generate:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%cst</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>4.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_4</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>6.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>

  <span class=c>// Allocating buffers for the inputs and outputs.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>

  <span class=c>// Initialize the input buffer with the constant values.
</span><span class=c></span>  affine<span class=p>.</span>store <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_0</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_2</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_3</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_4</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>

  <span class=c>// Load the transpose value from the input buffer and store it into the
</span><span class=c></span>  <span class=c>// next input buffer.
</span><span class=c></span>  affine<span class=p>.</span>for <span class=nv>%arg0</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>3</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%arg1</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>2</span> <span class=p>{</span>
      <span class=nv>%3</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%2</span><span class=p>[</span><span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
      affine<span class=p>.</span>store <span class=nv>%3</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c>// Multiply and store into the output buffer.
</span><span class=c></span>  affine<span class=p>.</span>for <span class=nv>%arg0</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>2</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%arg1</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>3</span> <span class=p>{</span>
      <span class=nv>%3</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%1</span><span class=p>[</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
      <span class=nv>%4</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%1</span><span class=p>[</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
      <span class=nv>%5</span> <span class=p>=</span> mulf <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> <span class=k>f64</span>
      affine<span class=p>.</span>store <span class=nv>%5</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c>// Print the value held by the buffer.
</span><span class=c></span>  toy<span class=p>.</span>print <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  dealloc <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  dealloc <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><h2 id=taking-advantage-of-affine-optimization>Taking Advantage of Affine Optimization</h2><p>Our naive lowering is correct, but it leaves a lot to be desired with regards to
efficiency. For example, the lowering of <code>toy.mul</code> has generated some redundant
loads. Let&rsquo;s look at how adding a few existing optimizations to the pipeline can
help clean this up. Adding the <code>LoopFusion</code> and <code>MemRefDataFlowOpt</code> passes to
the pipeline gives the following result:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%cst</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>4.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
  <span class=nv>%cst_4</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>6.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>

  <span class=c>// Allocating buffers for the inputs and outputs.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>

  <span class=c>// Initialize the input buffer with the constant values.
</span><span class=c></span>  affine<span class=p>.</span>store <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_2</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_3</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  affine<span class=p>.</span>store <span class=nv>%cst_4</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>

  affine<span class=p>.</span>for <span class=nv>%arg0</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>3</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%arg1</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>2</span> <span class=p>{</span>
      <span class=c>// Load the transpose value from the input buffer.
</span><span class=c></span>      <span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%1</span><span class=p>[</span><span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>

      <span class=c>// Multiply and store into the output buffer.
</span><span class=c></span>      <span class=nv>%3</span> <span class=p>=</span> mulf <span class=nv>%2</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>f64</span>
      affine<span class=p>.</span>store <span class=nv>%3</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c>// Print the value held by the buffer.
</span><span class=c></span>  toy<span class=p>.</span>print <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  dealloc <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Here, we can see that a redundant allocation was removed, the two loop nests
were fused, and some unnecessary <code>load</code>s were removed. You can build <code>toyc-ch5</code>
and try yourself: <code>toyc-ch5 test/lowering.toy -emit=mlir-affine</code>. We can also
check our optimizations by adding <code>-opt</code>.</p><p>In this chapter we explored some aspects of partial lowering, with the intent to
optimize. In the
<a href=/docs/Tutorials/Toy/Ch-6/>next chapter</a>
we will continue the discussion about
dialect conversion by targeting LLVM for code generation.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Tutorials/Toy/Ch-4/ title="Chapter 4: Enabling Generic Transformation with Interfaces"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 4: Enabling Generic Transformation with Interfaces</a>
<a class="nav nav-next" href=/docs/Tutorials/Toy/Ch-6/ title="Chapter 6: Lowering to LLVM and CodeGeneration">Next - Chapter 6: Lowering to LLVM and CodeGeneration <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/OpenMPOps/>Dialect 'omp' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Tutorials/Toy/>Toy<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li class=active><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>