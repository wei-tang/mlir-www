<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Conversion to the LLVM Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/ConversionToLLVMDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Conversion to the LLVM Dialect</h1><p>Conversion from the Standard to the
<a href=/docs/Dialects/LLVM/>LLVM Dialect</a>
can be
performed by the specialized dialect conversion pass by running:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>mlir-opt -convert-std-to-llvm &lt;filename.mlir&gt;
</code></pre></div><p>It performs type and operation conversions for a subset of operations from
standard dialect (operations on scalars and vectors, control flow operations) as
described in this document. We use the terminology defined by the
<a href=/docs/Dialects/LLVM/>LLVM IR Dialect description</a>
throughout this document.</p><p><nav id=TableOfContents><ul><li><a href=#type-conversion>Type Conversion</a><ul><li><a href=#scalar-types>Scalar Types</a></li><li><a href=#index-type>Index Type</a></li><li><a href=#vector-types>Vector Types</a></li><li><a href=#memref-types>Memref Types</a></li><li><a href=#function-types>Function Types</a></li></ul></li><li><a href=#calling-convention>Calling Convention</a><ul><li><a href=#function-signature-conversion>Function Signature Conversion</a></li><li><a href=#result-packing>Result Packing</a></li><li><a href=#calling-convention-for-memref>Calling Convention for memref</a></li><li><a href=#c-compatible-wrapper-emission>C-compatible wrapper emission</a></li></ul></li><li><a href=#repeated-successor-removal>Repeated Successor Removal</a></li><li><a href=#default-memref-model>Default Memref Model</a><ul><li><a href=#memref-descriptor>Memref Descriptor</a></li><li><a href=#index-linearization>Index Linearization</a></li></ul></li></ul></nav><h2 id=type-conversion>Type Conversion</h2><h3 id=scalar-types>Scalar Types</h3><p>Scalar types are converted to their LLVM counterparts if they exist. The
following conversions are currently implemented:</p><ul><li><code>i*</code> converts to <code>!llvm.i*</code></li><li><code>f16</code> converts to <code>!llvm.half</code></li><li><code>f32</code> converts to <code>!llvm.float</code></li><li><code>f64</code> converts to <code>!llvm.double</code></li></ul><p>Note: <code>bf16</code> type is not supported by LLVM IR and cannot be converted.</p><h3 id=index-type>Index Type</h3><p>Index type is converted to a wrapped LLVM IR integer with bitwidth equal to the
bitwidth of the pointer size as specified by the
<a href=https://llvm.org/docs/LangRef.html#data-layout>data layout</a>
of the LLVM module
<a href=/docs/Dialects/LLVM/#context-and-module-association>contained</a>
in the LLVM Dialect
object. For example, on x86-64 CPUs it converts to <code>!llvm.i64</code>.</p><h3 id=vector-types>Vector Types</h3><p>LLVM IR only supports <em>one-dimensional</em> vectors, unlike MLIR where vectors can
be multi-dimensional. Vector types cannot be nested in either IR. In the
one-dimensional case, MLIR vectors are converted to LLVM IR vectors of the same
size with element type converted using these conversion rules. In the
n-dimensional case, MLIR vectors are converted to (n-1)-dimensional array types
of one-dimensional vectors.</p><p>For example, <code>vector&lt;4 x f32></code> converts to <code>!llvm&lt;"&lt;4 x float>"></code> and <code>vector&lt;4 x 8 x 16 x f32></code> converts to <code>!llvm&lt;"[4 x [8 x &lt;16 x float>]]"></code>.</p><h3 id=memref-types>Memref Types</h3><p>Memref types in MLIR have both static and dynamic information associated with
them. The dynamic information comprises the buffer pointer as well as sizes and
strides of any dynamically-sized dimensions. Memref types are normalized and
converted to a descriptor that is only dependent on the rank of the memref. The
descriptor contains:</p><ol><li>the pointer to the data buffer, followed by</li><li>the pointer to properly aligned data payload that the memref indexes,
followed by</li><li>a lowered <code>index</code>-type integer containing the distance between the beginning
of the buffer and the first element to be accessed through the memref,
followed by</li><li>an array containing as many <code>index</code>-type integers as the rank of the memref:
the array represents the size, in number of elements, of the memref along
the given dimension. For constant MemRef dimensions, the corresponding size
entry is a constant whose runtime value must match the static value,
followed by</li><li>a second array containing as many 64-bit integers as the rank of the MemRef:
the second array represents the &ldquo;stride&rdquo; (in tensor abstraction sense), i.e.
the number of consecutive elements of the underlying buffer.</li></ol><p>For constant memref dimensions, the corresponding size entry is a constant whose
runtime value matches the static value. This normalization serves as an ABI for
the memref type to interoperate with externally linked functions. In the
particular case of rank <code>0</code> memrefs, the size and stride arrays are omitted,
resulting in a struct containing two pointers + offset.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64 }&#34;</span><span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x42x42x43x123 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [5 x i64], [5 x i64] }&#34;</span><span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x?x42x?x123 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [5 x i64], [5 x i64]  }&#34;</span><span class=p>&gt;</span>

<span class=c>// Memref types can have vectors as element types
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x? x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ &lt;4 x float&gt;*, &lt;4 x float&gt;*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>If the rank of the memref is unknown at compile time, the memref is converted to
an unranked descriptor that contains:</p><ol><li>a 64-bit integer representing the dynamic rank of the memref, followed by</li><li>a pointer to a ranked memref descriptor with the contents listed above.</li></ol><p>Dynamic ranked memrefs should be used only to pass arguments to external library
calls that expect a unified memref type. The called functions can parse any
unranked memref descriptor by reading the rank and parsing the enclosed ranked
descriptor pointer.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// unranked descriptor
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i64, i8*}&#34;</span><span class=p>&gt;</span>
</code></pre></div><p><strong>In function signatures,</strong> <code>memref</code> is passed as a <em>pointer</em> to the structured
defined above to comply with the calling convention.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A function type with memref as argument
</span><span class=c></span><span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=c>// is transformed into the LLVM function with pointer-to-structure argument.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void({ float*, float*, i64, [1 x i64], [1 x i64]}*) &#34;</span><span class=p>&gt;</span>
</code></pre></div><h3 id=function-types>Function Types</h3><p>Function types get converted to LLVM function types. The arguments are converted
individually according to these rules. The result types need to accommodate the
fact that LLVM IR functions always have a return type, which may be a Void type.
The converted function always has a single result type. If the original function
type had no results, the converted function will have one result of the wrapped
<code>void</code> type. If the original function type had one result, the converted
function will also have one result converted using these rules. Otherwise, the result
type will be a wrapped LLVM IR structure type where each element of the
structure corresponds to one of the results of the original function, converted
using these rules. In high-order functions, function-typed arguments and results
are converted to a wrapped LLVM IR function pointer type (since LLVM IR does not
allow passing functions to functions without indirection) with the pointee type
converted using these rules.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// zero-ary function type with no results.
</span><span class=c></span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=c>// is converted to a zero-ary function with `void` result
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void ()&#34;</span><span class=p>&gt;</span>

<span class=c>// unary function with one result
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
<span class=c>// has its argument and result type converted, before creating the LLVM IR function type
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i64 (i32)&#34;</span><span class=p>&gt;</span>

<span class=c>// binary function with one result
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
<span class=c>// has its arguments handled separately
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i64 (i32, float)&#34;</span><span class=p>&gt;</span>

<span class=c>// binary function with two results
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>f64</span><span class=p>)</span>
<span class=c>// has its result aggregated into a structure type
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i64, double} (i32, f32)&#34;</span><span class=p>&gt;</span>

<span class=c>// function-typed arguments or results in higher-order functions
</span><span class=c></span><span class=p>(</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span><span class=p>)</span>
<span class=c>// are converted into pointers to functions
</span><span class=c></span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void ()* (void ()*)&#34;</span><span class=p>&gt;</span>
</code></pre></div><h2 id=calling-convention>Calling Convention</h2><h3 id=function-signature-conversion>Function Signature Conversion</h3><p>LLVM IR functions are defined by a custom operation. The function itself has a
wrapped LLVM IR function type converted as described above. The function
definition operation uses MLIR syntax.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// zero-ary function type with no results.
</span><span class=c></span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=c>// gets LLVM type void().
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>

<span class=c>// function with one result
</span><span class=c></span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
<span class=c>// gets converted to LLVM type i64(i32).
</span><span class=c></span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=c>// function with two results
</span><span class=c></span><span class=kt>func</span> <span class=nf>@qux</span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>f64</span><span class=p>)</span>
<span class=c>// has its result aggregated into a structure type
</span><span class=c></span><span class=kt>func</span> <span class=nf>@qux</span><span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i64, double}&#34;</span><span class=p>&gt;</span>

<span class=c>// function-typed arguments or results in higher-order functions
</span><span class=c></span><span class=kt>func</span> <span class=nf>@quux</span><span class=p>(</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span><span class=p>)</span>
<span class=c>// are converted into pointers to functions
</span><span class=c></span><span class=kt>func</span> <span class=nf>@quux</span><span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void ()*&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void ()*&#34;</span><span class=p>&gt;</span>
<span class=c>// the call flow is handled by the LLVM dialect `call` operation supporting both
</span><span class=c></span><span class=c>// direct and indirect calls
</span></code></pre></div><h3 id=result-packing>Result Packing</h3><p>In case of multi-result functions, the returned values are inserted into a
structure-typed value before being returned and extracted from it at the call
site. This transformation is a part of the conversion and is transparent to the
defines and uses of the values being returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>return</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i64</span>
<span class=p>}</span>
<span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
  <span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>17</span> <span class=p>:</span> <span class=k>i64</span>
  <span class=nv>%2</span><span class=p>:</span><span class=nl>2 =</span> call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span>
  <span class=s>&#34;use_i32&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=nv>#0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=s>&#34;use_i64&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=nv>#1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=c>// is transformed into
</span><span class=c></span>
<span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=c>// insert the vales into a structure
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span>  <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>

  <span class=c>// return the structure value
</span><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>
<span class=p>}</span>
<span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>17</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

  <span class=c>// call and extract the values from the structure
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%2</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%2</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, i64}&#34;</span><span class=p>&gt;</span>

  <span class=c>// use as before
</span><span class=c></span>  <span class=s>&#34;use_i32&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=s>&#34;use_i64&#34;</span><span class=p>(</span><span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h3 id=calling-convention-for-memref>Calling Convention for <code>memref</code></h3><p>Function <em>arguments</em> of <code>memref</code> type, ranked or unranked, are <em>expanded</em> into a
list of arguments of non-aggregate types that the memref descriptor defined
above comprises. That is, the outer struct type and the inner array types are
replaced with individual arguments.</p><p>This convention is implemented in the conversion of <code>std.func</code> and <code>std.call</code> to
the LLVM dialect, with the former unpacking the descriptor into a set of
individual values and the latter packing those values back into a descriptor so
as to make it transparently usable by other operations. Conversions from other
dialects should take this convention into account.</p><p>This specific convention is motivated by the necessity to specify alignment and
aliasing attributes on the raw pointers underpinning the memref.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Gets converted to the following.
</span><span class=c></span>
llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span>   <span class=c>// Allocated pointer.
</span><span class=c></span>               <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span>   <span class=c>// Aligned pointer.
</span><span class=c></span>               <span class=nv>%arg2</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>         <span class=c>// Offset.
</span><span class=c></span>               <span class=nv>%arg3</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>         <span class=c>// Size in dim 0.
</span><span class=c></span>               <span class=nv>%arg4</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>{</span>       <span class=c>// Stride in dim 0.
</span><span class=c></span>  <span class=c>// Populate memref descriptor structure.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg3</span><span class=p>,</span> <span class=nv>%3</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%5</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%4</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>

  <span class=c>// Descriptor is now usable as a single value.
</span><span class=c></span>  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;get&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
  call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Gets converted to the following.
</span><span class=c></span>
llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;get&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>

  <span class=c>// Unpack the memref descriptor.
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%5</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [1 x i64], [1 x i64] }&#34;</span><span class=p>&gt;</span>

  <span class=c>// Pass individual values to the callee.
</span><span class=c></span>  llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

</code></pre></div><p>For <strong>unranked</strong> memrefs, the list of function arguments always contains two
elements, same as the unranked memref descriptor: an integer rank, and a
type-erased (<code>!llvm&lt;"i8*"></code>) pointer to the ranked memref descriptor. Note that
while the <em>calling convention</em> does not require stack allocation, <em>casting</em> to
unranked memref does since one cannot take an address of an SSA value containing
the ranked memref. The caller is in charge of ensuring the thread safety and
eventually removing unnecessary stack allocations in cast operations.</p><p>Example</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Gets converted to the following.
</span><span class=c></span>
llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>       <span class=c>// Rank.
</span><span class=c></span>               <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=c>// Type-erased pointer to descriptor.
</span><span class=c></span>  <span class=c>// Pack the unranked memref descriptor.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span>

  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;get&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span>
  call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span><span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Gets converted to the following.
</span><span class=c></span>
llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;get&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span><span class=p>)</span>

  <span class=c>// Unpack the memref descriptor.
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ i64, i8* }&#34;</span><span class=p>&gt;</span>

  <span class=c>// Pass individual values to the callee.
</span><span class=c></span>  llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span><span class=p>)</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p><em>This convention may or may not apply if the conversion of MemRef types is
overridden by the user.</em></p><h3 id=c-compatible-wrapper-emission>C-compatible wrapper emission</h3><p>In practical cases, it may be desirable to have externally-facing functions with
a single attribute corresponding to a MemRef argument. When interfacing with
LLVM IR produced from C, the code needs to respect the corresponding calling
convention. The conversion to the LLVM dialect provides an option to generate
wrapper functions that take memref descriptors as pointers-to-struct compatible
with data types produced by Clang when compiling C sources. The generation of
such wrapper functions can additionally be controlled at a function granularity
by setting the <code>llvm.emit_c_interface</code> unit attribute.</p><p>More specifically, a memref argument is converted into a pointer-to-struct
argument of type <code>{T*, T*, i64, i64[N], i64[N]}*</code> in the wrapper function, where
<code>T</code> is the converted element type and <code>N</code> is the memref rank. This type is
compatible with that produced by Clang for the following C++ structure template
instantiations or their equivalents in C.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>N</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=nc>MemRefDescriptor</span> <span class=p>{</span>
  <span class=n>T</span> <span class=o>*</span><span class=n>allocated</span><span class=p>;</span>
  <span class=n>T</span> <span class=o>*</span><span class=n>aligned</span><span class=p>;</span>
  <span class=n>intptr_t</span> <span class=n>offset</span><span class=p>;</span>
  <span class=n>intptr_t</span> <span class=n>sizes</span><span class=p>[</span><span class=n>N</span><span class=p>]</span><span class=p>;</span>
  <span class=n>intptr_t</span> <span class=n>strides</span><span class=p>[</span><span class=n>N</span><span class=p>]</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>If enabled, the option will do the following. For <em>external</em> functions declared
in the MLIR module.</p><ol><li>Declare a new function <code>_mlir_ciface_&lt;original name></code> where memref arguments
are converted to pointer-to-struct and the remaining arguments are converted
as usual.</li><li>Add a body to the original function (making it non-external) that<ol><li>allocates a memref descriptor,</li><li>populates it, and</li><li>passes the pointer to it into the newly declared interface function, then</li><li>collects the result of the call and returns it to the caller.</li></ol></li></ol><p>For (non-external) functions defined in the MLIR module.</p><ol><li>Define a new function <code>_mlir_ciface_&lt;original name></code> where memref arguments
are converted to pointer-to-struct and the remaining arguments are converted
as usual.</li><li>Populate the body of the newly defined function with IR that<ol><li>loads descriptors from pointers;</li><li>unpacks descriptor into individual non-aggregate values;</li><li>passes these values into the original function;</li><li>collects the result of the call and returns it to the caller.</li></ol></li></ol><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>
<span class=kt>func</span> <span class=nf>@qux</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>

<span class=c>// Gets converted into the following.
</span><span class=c></span>
<span class=c>// Function with unpacked arguments.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@qux</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>
               <span class=nv>%arg3</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=nv>%arg4</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=nv>%arg5</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>
               <span class=nv>%arg6</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Populate memref descriptor (as per calling convention).
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%2</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg3</span><span class=p>,</span> <span class=nv>%3</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%5</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg5</span><span class=p>,</span> <span class=nv>%4</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%6</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%5</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%7</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%arg6</span><span class=p>,</span> <span class=nv>%6</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>

  <span class=c>// Store the descriptor in a stack-allocated space.
</span><span class=c></span>  <span class=nv>%8</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
  <span class=nv>%9</span> <span class=p>=</span> llvm<span class=p>.</span>alloca <span class=nv>%8</span> <span class=p>x</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
                 <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span>
  llvm<span class=p>.</span>store <span class=nv>%7</span><span class=p>,</span> <span class=nv>%9</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span>

  <span class=c>// Call the interface function.
</span><span class=c></span>  llvm<span class=p>.</span>call <span class=nf>@_mlir_ciface_qux</span><span class=p>(</span><span class=nv>%9</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>

  <span class=c>// The stored descriptor will be freed on return.
</span><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Interface function.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@_mlir_ciface_qux</span><span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Gets converted into the following.
</span><span class=c></span>
<span class=c>// Function with unpacked arguments.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>
               <span class=nv>%arg3</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=nv>%arg4</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=nv>%arg5</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>
               <span class=nv>%arg6</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Interface function callable from C.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@_mlir_ciface_foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Load the descriptor.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }*&#34;</span><span class=p>&gt;</span>

  <span class=c>// Unpack the descriptor as per calling convention.
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%5</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%6</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  <span class=nv>%7</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%0</span><span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ float*, float*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
  llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%5</span><span class=p>,</span> <span class=nv>%6</span><span class=p>,</span> <span class=nv>%7</span><span class=p>)</span>
    <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span>
       <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Rationale: Introducing auxiliary functions for C-compatible interfaces is
preferred to modifying the calling convention since it will minimize the effect
of C compatibility on intra-module calls or calls between MLIR-generated
functions. In particular, when calling external functions from an MLIR module in
a (parallel) loop, the fact of storing a memref descriptor on stack can lead to
stack exhaustion and/or concurrent access to the same address. Auxiliary
interface function serves as an allocation scope in this case. Furthermore, when
targeting accelerators with separate memory spaces such as GPUs, stack-allocated
descriptors passed by pointer would have to be transferred to the device memory,
which introduces significant overhead. In such situations, auxiliary interface
functions are executed on host and only pass the values through device function
invocation mechanism.</p><h2 id=repeated-successor-removal>Repeated Successor Removal</h2><p>Since the goal of the LLVM IR dialect is to reflect LLVM IR in MLIR, the dialect
and the conversion procedure must account for the differences between block
arguments and LLVM IR PHI nodes. In particular, LLVM IR disallows PHI nodes with
different values coming from the same source. Therefore, the LLVM IR dialect
disallows operations that have identical successors accepting arguments, which
would lead to invalid PHI nodes. The conversion process resolves the potential
PHI source ambiguity by injecting dummy blocks if the same block is used more
than once as a successor in an instruction. These dummy blocks branch
unconditionally to the original successors, pass them the original operands
(available in the dummy block because it is dominated by the original block) and
are used instead of them in the original terminator operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  cond_br <span class=nv>%0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
</code></pre></div><p>leads to a new basic block being inserted,</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  cond_br <span class=nv>%0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^dummy
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=nl>^dummy</span><span class=p>:</span>
  br <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%4</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</code></pre></div><p>before the conversion to the LLVM IR dialect:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  llvm<span class=p>.</span>cond_br  <span class=nv>%0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^dummy
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32&#34;</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;use&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=nl>^dummy</span><span class=p>:</span>
  llvm<span class=p>.</span>br <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span>
</code></pre></div><h2 id=default-memref-model>Default Memref Model</h2><h3 id=memref-descriptor>Memref Descriptor</h3><p>Within a converted function, a <code>memref</code>-typed value is represented by a memref
<em>descriptor</em>, the type of which is the structure type obtained by converting
from the memref type. This descriptor holds all the necessary information to
produce an address of a specific element. In particular, it holds dynamic values
for static sizes, and they are expected to match at all times.</p><p>It is created by the allocation operation and is updated by the conversion
operations that may change static dimensions into dynamic dimensions and vice versa.</p><p><strong>Note</strong>: LLVM IR conversion does not support <code>memref</code>s with layouts that are
not amenable to the strided form.</p><h3 id=index-linearization>Index Linearization</h3><p>Accesses to a memref element are transformed into an access to an element of the
buffer pointed to by the descriptor. The position of the element in the buffer
is calculated by linearizing memref indices in row-major order (lexically first
index is the slowest varying, similar to C, but accounting for strides). The
computation of the linear address is emitted as arithmetic operation in the LLVM
IR dialect. Strides are extracted from the memref descriptor.</p><p>Accesses to zero-dimensional memref (that are interpreted as pointers to the
elemental type) are directly converted into <code>llvm.load</code> or <code>llvm.store</code> without
any pointer manipulations.</p><p>Examples:</p><p>An access to a zero-dimensional memref is converted into a plain load:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// before
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> load <span class=nv>%m</span><span class=p>[</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// after
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%m</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>An access to a memref with indices:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> load <span class=nv>%m</span><span class=p>[</span><span class=m>1</span><span class=p>,</span><span class=m>2</span><span class=p>,</span><span class=m>3</span><span class=p>,</span><span class=m>4</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x?x13x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>is transformed into the equivalent of the following code:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Compute the linearized index from strides. Each block below extracts one
</span><span class=c></span><span class=c>// stride from the descriptor, multiplies it with the index and accumulates
</span><span class=c></span><span class=c>// the total offset.
</span><span class=c></span><span class=nv>%stride1</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>
<span class=nv>%idx1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr1</span> <span class=p>=</span> muli <span class=nv>%stride1</span><span class=p>,</span> <span class=nv>%idx1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=nv>%stride2</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>
<span class=nv>%idx2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr2</span> <span class=p>=</span> muli <span class=nv>%stride2</span><span class=p>,</span> <span class=nv>%idx2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr3</span> <span class=p>=</span> addi <span class=nv>%addr1</span><span class=p>,</span> <span class=nv>%addr2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=nv>%stride3</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>
<span class=nv>%idx3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>3</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr4</span> <span class=p>=</span> muli <span class=nv>%stride3</span><span class=p>,</span> <span class=nv>%idx3</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr5</span> <span class=p>=</span> addi <span class=nv>%addr3</span><span class=p>,</span> <span class=nv>%addr4</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=nv>%stride4</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>3</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>
<span class=nv>%idx4</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>4</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr6</span> <span class=p>=</span> muli <span class=nv>%stride4</span><span class=p>,</span> <span class=nv>%idx4</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%addr7</span> <span class=p>=</span> addi <span class=nv>%addr5</span><span class=p>,</span> <span class=nv>%addr6</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=c>// Add the linear offset to the address.
</span><span class=c></span><span class=nv>%offset</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>
<span class=nv>%addr8</span> <span class=p>=</span> addi <span class=nv>%addr7</span><span class=p>,</span> <span class=nv>%offset</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=c>// Obtain the aligned pointer.
</span><span class=c></span><span class=nv>%aligned</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue<span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span>

<span class=c>// Get the address of the data pointer.
</span><span class=c></span><span class=nv>%ptr</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%aligned</span><span class=p>[</span><span class=nv>%addr8</span><span class=p>]</span>
    <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{float*, float*, i64, i64[4], i64[4]}&#34;</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>

<span class=c>// Perform the actual load.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%ptr</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>For stores, the address computation code is identical and only the actual store
operation is different.</p><p>Note: the conversion does not perform any sort of common subexpression
elimination when emitting memref accesses.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/EDSC/ title="Background: declarative builders API"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Background: declarative builders API</a>
<a class="nav nav-next" href=/docs/CreatingADialect/ title="Creating a Dialect">Next - Creating a Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li class=active><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>