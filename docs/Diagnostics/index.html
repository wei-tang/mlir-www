<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.62.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Diagnostics/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</h1><p>[TOC]</p><p>This document presents an introduction to using and interfacing with MLIR's
diagnostics infrastructure.</p><p>See
<a href=/docs/LangRef/>MLIR specification</a>
for more information about MLIR, the
structure of the IR, operations, etc.</p><h2 id=source-locations>Source Locations</h2><p>Source location information is extremely important for any compiler, because it
provides a baseline for debuggability and error-reporting. MLIR provides several
different location types depending on the situational need.</p><h3 id=callsite-location>CallSite Location</h3><pre><code>callsite-location ::= 'callsite' '(' location 'at' location ')'
</code></pre><p>An instance of this location allows for representing a directed stack of
location usages. This connects a location of a <code>callee</code> with the location of a
<code>caller</code>.</p><h3 id=filelinecol-location>FileLineCol Location</h3><pre><code>filelinecol-location ::= string-literal ':' integer-literal ':' integer-literal
</code></pre><p>An instance of this location represents a tuple of file, line number, and column
number. This is similar to the type of location that you get from most source
languages.</p><h3 id=fused-location>Fused Location</h3><pre><code>fused-location ::= `fused` fusion-metadata? '[' location (location ',')* ']'
fusion-metadata ::= '&lt;' attribute-value '&gt;'
</code></pre><p>An instance of a <code>fused</code> location represents a grouping of several other source
locations, with optional metadata that describes the context of the fusion.
There are many places within a compiler in which several constructs may be fused
together, e.g. pattern rewriting, that normally result partial or even total
loss of location information. With <code>fused</code> locations, this is a non-issue.</p><h3 id=name-location>Name Location</h3><pre><code>name-location ::= string-literal ('(' location ')')?
</code></pre><p>An instance of this location allows for attaching a name to a child location.
This can be useful for representing the locations of variable, or node,
definitions.</p><h3 id=opaque-location>Opaque Location</h3><p>An instance of this location essentially contains a pointer to some data
structure that is external to MLIR and an optional location that can be used if
the first one is not suitable. Since it contains an external structure, only the
optional location is used during serialization.</p><h3 id=unknown-location>Unknown Location</h3><pre><code>unknown-location ::= `unknown`
</code></pre><p>Source location information is an extremely integral part of the MLIR
infrastructure. As such, location information is always present in the IR, and
must explicitly be set to unknown. Thus an instance of the <code>unknown</code> location,
represents an unspecified source location.</p><h2 id=diagnostic-engine>Diagnostic Engine</h2><p>The <code>DiagnosticEngine</code> acts as the main interface for diagnostics in MLIR. It
manages the registration of diagnostic handlers, as well as the core API for
diagnostic emission. Handlers generally take the form of
<code>LogicalResult(Diagnostic &)</code>. If the result is <code>success</code>, it signals that the
diagnostic has been fully processed and consumed. If <code>failure</code>, it signals that
the diagnostic should be propagated to any previously registered handlers. It
can be interfaced with via an <code>MLIRContext</code> instance.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>DiagnosticEngine</span> <span class=n>engine</span> <span class=o>=</span> <span class=n>ctx</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getDiagEngine</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

<span class=c1>/// Handle the reported diagnostic.
</span><span class=c1></span><span class=c1>// Return success to signal that the diagnostic has either been fully processed,
</span><span class=c1></span><span class=c1>// or failure if the diagnostic should be propagated to the previous handlers.
</span><span class=c1></span><span class=n>DiagnosticEngine</span><span class=o>:</span><span class=o>:</span><span class=n>HandlerID</span> <span class=n>id</span> <span class=o>=</span> <span class=n>engine</span><span class=p>.</span><span class=n>registerHandler</span><span class=p>(</span>
    <span class=p>[</span><span class=p>]</span><span class=p>(</span><span class=n>Diagnostic</span> <span class=o>&amp;</span><span class=n>diag</span><span class=p>)</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>LogicalResult</span> <span class=p>{</span>
  <span class=kt>bool</span> <span class=n>should_propage_diagnostic</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
  <span class=k>return</span> <span class=nf>failure</span><span class=p>(</span><span class=n>should_propage_diagnostic</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span><span class=p>)</span><span class=p>;</span>


<span class=c1>// We can also elide the return value completely, in which the engine assumes
</span><span class=c1></span><span class=c1>// that all diagnostics are consumed(i.e. a success() result).
</span><span class=c1></span><span class=n>DiagnosticEngine</span><span class=o>:</span><span class=o>:</span><span class=n>HandlerID</span> <span class=n>id</span> <span class=o>=</span> <span class=n>engine</span><span class=p>.</span><span class=n>registerHandler</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>(</span><span class=n>Diagnostic</span> <span class=o>&amp;</span><span class=n>diag</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span><span class=p>;</span>
<span class=p>}</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Unregister this handler when we are done.
</span><span class=c1></span><span class=n>engine</span><span class=p>.</span><span class=n>eraseHandler</span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h3 id=constructing-a-diagnostic>Constructing a Diagnostic</h3><p>As stated above, the <code>DiagnosticEngine</code> holds the core API for diagnostic
emission. A new diagnostic can be emitted with the engine via <code>emit</code>. This
method returns an
<a href=#inflight-diagnostic>InFlightDiagnostic</a>
that can be
modified further.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>InFlightDiagnostic</span> <span class=nf>emit</span><span class=p>(</span><span class=n>Location</span> <span class=n>loc</span><span class=p>,</span> <span class=n>DiagnosticSeverity</span> <span class=n>severity</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><p>Using the <code>DiagnosticEngine</code>, though, is generally not the preferred way to emit
diagnostics in MLIR.
<a href=/docs/LangRef/#operations><code>operation</code></a>
provides utility
methods for emitting diagnostics:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// `emit` methods available in the mlir namespace.
</span><span class=c1></span><span class=n>InFlightDiagnostic</span> <span class=n>emitError</span><span class=o>/</span><span class=n>Remark</span><span class=o>/</span><span class=n>Warning</span><span class=p>(</span><span class=n>Location</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// These methods use the location attached to the operation.
</span><span class=c1></span><span class=n>InFlightDiagnostic</span> <span class=n>Operation</span><span class=o>:</span><span class=o>:</span><span class=n>emitError</span><span class=o>/</span><span class=n>Remark</span><span class=o>/</span><span class=n>Warning</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// This method creates a diagnostic prefixed with &#34;&#39;op-name&#39; op &#34;.
</span><span class=c1></span><span class=n>InFlightDiagnostic</span> <span class=n>Operation</span><span class=o>:</span><span class=o>:</span><span class=n>emitOpError</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h2 id=diagnostic>Diagnostic</h2><p>A <code>Diagnostic</code> in MLIR contains all of the necessary information for reporting a
message to the user. A <code>Diagnostic</code> essentially boils down to three main
components:</p><ul><li><a href=#source-locations>Source Location</a></li><li>Severity Level<ul><li>Error, Note, Remark, Warning</li></ul></li><li>Diagnostic Arguments<ul><li>The diagnostic arguments are used when constructing the output message.</li></ul></li></ul><h3 id=appending-arguments>Appending arguments</h3><p>One a diagnostic has been constructed, the user can start composing it. The
output message of a diagnostic is composed of a set of diagnostic arguments that
have been attached to it. New arguments can be attached to a diagnostic in a few
different ways:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// A few interesting things to use when composing a diagnostic.
</span><span class=c1></span><span class=n>Attribute</span> <span class=n>fooAttr</span><span class=p>;</span>
<span class=n>Type</span> <span class=n>fooType</span><span class=p>;</span>
<span class=n>SmallVector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>fooInts</span><span class=p>;</span>

<span class=c1>// Diagnostics can be composed via the streaming operators.
</span><span class=c1></span><span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>emitError</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Compose an interesting error: </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>fooAttr</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>, </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>fooType</span>
                <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>, (</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>fooInts</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=sc>&#39;</span><span class=sc>)</span><span class=sc>&#39;</span><span class=p>;</span>

<span class=c1>// This could generate something like (FuncAttr:@foo, IntegerType:i32, {0,1,2}):
</span><span class=c1></span><span class=sa></span><span class=s>&#34;</span><span class=s>Compose an interesting error: @foo, i32, (0, 1, 2)</span><span class=s>&#34;</span>
</code></pre></div><h3 id=attaching-notes>Attaching notes</h3><p>Unlike many other compiler frameworks, notes in MLIR cannot be emitted directly.
They must be explicitly attached to another diagnostic non-note diagnostic. When
emitting a diagnostic, notes can be directly attached via <code>attachNote</code>. When
attaching a note, if the user does not provide an explicit source location the
note will inherit the location of the parent diagnostic.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Emit a note with an explicit source location.
</span><span class=c1></span><span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>emitError</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>...</span><span class=s>&#34;</span><span class=p>)</span><span class=p>.</span><span class=n>attachNote</span><span class=p>(</span><span class=n>noteLoc</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>...</span><span class=s>&#34;</span><span class=p>;</span>

<span class=c1>// Emit a note that inherits the parent location.
</span><span class=c1></span><span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>emitError</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>...</span><span class=s>&#34;</span><span class=p>)</span><span class=p>.</span><span class=n>attachNote</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>...</span><span class=s>&#34;</span><span class=p>;</span>
</code></pre></div><h2 id=inflight-diagnostic>InFlight Diagnostic</h2><p>Now that
<a href=#diagnostic>Diagnostics</a>
have been explained, we introduce the
<code>InFlightDiagnostic</code>, an RAII wrapper around a diagnostic that is set to be
reported. This allows for modifying a diagnostic while it is still in flight. If
it is not reported directly by the user it will automatically report when
destroyed.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=p>{</span>
  <span class=n>InFlightDiagnostic</span> <span class=n>diag</span> <span class=o>=</span> <span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>emitError</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>...</span><span class=s>&#34;</span><span class=p>;</span>
<span class=p>}</span>  <span class=c1>// The diagnostic is automatically reported here.
</span></code></pre></div><h2 id=diagnostic-configuration-options>Diagnostic Configuration Options</h2><p>Several options are provided to help control and enhance the behavior of
diagnostics. These options are listed below:</p><h3 id=print-operation-on-diagnostic>Print Operation On Diagnostic</h3><p>Command Line Flag: <code>-mlir-print-op-on-diagnostic</code></p><p>When a diagnostic is emitted on an operation, via <code>Operation::emitError/...</code>,
the textual form of that operation is printed and attached as a note to the
diagnostic. This option is useful for understanding the current form of an
operation that may be invalid, especially when debugging verifier failures. An
example output is shown below:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>test.mlir:3:3: error: <span class=s1>&#39;module_terminator&#39;</span> op expects parent op <span class=s1>&#39;module&#39;</span>
  <span class=s2>&#34;module_terminator&#34;</span><span class=o>(</span><span class=o>)</span> : <span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span><span class=o>)</span>
  ^
test.mlir:3:3: note: see current operation: <span class=s2>&#34;module_terminator&#34;</span><span class=o>(</span><span class=o>)</span> : <span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span><span class=o>)</span>
  <span class=s2>&#34;module_terminator&#34;</span><span class=o>(</span><span class=o>)</span> : <span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span><span class=o>)</span>
  ^
</code></pre></div><h3 id=print-stacktrace-on-diagnostic>Print StackTrace On Diagnostic</h3><p>Command Line Flag: <code>-mlir-print-stacktrace-on-diagnostic</code></p><p>When a diagnostic is emitted, attach the current stack trace as a note to the
diagnostic. This option is useful for understanding which part of the compiler
generated certain diagnostics. An example output is shown below:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>test.mlir:3:3: error: <span class=s1>&#39;module_terminator&#39;</span> op expects parent op <span class=s1>&#39;module&#39;</span>
  <span class=s2>&#34;module_terminator&#34;</span><span class=o>(</span><span class=o>)</span> : <span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span><span class=o>)</span>
  ^
test.mlir:3:3: note: diagnostic emitted with trace:
 <span class=c1>#0 0x000055dd40543805 llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) llvm/lib/Support/Unix/Signals.inc:553:11</span>
 <span class=c1>#1 0x000055dd3f8ac162 emitDiag(mlir::Location, mlir::DiagnosticSeverity, llvm::Twine const&amp;) /lib/IR/Diagnostics.cpp:292:7</span>
 <span class=c1>#2 0x000055dd3f8abe8e mlir::emitError(mlir::Location, llvm::Twine const&amp;) /lib/IR/Diagnostics.cpp:304:10</span>
 <span class=c1>#3 0x000055dd3f998e87 mlir::Operation::emitError(llvm::Twine const&amp;) /lib/IR/Operation.cpp:324:29</span>
 <span class=c1>#4 0x000055dd3f99d21c mlir::Operation::emitOpError(llvm::Twine const&amp;) /lib/IR/Operation.cpp:652:10</span>
 <span class=c1>#5 0x000055dd3f96b01c mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl&lt;mlir::ModuleTerminatorOp&gt;::verifyTrait(mlir::Operation*) /mlir/IR/OpDefinition.h:897:18</span>
 <span class=c1>#6 0x000055dd3f96ab38 mlir::Op&lt;mlir::ModuleTerminatorOp, mlir::OpTrait::ZeroOperands, mlir::OpTrait::ZeroResult, mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl, mlir::OpTrait::IsTerminator&gt;::BaseVerifier&lt;mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl&lt;mlir::ModuleTerminatorOp&gt;, mlir::OpTrait::IsTerminator&lt;mlir::ModuleTerminatorOp&gt; &gt;::verifyTrait(mlir::Operation*) /mlir/IR/OpDefinition.h:1052:29</span>
 <span class=c1>#  ...</span>
  <span class=s2>&#34;module_terminator&#34;</span><span class=o>(</span><span class=o>)</span> : <span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span><span class=o>)</span>
  ^
</code></pre></div><h2 id=common-diagnostic-handlers>Common Diagnostic Handlers</h2><p>To interface with the diagnostics infrastructure, users will need to register a
diagnostic handler with the
<a href=#diagnostic-engine><code>DiagnosticEngine</code></a>
.
Recognizing the many users will want the same handler functionality, MLIR
provides several common diagnostic handlers for immediate use.</p><h3 id=scoped-diagnostic-handler>Scoped Diagnostic Handler</h3><p>This diagnostic handler is a simple RAII class that registers and unregisters a
given diagnostic handler. This class can be either be used directly, or in
conjunction with a derived diagnostic handler.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Construct the handler directly.
</span><span class=c1></span><span class=n>MLIRContext</span> <span class=n>context</span><span class=p>;</span>
<span class=n>ScopedDiagnosticHandler</span> <span class=nf>scopedHandler</span><span class=p>(</span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span> <span class=p>[</span><span class=p>]</span><span class=p>(</span><span class=n>Diagnostic</span> <span class=o>&amp;</span><span class=n>diag</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Use this handler in conjunction with another.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyDerivedHandler</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ScopedDiagnosticHandler</span> <span class=p>{</span>
  <span class=n>MyDerivedHandler</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=o>:</span> <span class=n>ScopedDiagnosticHandler</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Set the handler that should be RAII managed.
</span><span class=c1></span>    <span class=n>setHandler</span><span class=p>(</span><span class=p>[</span><span class=o>&amp;</span><span class=p>]</span><span class=p>(</span><span class=n>Diagnostic</span> <span class=n>diag</span><span class=p>)</span> <span class=p>{</span>
      <span class=p>.</span><span class=p>.</span><span class=p>.</span>
    <span class=p>}</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><h3 id=sourcemgr-diagnostic-handler>SourceMgr Diagnostic Handler</h3><p>This diagnostic handler is a wrapper around an llvm::SourceMgr instance. It
provides support for displaying diagnostic messages inline with a line of a
respective source file. This handler will also automatically load newly seen
source files into the SourceMgr when attempting to display the source line of a
diagnostic. Example usage of this handler can be seen in the <code>mlir-opt</code> tool.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir

/tmp/test.mlir:6:24: error: expected non-function <span class=nb>type</span>
func @foo<span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span>index, ind<span class=o>)</span> <span class=o>{</span>
                       ^
</code></pre></div><p>To use this handler in your tool, add the following:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>SourceMgr</span> <span class=n>sourceMgr</span><span class=p>;</span>
<span class=n>MLIRContext</span> <span class=n>context</span><span class=p>;</span>
<span class=n>SourceMgrDiagnosticHandler</span> <span class=nf>sourceMgrHandler</span><span class=p>(</span><span class=n>sourceMgr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>context</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h3 id=sourcemgr-diagnostic-verifier-handler>SourceMgr Diagnostic Verifier Handler</h3><p>This handler is a wrapper around a llvm::SourceMgr that is used to verify that
certain diagnostics have been emitted to the context. To use this handler,
annotate your source file with expected diagnostics in the form of:</p><ul><li><code>expected-(error|note|remark|warning) {{ message }}</code></li></ul><p>A few examples are shown below:</p><pre><code class=language-mlir data-lang=mlir>// Expect an error on the same line.
func @bad_branch() {
  br ^missing  // expected-error {{reference to an undefined block}}
}

// Expect an error on an adjacent line.
func @foo(%a : f32) {
  // expected-error@+1 {{unknown comparison predicate &quot;foo&quot;}}
  %result = cmpf &quot;foo&quot;, %a, %a : f32
  return
}

// Expect an error on the next line that does not contain a designator.
// expected-remark@below {{remark on function below}}
// expected-remark@below {{another remark on function below}}
func @bar(%a : f32)

// Expect an error on the previous line that does not contain a designator.
func @baz(%a : f32)
// expected-remark@above {{remark on function above}}
// expected-remark@above {{another remark on function above}}

</code></pre><p>The handler will report an error if any unexpected diagnostics were seen, or if
any expected diagnostics weren't.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir

/tmp/test.mlir:6:24: error: unexpected error: expected non-function <span class=nb>type</span>
func @foo<span class=o>(</span><span class=o>)</span> -&gt; <span class=o>(</span>index, ind<span class=o>)</span> <span class=o>{</span>
                       ^

/tmp/test.mlir:15:4: error: expected remark <span class=s2>&#34;expected some remark&#34;</span> was not produced
// expected-remark <span class=o>{</span><span class=o>{</span>expected some remark<span class=o>}</span><span class=o>}</span>
   ^~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre></div><p>Similarly to the
<a href=#sourcemgr-diagnostic-handler>SourceMgr Diagnostic Handler</a>
,
this handler can be added to any tool via the following:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>SourceMgr</span> <span class=n>sourceMgr</span><span class=p>;</span>
<span class=n>MLIRContext</span> <span class=n>context</span><span class=p>;</span>
<span class=n>SourceMgrDiagnosticVerifierHandler</span> <span class=nf>sourceMgrHandler</span><span class=p>(</span><span class=n>sourceMgr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>context</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h3 id=parallel-diagnostic-handler>Parallel Diagnostic Handler</h3><p>MLIR is designed from the ground up to be multi-threaded. One important to thing
to keep in mind when multi-threading is determinism. This means that the
behavior seen when operating on multiple threads is the same as when operating
on a single thread. For diagnostics, this means that the ordering of the
diagnostics is the same regardless of the amount of threads being operated on.
The ParallelDiagnosticHandler is introduced to solve this problem.</p><p>After creating a handler of this type, the only remaining step is to ensure that
each thread that will be emitting diagnostics to the handler sets a respective
&lsquo;orderID&rsquo;. The orderID corresponds to the order in which diagnostics would be
emitted when executing synchronously. For example, if we were processing a list
of operations [a, b, c] on a single-thread. Diagnostics emitted while processing
operation &lsquo;a&rsquo; would be emitted before those for &lsquo;b&rsquo; or &lsquo;c&rsquo;. This corresponds 1-1
with the &lsquo;orderID&rsquo;. The thread that is processing &lsquo;a&rsquo; should set the orderID to
&lsquo;0&rsquo;; the thread processing &lsquo;b&rsquo; should set it to &lsquo;1&rsquo;; and so on and so forth.
This provides a way for the handler to deterministically order the diagnostics
that it receives given the thread that it is receiving on.</p><p>A simple example is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=n>ParallelDiagnosticHandler</span> <span class=nf>handler</span><span class=p>(</span><span class=n>context</span><span class=p>)</span><span class=p>;</span>

<span class=c1>// Process a list of operations in parallel.
</span><span class=c1></span><span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Operation</span> <span class=o>*</span><span class=o>&gt;</span> <span class=n>opsToProcess</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>for_each_n</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>parallel</span><span class=o>:</span><span class=o>:</span><span class=n>par</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>opsToProcess</span><span class=p>.</span><span class=n>size</span><span class=p>(</span><span class=p>)</span><span class=p>,</span>
                 <span class=p>[</span><span class=o>&amp;</span><span class=p>]</span><span class=p>(</span><span class=n>size_t</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Notify the handler that we are processing the i&#39;th operation.
</span><span class=c1></span>  <span class=n>handler</span><span class=p>.</span><span class=n>setOrderIDForThread</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=p>;</span>
  <span class=k>auto</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=n>opsToProcess</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=p>;</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>

  <span class=c1>// Notify the handler that we are finished processing diagnostics on this
</span><span class=c1></span>  <span class=c1>// thread.
</span><span class=c1></span>  <span class=n>handler</span><span class=p>.</span><span class=n>eraseOrderIDForThread</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br></div><nav class=pagination><a class="nav nav-prev" href=/docs/DialectConversion/ title="Dialect Conversion"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect Conversion</a>
<a class="nav nav-next" href=/docs/Interfaces/ title="Introduction to MLIR Interfaces">Next - Introduction to MLIR Interfaces <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=active><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>