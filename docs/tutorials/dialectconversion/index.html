<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect Conversion - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/tutorials/dialectconversion/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Dialect Conversion</h1><p>This document describes a framework in MLIR in which to perform operation
conversions between, and within dialects. This framework allows for transforming
illegal operations to those supported by a provided conversion target, via a set
of pattern-based operation rewriting patterns.</p><p>[TOC]</p><p>To utilize the framework, a few things must be provided:</p><ul><li>A <a href=#conversion-target>Conversion Target</a></li><li>A set of <a href=#rewrite-pattern-specification>Rewrite Patterns</a></li><li>A <a href=#type-conversion>Type Converter</a> (Optional)</li></ul><h2 id=modes-of-conversion>Modes of Conversion</h2><p>When applying a conversion to a set of operations, there are several conversion
modes that can be selected from:</p><ul><li><p>Partial Conversion</p><ul><li>A partial conversion will legalize as many operations to the target as
possible, but will allow pre-existing operations that were not
explicitly marked as <code>illegal</code> to remain unconverted. This allows for
partially lowering parts of the module in the presence of unknown
operations.</li><li>A partial conversion can be applied via <code>applyPartialConversion</code>.</li></ul></li><li><p>Full Conversion</p><ul><li>A full conversion is only successful if all operations are properly
legalized to the given conversion target. This ensures that only known
operations will exist after the conversion process.</li><li>A full conversion can be applied via <code>applyFullConversion</code>.</li></ul></li><li><p>Analysis Conversion</p><ul><li>An analysis conversion will analyze which operations are legalizable to
the given conversion target if a conversion were to be applied. Note
that no rewrites, or transformations, are actually applied to the input
operations.</li><li>An analysis conversion can be applied via <code>applyAnalysisConversion</code>.</li></ul></li></ul><h2 id=conversion-target>Conversion Target</h2><p>The conversion target is the formal definition of what is considered to be legal
during the conversion process. The final operations generated by the conversion
framework must be marked as legal on the <code>ConversionTarget</code> for the rewrite to
be a success. Existing operations need not always be legal, though; see the
different conversion modes for why. Operations and dialects may be marked with
any of the provided legality actions below:</p><ul><li><p>Legal</p><ul><li>This action signals that every instance of a given operation is legal,
i.e. any combination of attributes, operands, types, etc. are valid.</li></ul></li><li><p>Dynamic</p><ul><li>This action signals that only some instances of a given operation are
legal. This allows for defining fine-tune constraints, e.g. saying that
<code>addi</code> is only legal when operating on 32-bit integers.</li><li>If a specific handler is not provided when setting the action, the
target must override the <code>isDynamicallyLegal</code> hook provided by
<code>ConversionTarget</code>.</li></ul></li><li><p>Illegal</p><ul><li>This action signals that no instance of a given operation is legal.
Operations marked as <code>illegal</code> must always be converted for the
conversion to be successful. This action also allows for selectively
marking specific operations as illegal in an otherwise legal dialect.</li></ul></li></ul><p>An example conversion target is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyTarget</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ConversionTarget</span> <span class=p>{</span>
  <span class=n>MyTarget</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>)</span> <span class=o>:</span> <span class=n>ConversionTarget</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//--------------------------------------------------------------------------
</span><span class=c1></span>    <span class=c1>// Marking an operation as Legal:
</span><span class=c1></span>
    <span class=c1>/// Mark all operations within the LLVM dialect are legal.
</span><span class=c1></span>    <span class=n>addLegalDialects</span><span class=o>&lt;</span><span class=n>LLVMDialect</span><span class=o>&gt;</span><span class=p>();</span>

    <span class=c1>/// Mark `std.constant` op is always legal on this target.
</span><span class=c1></span>    <span class=n>addLegalOps</span><span class=o>&lt;</span><span class=n>ConstantOp</span><span class=o>&gt;</span><span class=p>();</span>

    <span class=c1>//--------------------------------------------------------------------------
</span><span class=c1></span>    <span class=c1>// Marking an operation as dynamically legal.
</span><span class=c1></span>
    <span class=c1>/// Mark all operations within Affine dialect have dynamic legality
</span><span class=c1></span>    <span class=c1>/// constraints.
</span><span class=c1></span>    <span class=n>addDynamicallyLegalDialects</span><span class=o>&lt;</span><span class=n>AffineDialect</span><span class=o>&gt;</span><span class=p>();</span>

    <span class=c1>/// Mark `std.return` as dynamically legal.
</span><span class=c1></span>    <span class=n>addDynamicallyLegalOp</span><span class=o>&lt;</span><span class=n>ReturnOp</span><span class=o>&gt;</span><span class=p>();</span>

    <span class=c1>/// Mark `std.return` as dynamically legal, but provide a specific legality
</span><span class=c1></span>    <span class=c1>/// callback.
</span><span class=c1></span>    <span class=n>addDynamicallyLegalOp</span><span class=o>&lt;</span><span class=n>ReturnOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>ReturnOp</span> <span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>

    <span class=c1>//--------------------------------------------------------------------------
</span><span class=c1></span>    <span class=c1>// Marking an operation as illegal.
</span><span class=c1></span>
    <span class=c1>/// All operations within the GPU dialect are illegal.
</span><span class=c1></span>    <span class=n>addIllegalDialect</span><span class=o>&lt;</span><span class=n>GPUDialect</span><span class=o>&gt;</span><span class=p>();</span>

    <span class=c1>/// Mark `std.br` and `std.cond_br` as illegal.
</span><span class=c1></span>    <span class=n>addIllegalOp</span><span class=o>&lt;</span><span class=n>BranchOp</span><span class=p>,</span> <span class=n>CondBranchOp</span><span class=o>&gt;</span><span class=p>();</span>
  <span class=p>}</span>

  <span class=c1>/// Implement the default legalization handler to handle operations marked as
</span><span class=c1></span>  <span class=c1>/// dynamically legal that were not provided with an explicit handler.
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>isDynamicallyLegal</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><h3 id=recursive-legality>Recursive Legality</h3><p>In some cases, it may be desirable to mark entire regions of operations as
legal. This provides an additional granularity of context to the concept of
&ldquo;legal&rdquo;. The <code>ConversionTarget</code> supports marking operations, that were
previously added as <code>Legal</code> or <code>Dynamic</code>, as <code>recursively</code> legal. Recursive
legality means that if an operation instance is legal, either statically or
dynamically, all of the operations nested within are also considered legal. An
operation can be marked via <code>markOpRecursivelyLegal&lt;&gt;</code>:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ConversionTarget</span> <span class=o>&amp;</span><span class=n>target</span> <span class=o>=</span> <span class=p>...;</span>

<span class=c1>/// The operation must first be marked as `Legal` or `Dynamic`.
</span><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>(...);</span>
<span class=n>target</span><span class=p>.</span><span class=n>addDynamicallyLegalOp</span><span class=o>&lt;</span><span class=n>MySecondOp</span><span class=o>&gt;</span><span class=p>(...);</span>

<span class=c1>/// Mark the operation as always recursively legal.
</span><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>();</span>
<span class=c1>/// Mark optionally with a callback to allow selective marking.
</span><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>MySecondOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
<span class=c1>/// Mark optionally with a callback to allow selective marking.
</span><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>MyOp</span> <span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</code></pre></div><h2 id=rewrite-pattern-specification>Rewrite Pattern Specification</h2><p>After the conversion target has been defined, a set of legalization patterns
must be provided to transform illegal operations into legal ones. The patterns
supplied here, that do not <a href=#conversion-patterns>require type changes</a>, are the
same as those described in the
<a href=QuickstartRewrites.md#adding-patterns>quickstart rewrites guide</a>, but have a
few additional <a href=#restrictions>restrictions</a>. The patterns provided do not need
to generate operations that are directly legal on the target. The framework will
automatically build a graph of conversions to convert non-legal operations into
a set of legal ones.</p><p>As an example, say you define a target that supports one operation: <code>foo.add</code>.
When providing the following patterns: [<code>bar.add</code> -&gt; <code>baz.add</code>, <code>baz.add</code> -&gt;
<code>foo.add</code>], the framework will automatically detect that it can legalize
<code>baz.add</code> -&gt; <code>foo.add</code> even though a direct conversion does not exist. This
means that you donâ€™t have to define a direct legalization pattern for <code>bar.add</code>
-&gt; <code>foo.add</code>.</p><h3 id=restrictions>Restrictions</h3><p>The framework processes operations in topological order, trying to legalize them
individually. As such, patterns used in the conversion framework have a few
additional restrictions:</p><ol><li>If a pattern matches, it must erase or replace the op it matched on.
Operations can <em>not</em> be updated in place.</li><li>Match criteria should not be based on the IR outside of the op itself. The
preceding ops will already have been processed by the framework (although it
may not update uses), and the subsequent IR will not yet be processed. This
can create confusion if a pattern attempts to match against a sequence of
ops (e.g. rewrite A + B -&gt; C). That sort of rewrite should be performed in a
separate pass.</li></ol><h2 id=type-conversion>Type Conversion</h2><p>It is sometimes necessary as part of a conversion to convert the set types of
being operated on. In these cases, a <code>TypeConverter</code> object may be defined that
details how types should be converted. The <code>TypeConverter</code> is used by patterns
and by the general conversion infrastructure to convert the signatures of blocks
and regions.</p><h3 id=type-converter>Type Converter</h3><p>As stated above, the <code>TypeConverter</code> contains several hooks for detailing how to
convert types. Several of these hooks are detailed below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>TypeConverter</span> <span class=p>{</span>
 <span class=k>public</span><span class=o>:</span>
  <span class=c1>/// This hook allows for converting a type. This function should return
</span><span class=c1></span>  <span class=c1>/// failure if no valid conversion exists, success otherwise. If the new set
</span><span class=c1></span>  <span class=c1>/// of types is empty, the type is removed and any usages of the existing
</span><span class=c1></span>  <span class=c1>/// value are expected to be removed during conversion.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=n>LogicalResult</span> <span class=n>convertType</span><span class=p>(</span><span class=n>Type</span> <span class=n>t</span><span class=p>,</span> <span class=n>SmallVectorImpl</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>);</span>

  <span class=c1>/// This hook simplifies defining 1-1 type conversions. This function returns
</span><span class=c1></span>  <span class=c1>/// the type to convert to on success, and a null type on failure.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=n>Type</span> <span class=nf>convertType</span><span class=p>(</span><span class=n>Type</span> <span class=n>t</span><span class=p>);</span>

  <span class=c1>/// This hook allows for materializing a conversion from a set of types into
</span><span class=c1></span>  <span class=c1>/// one result type by generating a cast operation of some kind. The generated
</span><span class=c1></span>  <span class=c1>/// operation should produce one result, of &#39;resultType&#39;, with the provided
</span><span class=c1></span>  <span class=c1>/// &#39;inputs&#39; as operands. This hook must be overridden when a type conversion
</span><span class=c1></span>  <span class=c1>/// results in more than one type, or if a type conversion may persist after
</span><span class=c1></span>  <span class=c1>/// the conversion has finished.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=n>Operation</span> <span class=o>*</span><span class=nf>materializeConversion</span><span class=p>(</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
                                           <span class=n>Type</span> <span class=n>resultType</span><span class=p>,</span>
                                           <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span> <span class=o>*&gt;</span> <span class=n>inputs</span><span class=p>,</span>
                                           <span class=n>Location</span> <span class=n>loc</span><span class=p>);</span>
<span class=p>};</span>
</code></pre></div><h3 id=conversion-patterns>Conversion Patterns</h3><p>When type conversion comes into play, the general Rewrite Patterns can no longer
be used. This is due to the fact that the operands of the operation being
matched will not correspond with the operands of the correct type as determined
by <code>TypeConverter</code>. The operation rewrites on type boundaries must thus use a
special pattern, the <code>ConversionPattern</code>. This pattern provides, as an
additional argument to the <code>matchAndRewrite</code> and <code>rewrite</code> methods, the set of
remapped operands corresponding to the desired type. These patterns also utilize
a special <code>PatternRewriter</code>, <code>ConversionPatternRewriter</code>, that provides special
hooks for use with the conversion infrastructure.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyConversionPattern</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ConversionPattern</span> <span class=p>{</span>
  <span class=c1>/// The `matchAndRewrite` hooks on ConversionPatterns take an additional
</span><span class=c1></span>  <span class=c1>/// `operands` parameter, containing the remapped operands of the original
</span><span class=c1></span>  <span class=c1>/// operation.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=n>PatternMatchResult</span>
  <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span> <span class=o>*&gt;</span> <span class=n>operands</span><span class=p>,</span>
                  <span class=n>ConversionPatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>These patterns have the same <a href=#restrictions>restrictions</a> as the basic rewrite
patterns used in dialect conversion.</p><h3 id=region-signature-conversion>Region Signature Conversion</h3><p>From the perspective of type conversion, the entry block to a region is often
special. The types of the entry block arguments are often tied semantically to
details on the operation, e.g. FuncOp, AffineForOp, etc. Given this, the
conversion of the types for this block must be done explicitly via a conversion
pattern. To convert the signature of a region entry block, a custom hook on the
ConversionPatternRewriter must be invoked <code>applySignatureConversion</code>. A
signature conversion, <code>TypeConverter::SignatureConversion</code>, can be built
programmatically:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>SignatureConversion</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=c1>/// Remap an input of the original signature with a new set of types. The
</span><span class=c1></span>    <span class=c1>/// new types are appended to the new signature conversion.
</span><span class=c1></span>    <span class=kt>void</span> <span class=n>addInputs</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>types</span><span class=p>);</span>

    <span class=c1>/// Append new input types to the signature conversion, this should only be
</span><span class=c1></span>    <span class=c1>/// used if the new types are not intended to remap an existing input.
</span><span class=c1></span>    <span class=kt>void</span> <span class=nf>addInputs</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>types</span><span class=p>);</span>

    <span class=c1>/// Remap an input of the original signature with a range of types in the
</span><span class=c1></span>    <span class=c1>/// new signature.
</span><span class=c1></span>    <span class=kt>void</span> <span class=nf>remapInput</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>newInputNo</span><span class=p>,</span>
                    <span class=kt>unsigned</span> <span class=n>newInputCount</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span>

    <span class=c1>/// Remap an input of the original signature to another `replacement`
</span><span class=c1></span>    <span class=c1>/// value. This drops the original argument.
</span><span class=c1></span>    <span class=kt>void</span> <span class=nf>remapInput</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=n>Value</span> <span class=o>*</span><span class=n>replacement</span><span class=p>);</span>
<span class=p>};</span>
</code></pre></div><p>The <code>TypeConverter</code> provides several default utilities for signature conversion:
<code>convertSignatureArg</code>/<code>convertBlockSignature</code>.</p><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Tutorials/DialectConversion.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/tutorials/ title=Tutorials><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Tutorials</a>
<a class="nav nav-next" href=/docs/tutorials/toy/ title="Toy Tutorial">Next - Toy Tutorial <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li class=parent><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li class=active><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgdoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>