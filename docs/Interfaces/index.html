<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Introduction to MLIR Interfaces - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.62.2"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Interfaces/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Introduction to MLIR Interfaces</h1><p>MLIR is generic and very extensible; it allows for opaquely representing many
different dialects that have their own operations, attributes, types, and so on.
This allows for dialects to be very expressive in their semantics and for MLIR
to capture many different levels of abstraction. The downside to this is that
transformations and analyses must be extremely conservative about the operations
that they encounter, and must special-case the different dialects that they
support. To combat this, MLIR provides the concept of <code>interfaces</code>.</p><h2 id=motivation>Motivation</h2><p>Interfaces provide a generic way of interacting with the IR. The goal is to be
able to express transformations/analyses in terms of these interfaces without
encoding specific knowledge about the exact operation or dialect involved. This
makes the compiler more extensible by allowing the addition of new dialects and
operations in a decoupled way with respect to the implementation of
transformations/analyses.</p><h3 id=dialect-interfaces>Dialect Interfaces</h3><p>Dialect interfaces are generally useful for transformation passes or analyses
that want to opaquely operate on operations, even <em>across</em> dialects. These
interfaces generally involve wide coverage over the entire dialect and are only
used for a handful of transformations/analyses. In these cases, registering the
interface directly on each operation is overly complex and cumbersome. The
interface is not core to the operation, just to the specific transformation. An
example of where this type of interface would be used is inlining. Inlining
generally queries high-level information about the operations within a dialect,
like legality and cost modeling, that often is not specific to one operation.</p><p>A dialect interface can be defined by inheriting from the CRTP base class
<code>DialectInterfaceBase::Base</code>. This class provides the necessary utilities for
registering an interface with the dialect so that it can be looked up later.
Once the interface has been defined, dialects can override it using
dialect-specific information. The interfaces defined by a dialect are registered
in a similar mechanism to Attributes, Operations, Types, etc.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Define an Inlining interface to allow for dialects to opt-in.
</span><span class=c1></span><span class=k>class</span> <span class=nc>DialectInlinerInterface</span> <span class=o>:</span>
    <span class=k>public</span> <span class=n>DialectInterface</span><span class=o>:</span><span class=o>:</span><span class=n>Base</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Returns true if the given region &#39;src&#39; can be inlined into the region
</span><span class=c1></span>  <span class=c1>/// &#39;dest&#39; that is attached to an operation registered to the current dialect.
</span><span class=c1></span>  <span class=c1>/// &#39;valueMapping&#39; contains any remapped values from within the &#39;src&#39; region.
</span><span class=c1></span>  <span class=c1>/// This can be used to examine what values will replace entry arguments into
</span><span class=c1></span>  <span class=c1>/// the &#39;src&#39; region, for example.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=kt>bool</span> <span class=n>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                               <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Override the inliner interface to add support for inlining affine
</span><span class=c1></span><span class=c1>/// operations.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>AffineInlinerInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>DialectInlinerInterface</span> <span class=p>{</span>
  <span class=c1>/// Affine structures have specific inlining constraints.
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                       <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Register the interface with the dialect.
</span><span class=c1></span><span class=n>AffineOpsDialect</span><span class=o>:</span><span class=o>:</span><span class=n>AffineOpsDialect</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>{</span>
  <span class=n>addInterfaces</span><span class=o>&lt;</span><span class=n>AffineInlinerInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Once registered, these interfaces can be opaquely queried from the dialect by
the transformation/analysis that wants to use them:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Dialect</span> <span class=o>*</span><span class=n>dialect</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=n>interface</span> <span class=o>=</span> <span class=n>dialect</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getInterface</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=c1>// The dialect provides this interface.
</span></code></pre></div><h4 id=dialectinterfacecollections>DialectInterfaceCollections</h4><p>An additional utility is provided via DialectInterfaceCollection. This CRTP
class allows for collecting all of the dialects that have registered a given
interface within the context.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>InlinerInterface</span> <span class=o>:</span> <span class=k>public</span>
    <span class=n>DialectInterfaceCollection</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=c1>/// The hooks for this class mirror the hooks for the DialectInlinerInterface,
</span><span class=c1></span>  <span class=c1>/// with default implementations that call the hook on the interface for a
</span><span class=c1></span>  <span class=c1>/// given dialect.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                               <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=o>*</span><span class=n>handler</span> <span class=o>=</span> <span class=n>getInterfaceFor</span><span class=p>(</span><span class=n>dest</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getContainingOp</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>handler</span> <span class=o>?</span> <span class=n>handler</span><span class=o>-</span><span class=o>&gt;</span><span class=n>isLegalToInline</span><span class=p>(</span><span class=n>dest</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>valueMapping</span><span class=p>)</span> <span class=o>:</span> <span class=nb>false</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=n>InlinerInterface</span> <span class=nf>interface</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span><span class=p>;</span>
<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>interface</span><span class=p>.</span><span class=n>isLegalToInline</span><span class=p>(</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>)</span>
   <span class=p>.</span><span class=p>.</span><span class=p>.</span>
</code></pre></div><h3 id=operation-interfaces>Operation Interfaces</h3><p>Operation interfaces, as the name suggests, are those registered at the
Operation level. These interfaces provide an opaque view into derived operations
by providing a virtual interface that must be implemented. As an example, the
<code>Linalg</code> dialect may implement an interface that provides general queries about
some of the dialects library operations. These queries may provide things like:
the number of parallel loops; the number of inputs and outputs; etc.</p><p>Operation interfaces are defined by overriding the CRTP base class
<code>OpInterface</code>. This class takes, as a template parameter, a <code>Traits</code> class that
defines a <code>Concept</code> and a <code>Model</code> class. These classes provide an implementation
of concept-based polymorphism, where the Concept defines a set of virtual
methods that are overridden by the Model that is templated on the concrete
operation type. It is important to note that these classes should be pure in
that they contain no non-static data members. Operations that wish to override
this interface should add the provided trait <code>OpInterface&lt;..>::Trait</code> upon
registration.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>ExampleOpInterfaceTraits</span> <span class=p>{</span>
  <span class=c1>/// Define a base concept class that defines the virtual interface that needs
</span><span class=c1></span>  <span class=c1>/// to be overridden.
</span><span class=c1></span>  <span class=k>struct</span> <span class=nc>Concept</span> <span class=p>{</span>
    <span class=k>virtual</span> <span class=o>~</span><span class=n>Concept</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=k>virtual</span> <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=p>}</span><span class=p>;</span>

  <span class=c1>/// Define a model class that specializes a concept on a given operation type.
</span><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>OpT</span><span class=o>&gt;</span>
  <span class=k>struct</span> <span class=nc>Model</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Concept</span> <span class=p>{</span>
    <span class=c1>/// Override the method to dispatch on the concrete operation.
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>final</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>OpT</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>.</span><span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>ExampleOpInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpInterface</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=p>,</span>
                                              <span class=n>ExampleOpInterfaceTraits</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Use base class constructor to support LLVM-style casts.
</span><span class=c1></span>  <span class=k>using</span> <span class=n>OpInterface</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=p>,</span> <span class=n>ExampleOpInterfaceTraits</span><span class=o>&gt;</span><span class=o>:</span><span class=o>:</span><span class=n>OpInterface</span><span class=p>;</span>

  <span class=c1>/// The interface dispatches to &#39;getImpl()&#39;, an instance of the concept.
</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>getImpl</span><span class=p>(</span><span class=p>)</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getNumInputs</span><span class=p>(</span><span class=n>getOperation</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

</code></pre></div><p>Once the interface has been defined, it is registered to an operation by adding
the provided trait <code>ExampleOpInterface::Trait</code>. Using this interface is just
like using any other derived operation type, i.e. casting:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// When defining the operation, the interface is registered via the nested
</span><span class=c1></span><span class=c1>/// &#39;Trait&#39; class provided by the &#39;OpInterface&lt;&gt;&#39; base class.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyOp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Op</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>ExampleOpInterface</span><span class=o>:</span><span class=o>:</span><span class=n>Trait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// The definition of the interface method on the derived operation.
</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span> <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Later, we can query if a specific operation(like &#39;MyOp&#39;) overrides the given
</span><span class=c1></span><span class=c1>/// interface.
</span><span class=c1></span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>ExampleOpInterface</span> <span class=n>example</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>)</span>
  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>num inputs = </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>example</span><span class=p>.</span><span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</code></pre></div><h4 id=utilizing-the-ods-framework>Utilizing the ODS Framework</h4><p>Operation interfaces require a bit of boiler plate to connect all of the pieces
together. The ODS(Operation Definition Specification) framework provides
simplified mechanisms for
<a href=/docs/OpDefinitions/#operation-interfaces>defining interfaces</a>
.</p><p>As an example, using the ODS framework would allow for defining the example
interface above as:</p><pre><code class=language-tablegen data-lang=tablegen>def ExampleOpInterface : OpInterface&lt;&quot;ExampleOpInterface&quot;&gt; {
  let description = [{
    This is an example interface definition.
  }];

  let methods = [
    InterfaceMethod&lt;
      &quot;Get the number of inputs for the current operation.&quot;,
      &quot;unsigned&quot;, &quot;getNumInputs&quot;
    &gt;,
  ];
}
</code></pre><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Diagnostics/ title="Introduction and Usage Guide to MLIR's Diagnostics Infrastructure"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a>
<a class="nav nav-next" href=/docs/Traits/ title="Introduction to MLIR Operation Traits">Next - Introduction to MLIR Operation Traits <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li class=active><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>