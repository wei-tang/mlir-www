<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>MLIR Generic DAG Rewriter Infrastructure - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/GenericDAGRewriter/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>MLIR Generic DAG Rewriter Infrastructure</h1><h2 id=introduction-and-motivation>Introduction and Motivation</h2><p>The goal of a compiler IR is to represent code - at various levels of
abstraction which pose different sets of tradeoffs in terms of representational
capabilities and ease of transformation. However, the ability to represent code
is not itself very useful - you also need to be able to implement those
transformations.</p><p>There are many different sorts of compiler transformations, but this document
focuses on a particularly important class of transformation that comes up
repeatedly at scale, and is important for the immediate goals of MLIR: that of
pattern matching on a set of operations and replacing with another set. This is
the key algorithm required to implement the &ldquo;op fission&rdquo; algorithm used by the
tf2xla bridge, pattern matching rewrites from TF ops to TF/Lite, peephole
optimizations like &ldquo;eliminate identity nodes&rdquo; or &ldquo;replace x+0 with x&rdquo;, as well
as a useful abstraction to implement optimization algorithms for MLIR graphs at
all levels.</p><p>A particular strength of MLIR (and a major difference vs other compiler
infrastructures like LLVM, GCC, XLA, TensorFlow, etc) is that it uses a single
compiler IR to represent code at multiple levels of abstraction: an MLIR
operation can be a &ldquo;TensorFlow operation&rdquo;, an &ldquo;XLA HLO&rdquo;, a &ldquo;TF Lite
FlatBufferModel op&rdquo;, a TPU LLO instruction, an LLVM IR instruction (transitively
including X86, Lanai, CUDA, and other target specific instructions), or anything
else that the MLIR type system can reasonably express. Because MLIR spans such a
wide range of different problems, a single infrastructure for performing
graph-to-graph rewrites can help solve many diverse domain challenges, including
TensorFlow graph level down to the machine code level.</p><p><a href=https://en.wikipedia.org/wiki/Static_single_assignment_form>Static single assignment</a>
(SSA) representations like MLIR make it easy to access the operands and &ldquo;users&rdquo;
of an operation. As such, a natural abstraction for these graph-to-graph
rewrites is that of DAG pattern matching: clients define DAG tile patterns, and
each pattern includes a result DAG to produce and the cost of the result (or,
inversely, the benefit of doing the replacement). A common infrastructure
efficiently finds and perform the rewrites.</p><p>While this concept is simple, the details are more nuanced. This proposal
defines and explores a set of abstractions that we feel can solve a wide range
of different problems, and can be applied to many different sorts of problems
that MLIR is - and is expected to - face over time. We do this by separating the
pattern definition and matching algorithm from the &ldquo;driver&rdquo; of the computation
loop, and make space for the patterns to be defined declaratively in the future.</p><h2 id=related-work>Related Work</h2><p>There is a huge amount of related work to consider, given that pretty much every
compiler in existence has to solve this problem many times over. Here are a few
graph rewrite systems we have used, along with the pros and cons of this related
work. One unifying problem with all of these is that these systems are only
trying to solve one particular and usually narrow problem: our proposal would
like to solve many of these problems with a single infrastructure. Of these, the
most similar design to our proposal is the LLVM DAG-to-DAG instruction selection
algorithm at the end.</p><h3 id=constant-folding>Constant folding</h3><p>A degenerate but pervasive case of DAG-to-DAG pattern matching is constant
folding: given an operation whose operands contain constants can often be folded
to a result constant value.</p><p>MLIR already has constant folding routines which provide a simpler API than a
general DAG-to-DAG pattern matcher, and we expect it to remain because the
simpler contract makes it applicable in some cases that a generic matcher would
not. For example, a DAG-rewrite can remove arbitrary nodes in the current
function, which could invalidate iterators. Constant folding as an API does not
remove any nodes, it just provides a (list of) constant values and allows the
clients to update their data structures as necessary.</p><h3 id=ast-level-pattern-matchers>AST-Level Pattern Matchers</h3><p>The literature is full of source-to-source translators which transform
identities in order to improve performance (e.g. transforming <code>X*0</code> into <code>0</code>).
One large example that I&rsquo;m aware of is the GCC <code>fold</code> function, which performs
<a href=https://github.com/gcc-mirror/gcc/blob/master/gcc/fold-const.c>many optimizations</a>
on ASTs. Clang has
<a href=http://releases.llvm.org/3.5.0/tools/clang/docs/InternalsManual.html#constant-folding-in-the-clang-ast>similar routines</a>
for simple constant folding of expressions (as required by the C++ standard) but
doesn&rsquo;t perform general optimizations on its ASTs.</p><p>The primary downside of tree optimizers is that you can&rsquo;t see across operations
that have multiple uses. It is
<a href=https://llvm.org/pubs/2008-06-LCTES-ISelUsingSSAGraphs.pdf>well known in literature</a>
that DAG pattern matching is more powerful than tree pattern matching, but OTOH,
DAG pattern matching can lead to duplication of computation which needs to be
checked for.</p><h3 id=combiners-and-other-peephole-optimizers>&ldquo;Combiners&rdquo; and other peephole optimizers</h3><p>Compilers end up with a lot of peephole optimizers for various things, e.g. the
GCC
<a href=https://github.com/gcc-mirror/gcc/blob/master/gcc/combine.c>&ldquo;combine&rdquo; routines</a>
(which try to merge two machine instructions into a single one), the LLVM
<a href=http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/InstCombine/>Inst Combine</a>
<a href=https://llvm.org/docs/Passes.html#instcombine-combine-redundant-instructions>pass</a>
,
LLVM&rsquo;s
<a href=https://github.com/llvm-mirror/llvm/blob/master/lib/CodeGen/SelectionDAG/DAGCombiner.cpp>DAG Combiner</a>
,
the Swift compiler&rsquo;s
<a href=https://github.com/apple/swift/tree/master/lib/SILOptimizer/SILCombiner>SIL Combiner</a>
,
etc. These generally match one or more operations and produce zero or more
operations as a result. The LLVM
<a href=http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/CodeGen/SelectionDAG/>Legalization</a>
infrastructure has a different outer loop but otherwise works the same way.</p><p>These passes have a lot of diversity, but also have a unifying structure: they
mostly have a worklist outer loop which visits operations. They then use the C++
visitor pattern (or equivalent) to switch over the class of operation and
dispatch to a method. That method contains a long list of hand-written C++ code
that pattern-matches various special cases. LLVM introduced a &ldquo;match&rdquo; function
that allows writing patterns in a somewhat more declarative style using template
metaprogramming (MLIR has similar facilities). Here&rsquo;s a simple example:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// Y - (X + 1) --&gt; ~X + Y
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=n>Op1</span><span class=p>,</span> <span class=n>m_OneUse</span><span class=p>(</span><span class=n>m_Add</span><span class=p>(</span><span class=n>m_Value</span><span class=p>(</span><span class=n>X</span><span class=p>)</span><span class=p>,</span> <span class=n>m_One</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>BinaryOperator</span><span class=o>:</span><span class=o>:</span><span class=n>CreateAdd</span><span class=p>(</span><span class=n>Builder</span><span class=p>.</span><span class=n>CreateNot</span><span class=p>(</span><span class=n>X</span><span class=p>)</span><span class=p>,</span> <span class=n>Op0</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><p>Here is a somewhat more complicated one (this is not the biggest or most
complicated :)</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// C2 is ODD
</span><span class=c1></span>  <span class=c1>// LHS = XOR(Y,C1), Y = AND(Z,C2), C1==(C2+1) =&gt; LHS == NEG(OR(Z, ~C2))
</span><span class=c1></span>  <span class=c1>// ADD(LHS, RHS) == SUB(RHS, OR(Z, ~C2))
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=n>LHS</span><span class=p>,</span> <span class=n>m_Xor</span><span class=p>(</span><span class=n>m_Value</span><span class=p>(</span><span class=n>Y</span><span class=p>)</span><span class=p>,</span> <span class=n>m_APInt</span><span class=p>(</span><span class=n>C1</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>C1</span><span class=o>-</span><span class=o>&gt;</span><span class=n>countTrailingZeros</span><span class=p>(</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=n>Y</span><span class=p>,</span> <span class=n>m_And</span><span class=p>(</span><span class=n>m_Value</span><span class=p>(</span><span class=n>Z</span><span class=p>)</span><span class=p>,</span> <span class=n>m_APInt</span><span class=p>(</span><span class=n>C2</span><span class=p>)</span><span class=p>)</span><span class=p>)</span> <span class=o>&amp;</span><span class=o>&amp;</span> <span class=o>*</span><span class=n>C1</span> <span class=o>=</span><span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>C2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Value</span> <span class=n>NewOr</span> <span class=o>=</span> <span class=n>Builder</span><span class=p>.</span><span class=n>CreateOr</span><span class=p>(</span><span class=n>Z</span><span class=p>,</span> <span class=o>~</span><span class=p>(</span><span class=o>*</span><span class=n>C2</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>Builder</span><span class=p>.</span><span class=n>CreateSub</span><span class=p>(</span><span class=n>RHS</span><span class=p>,</span> <span class=n>NewOr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>sub</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
      <span class=p>}</span>
</code></pre></div><p>These systems are simple to set up, and pattern matching templates have some
advantages (they are extensible for new sorts of sub-patterns, look compact at
point of use). OTOH, they have lots of well known problems, for example:</p><ul><li>These patterns are very error prone to write, and contain lots of
redundancies.</li><li>The IR being matched often has identities (e.g. when matching commutative
operators) and the C++ code has to handle it manually - take a look at
<a href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/InstCombine/InstCombineAddSub.cpp?view=markup#l775">the full code</a>
for checkForNegativeOperand that defines the second pattern).</li><li>The matching code compiles slowly, both because it generates tons of code
and because the templates instantiate slowly.</li><li>Adding new patterns (e.g. for count leading zeros in the example above) is
awkward and doesn&rsquo;t often happen.</li><li>The cost model for these patterns is not really defined - it is emergent
based on the order the patterns are matched in code.</li><li>They are non-extensible without rebuilding the compiler.</li><li>It isn&rsquo;t practical to apply theorem provers and other tools to these
patterns - they cannot be reused for other purposes.</li></ul><p>In addition to structured &ldquo;combiners&rdquo; like these, there are lots of ad-hoc
systems like the
<a href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/CodeGen/PeepholeOptimizer.cpp?view=markup">LLVM Machine code peephole optimizer</a>
which are related.</p><h3 id=llvms-dag-to-dag-instruction-selection-infrastructure>LLVM&rsquo;s DAG-to-DAG Instruction Selection Infrastructure</h3><p>The instruction selection subsystem in LLVM is the result of many years worth of
iteration and discovery, driven by the need for LLVM to support code generation
for lots of targets, the complexity of code generators for modern instruction
sets (e.g. X86), and the fanatical pursuit of reusing code across targets. Eli
wrote a
<a href=https://eli.thegreenplace.net/2013/02/25/a-deeper-look-into-the-llvm-code-generator-part-1>nice short overview</a>
of how this works, and the
<a href=https://llvm.org/docs/CodeGenerator.html#select-instructions-from-dag>LLVM documentation</a>
describes it in more depth including its advantages and limitations. It allows
writing patterns like this.</p><pre><code>def : Pat&lt;(or GR64:$src, (not (add GR64:$src, 1))),
          (BLCI64rr GR64:$src)&gt;;
</code></pre><p>This example defines a matcher for the
<a href=https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#TBM_%5c%28Trailing_Bit_Manipulation%5c%29>&ldquo;blci&rdquo; instruction</a>
in the
<a href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Target/X86/X86InstrInfo.td?view=markup">X86 target description</a>
,
there are many others in that file (look for <code>Pat&lt;></code> patterns, since they aren&rsquo;t
entangled in details of the compiler like assembler/disassembler generation
logic).</p><p>For our purposes, there is much to like about this system, for example:</p><ul><li>It is defined in a declarative format.</li><li>It is extensible to target-defined operations.</li><li>It automates matching across identities, like commutative patterns.</li><li>It allows custom abstractions and intense factoring of target-specific
commonalities.</li><li>It generates compact code - it compiles into a state machine, which is
interpreted.</li><li>It allows the instruction patterns to be defined and reused for multiple
purposes.</li><li>The patterns are &ldquo;type checked&rdquo; at compile time, detecting lots of bugs
early and eliminating redundancy from the pattern specifications.</li><li>It allows the use of general C++ code for weird/complex cases.</li></ul><p>While there is a lot that is good here, there is also a lot of bad things:</p><ul><li>All of this machinery is only applicable to instruction selection. Even
directly adjacent problems like the DAGCombiner and Legalizer can&rsquo;t use it.</li><li>This isn&rsquo;t extensible at compiler runtime, you have to rebuild the compiler
to extend it.</li><li>The error messages when failing to match a pattern
<a href="https://www.google.com/search?q=llvm+cannot+select">are not exactly optimal</a>
.</li><li>It has lots of implementation problems and limitations (e.g. can&rsquo;t write a
pattern for a multi-result operation) as a result of working with the
awkward SelectionDAG representation and being designed and implemented
lazily.</li><li>This stuff all grew organically over time and has lots of sharp edges.</li></ul><h3 id=summary>Summary</h3><p>MLIR will face a wide range of pattern matching and graph rewrite problems, and
one of the major advantages of having a common representation for code at
multiple levels that it allows us to invest in - and highly leverage - a single
infra for doing this sort of work.</p><h2 id=goals>Goals</h2><p>This proposal includes support for defining pattern matching and rewrite
algorithms on MLIR. We&rsquo;d like these algorithms to encompass many problems in the
MLIR space, including 1-to-N expansions (e.g. as seen in the TF/XLA bridge when
lowering a &ldquo;tf.AddN&rdquo; to multiple &ldquo;add&rdquo; HLOs), M-to-1 patterns (as seen in
Grappler optimization passes, e.g. that convert multiple/add into a single
muladd op), as well as general M-to-N patterns (e.g. instruction selection for
target instructions). Patterns should have a cost associated with them, and the
common infrastructure should be responsible for sorting out the lowest cost
match for a given application.</p><p>We separate the task of picking a particular locally optimal pattern from a
given root node, the algorithm used to rewrite an entire graph given a
particular set of goals, and the definition of the patterns themselves. We do
this because DAG tile pattern matching is NP complete, which means that there
are no known polynomial time algorithms to optimally solve this problem.
Additionally, we would like to support iterative rewrite algorithms that
progressively transform the input program through multiple steps. Furthermore,
we would like to support many different sorts of clients across the MLIR stack,
and they may have different tolerances for compile time cost, different demands
for optimality, and other algorithmic goals or constraints.</p><p>We aim for MLIR transformations to be easy to implement and reduce the
likelihood for compiler bugs. We expect there to be a very very large number of
patterns that are defined over time, and we believe that these sorts of patterns
will have a very large number of legality/validity constraints - many of which
are difficult to reason about in a consistent way, may be target specific, and
whose implementation may be particularly bug-prone. As such, we aim to design the
API around pattern definition to be simple, resilient to programmer errors, and
allow separation of concerns between the legality of the nodes generated from
the idea of the pattern being defined.</p><p>Finally, error handling is a topmost concern: in addition to allowing patterns
to be defined in a target-independent way that may not apply for all hardware,
we also want failure for any pattern to match to be diagnosable in a reasonable
way. To be clear, this is not a solvable problem in general - the space of
malfunction is too great to be fully enumerated and handled optimally, but there
are better and worse ways to handle the situation. MLIR is already designed to
represent the provenance of an operation well. This project aims to propagate
that provenance information precisely, as well as diagnose pattern match
failures with the rationale for why a set of patterns do not apply.</p><h3 id=non-goals>Non goals</h3><p>This proposal doesn&rsquo;t aim to solve all compiler problems, it is simply a
DAG-to-DAG pattern matching system, starting with a greedy driver algorithm.
Compiler algorithms that require global dataflow analysis (e.g. common
subexpression elimination, conditional constant propagation, and many many
others) will not be directly solved by this infrastructure.</p><p>This proposal is limited to DAG patterns, which (by definition) prevent the
patterns from seeing across cycles in a graph. In an SSA-based IR like MLIR,
this means that these patterns don&rsquo;t see across PHI nodes / basic block
arguments. We consider this acceptable given the set of problems we are trying
to solve - we don&rsquo;t know of any other system that attempts to do so, and
consider the payoff of worrying about this to be low.</p><p>This design includes the ability for DAG patterns to have associated costs
(benefits), but those costs are defined in terms of magic numbers (typically
equal to the number of nodes being replaced). For any given application, the
units of magic numbers will have to be defined.</p><h2 id=overall-design>Overall design</h2><p>We decompose the problem into four major pieces:</p><ol><li>the code that is used to define patterns to match, cost, and their
replacement actions</li><li>the driver logic to pick the best match for a given root node</li><li>the client that is implementing some transformation (e.g. a combiner)</li><li>(future) the subsystem that allows patterns to be described with a
declarative syntax, which sugars step #1.</li></ol><p>We sketch the first three of these pieces, each in turn. This is not intended to
be a concrete API proposal, merely to describe the design</p><h3 id=defining-patterns>Defining Patterns</h3><p>Each pattern will be an instance of a mlir::Pattern class, whose subclasses
implement methods like this. Note that this API is meant for exposition, the
actual details are different for efficiency and coding standards reasons (e.g.
the memory management of <code>PatternState</code> is not specified below, etc):</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>Pattern</span> <span class=p>{</span>
  <span class=c1>/// Return the benefit (the inverse of &#34;cost&#34;) of matching this pattern.  The
</span><span class=c1></span>  <span class=c1>/// benefit of a Pattern is always static - rewrites that may have dynamic
</span><span class=c1></span>  <span class=c1>/// benefit can be instantiated multiple times (different Pattern instances)
</span><span class=c1></span>  <span class=c1>/// for each benefit that they may return, and be guarded by different match
</span><span class=c1></span>  <span class=c1>/// condition predicates.
</span><span class=c1></span>  <span class=n>PatternBenefit</span> <span class=nf>getBenefit</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>benefit</span><span class=p>;</span> <span class=p>}</span>

  <span class=c1>/// Return the root node that this pattern matches.  Patterns that can
</span><span class=c1></span>  <span class=c1>/// match multiple root types are instantiated once per root.
</span><span class=c1></span>  <span class=n>OperationName</span> <span class=nf>getRootKind</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>rootKind</span><span class=p>;</span> <span class=p>}</span>

  <span class=c1>/// Attempt to match against code rooted at the specified operation,
</span><span class=c1></span>  <span class=c1>/// which is the same operation code as getRootKind().  On failure, this
</span><span class=c1></span>  <span class=c1>/// returns a None value.  On success it a (possibly null) pattern-specific
</span><span class=c1></span>  <span class=c1>/// state wrapped in a Some.  This state is passed back into its rewrite
</span><span class=c1></span>  <span class=c1>/// function if this match is selected.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=n>Optional</span><span class=o>&lt;</span><span class=n>PatternState</span><span class=o>*</span><span class=o>&gt;</span> <span class=n>match</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=c1>/// Rewrite the IR rooted at the specified operation with the result of
</span><span class=c1></span>  <span class=c1>/// this pattern, generating any new operations with the specified
</span><span class=c1></span>  <span class=c1>/// rewriter.  If an unexpected error is encountered (an internal
</span><span class=c1></span>  <span class=c1>/// compiler error), it is emitted through the normal MLIR diagnostic
</span><span class=c1></span>  <span class=c1>/// hooks and the IR is left in a valid state.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>rewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>PatternState</span> <span class=o>*</span><span class=n>state</span><span class=p>,</span>
                       <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>In practice, the first patterns we implement will directly subclass and
implement this stuff, but we will define some helpers to reduce boilerplate.
When we have a declarative way to describe patterns, this should be
automatically generated from the description.</p><p>Instances of <code>Pattern</code> have a benefit that is static upon construction of the
pattern instance, but may be computed dynamically at pattern initialization
time, e.g. allowing the benefit to be derived from domain specific information,
like the target architecture). This limitation allows us MLIR to (eventually)
perform pattern fusion and compile patterns into an efficient state machine, and
<a href="https://dl.acm.org/citation.cfm?id=3179501">Thier, Ertl, and Krall</a>
have shown
that match predicates eliminate the need for dynamically computed costs in
almost all cases: you can simply instantiate the same pattern one time for each
possible cost and use the predicate to guard the match.</p><p>The two-phase nature of this API (match separate from rewrite) is important for
two reasons: 1) some clients may want to explore different ways to tile the
graph, and only rewrite after committing to one tiling. 2) We want to support
runtime extensibility of the pattern sets, but want to be able to statically
compile the bulk of known patterns into a state machine at &ldquo;compiler compile
time&rdquo;. Both of these reasons lead to us needing to match multiple patterns
before committing to an answer.</p><h3 id=picking-and-performing-a-replacement>Picking and performing a replacement</h3><p>In the short term, this API can be very simple, something like this can work and
will be useful for many clients:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>PatternMatcher</span> <span class=p>{</span>
   <span class=c1>// Create a pattern matcher with a bunch of patterns.  This constructor
</span><span class=c1></span>   <span class=c1>// looks across all of the specified patterns, and builds an internal
</span><span class=c1></span>   <span class=c1>// data structure that allows efficient matching.
</span><span class=c1></span>   <span class=n>PatternMatcher</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Pattern</span><span class=o>*</span><span class=o>&gt;</span> <span class=n>patterns</span><span class=p>)</span><span class=p>;</span>

   <span class=c1>// Given a specific operation, see if there is some rewrite that is
</span><span class=c1></span>   <span class=c1>// interesting.  If so, return success and return the list of new
</span><span class=c1></span>   <span class=c1>// operations that were created.  If not, return failure.
</span><span class=c1></span>   <span class=kt>bool</span> <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span>
                        <span class=n>SmallVectorImpl</span><span class=o>&lt;</span><span class=n>Operation</span><span class=o>*</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>newlyCreatedOps</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>In practice the interesting part of this class is the acceleration structure it
builds internally. It buckets up the patterns by root operation, and sorts them
by their static benefit. When performing a match, it tests any dynamic patterns,
then tests statically known patterns from highest to lowest benefit.</p><h3 id=first-client-a-greedy-worklist-combiner>First Client: A Greedy Worklist Combiner</h3><p>We expect that there will be lots of clients for this, but a simple greedy
worklist-driven combiner should be powerful enough to serve many important ones,
including the
<a href=https://github.com/tensorflow/tensorflow/tree/master/tensorflow/compiler/tf2xla/kernels>TF2XLA op expansion logic</a>
,
many of the pattern substitution passes of the
<a href=https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/toco>TOCO compiler</a>
for TF-Lite, many
<a href=https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/grappler>Grappler</a>
passes, and other general performance optimizations for applying identities.</p><p>The structure of this algorithm is straight-forward, here is pseudo code:</p><ul><li>Walk a function in preorder, adding each operation to a worklist.</li><li>While the worklist is non-empty, pull something off the back (processing
things generally in postorder)<ul><li>Perform matchAndRewrite on the operation. If failed, continue to the
next operation.</li><li>On success, add the newly created ops to the worklist and continue.</li></ul></li></ul><h2 id=future-directions>Future directions</h2><p>It is important to get implementation and usage experience with this, and many
patterns can be defined using this sort of framework. Over time, we can look to
make it easier to declare patterns in a declarative form (e.g. with the LLVM
tblgen tool or something newer/better). Once we have that, we can define an
internal abstraction for describing the patterns to match, allowing better high
level optimization of patterns (including fusion of the matching logic across
patterns, which the LLVM instruction selector does) and allow the patterns to be
defined without rebuilding the compiler itself.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/DialectConversion/ title="Dialect Conversion"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect Conversion</a>
<a class="nav nav-next" href=/docs/Interfaces/ title="MLIR Interfaces">Next - MLIR Interfaces <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=active><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Interfaces/>MLIR Interfaces</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Traits/>MLIR Operation Traits</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>