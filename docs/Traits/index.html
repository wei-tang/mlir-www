<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Introduction to MLIR Operation Traits - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Traits/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Introduction to MLIR Operation Traits</h1><p><nav id=TableOfContents><ul><li><a href=#defining-a-trait>Defining a Trait</a><ul><li><a href=#parametric-traits>Parametric Traits</a></li></ul></li><li><a href=#attaching-a-trait>Attaching a Trait</a></li><li><a href=#using-a-trait>Using a Trait</a></li><li><a href=#trait-list>Trait List</a><ul><li><a href=#broadcastable>Broadcastable</a></li><li><a href=#commutative>Commutative</a></li><li><a href=#function-like>Function-Like</a></li><li><a href=#hasparent>HasParent</a></li><li><a href=#isolatedfromabove>IsolatedFromAbove</a></li><li><a href=#nosideeffect>NoSideEffect</a></li><li><a href=#single-block-with-implicit-terminator>Single Block with Implicit Terminator</a></li><li><a href=#symbol>Symbol</a></li><li><a href=#symboltable>SymbolTable</a></li><li><a href=#terminator>Terminator</a></li></ul></li></ul></nav><p>MLIR allows for a truly open operation ecosystem, as any dialect may define
operations that suit a specific level of abstraction. <code>Traits</code> are a mechanism
in which to abstract implementation details and properties that are common
across many different operations. <code>Traits</code> may be used to specify special
properties and constraints of the operation, including whether the operation has
side effects or whether its output has the same type as the input. Some examples
of traits are <code>Commutative</code>, <code>SingleResult</code>, <code>Terminator</code>, etc. See the more
<a href=#traits>comprehensive list</a>
below for more examples of what is possible.</p><h2 id=defining-a-trait>Defining a Trait</h2><p>Traits may be defined in C++ by inheriting from the
<code>OpTrait::TraitBase&lt;ConcreteType, TraitType></code> class. This base class takes as
template parameters:</p><ul><li>ConcreteType<ul><li>The concrete operation type that this trait was attached to.</li></ul></li><li>TraitType<ul><li>The type of the trait class that is being defined, for use with the
<a href=https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern><code>Curiously Recurring Template Pattern</code></a>
.</li></ul></li></ul><p>A derived trait class is expected to take a single template that corresponds to
the <code>ConcreteType</code>. An example trait definition is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyTrait</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>:</span><span class=o>:</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>MyTrait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>Derived traits may also provide a <code>verifyTrait</code> hook, that is called when
verifying the concrete operation. The trait verifiers will currently always be
invoked before the main <code>Op::verify</code>.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyTrait</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>:</span><span class=o>:</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>MyTrait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Override the &#39;verifyTrait&#39; hook to add additional verification on the
</span><span class=c1></span>  <span class=c1>/// concrete operation.
</span><span class=c1></span>  <span class=k>static</span> <span class=n>LogicalResult</span> <span class=n>verifyTrait</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><p>Note: It is generally good practice to define the implementation of the
<code>verifyTrait</code> hook out-of-line as a free function when possible to avoid
instantiating the implementation for every concrete operation type.</p><h3 id=parametric-traits>Parametric Traits</h3><p>The above demonstrates the definition of a simple self-contained trait. It is
also often useful to provide some static parameters to the trait to control its
behavior. Given that the definition of the trait class is rigid, i.e. we must
have a single template argument for the concrete operation, the templates for
the parameters will need to be split out. An example is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>Parameter</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyParametricTrait</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
  <span class=k>class</span> <span class=nc>Impl</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>:</span><span class=o>:</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>Impl</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=c1>// Inside of &#39;Impl&#39; we have full access to the template parameters
</span><span class=c1></span>    <span class=c1>// specified above.
</span><span class=c1></span>  <span class=p>}</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><h2 id=attaching-a-trait>Attaching a Trait</h2><p>Traits may be used when defining a derived operation type, by simply adding the
name of the trait class to the <code>Op</code> class after the concrete operation type:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Here we define &#39;MyOp&#39; along with the &#39;MyTrait&#39; and `MyParametric trait
</span><span class=c1></span><span class=c1>/// classes we defined previously.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyOp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Op</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>MyTrait</span><span class=p>,</span> <span class=n>MyParametricTrait</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;</span><span class=o>:</span><span class=o>:</span><span class=n>Impl</span><span class=o>&gt;</span> <span class=p>{</span><span class=p>}</span><span class=p>;</span>
</code></pre></div><p>To use a trait in the
<a href=/docs/OpDefinitions/>ODS</a>
framework, we need to provide a
definition of the trait class. This can be done using the <code>NativeOpTrait</code> and
<code>ParamNativeOpTrait</code> classes. <code>ParamNativeOpTrait</code> provides a mechanism in which
to specify arguments to a parametric trait class with an internal <code>Impl</code>.</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=c>// The argument is the c++ trait class name.
</span><span class=c></span><span class=k>def</span> <span class=nv>MyTrait</span> <span class=p>:</span> <span class=nv>NativeOpTrait</span><span class=p>&lt;</span><span class=s>&#34;MyTrait&#34;</span><span class=p>&gt;</span><span class=p>;</span>

<span class=c>// The first argument is the parent c++ class name. The second argument is a
</span><span class=c></span><span class=c>// string containing the parameter list.
</span><span class=c></span><span class=k>class</span> <span class=nv>MyParametricTrait</span><span class=p>&lt;</span><span class=k>int</span> <span class=nv>prop</span><span class=p>&gt;</span>
  <span class=p>:</span> <span class=nv>NativeOpTrait</span><span class=p>&lt;</span><span class=s>&#34;MyParametricTrait&#34;</span><span class=p>,</span> <span class=p>!</span><span class=nv>cast</span><span class=p>&lt;</span><span class=k>string</span><span class=p>&gt;</span><span class=p>(</span><span class=p>!</span><span class=nv>head</span><span class=p>(</span><span class=nv>parameters</span><span class=p>)</span><span class=p>)</span><span class=p>&gt;</span><span class=p>;</span>
</code></pre></div><p>These can then be used in the <code>traits</code> list of an op definition:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>OpWithInferTypeInterfaceOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>[</span><span class=nv>MyTrait</span><span class=p>,</span> <span class=nv>MyParametricTrait</span><span class=p>&lt;</span><span class=m>10</span><span class=p>&gt;</span><span class=p>]</span><span class=p>&gt;</span> <span class=p>{</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>}</span>
</code></pre></div><p>See the documentation on
<a href=/docs/OpDefinitions/>operation definitions</a>
for more
details.</p><h2 id=using-a-trait>Using a Trait</h2><p>Traits may be used to provide additional methods, static fields, or other
information directly on the concrete operation. <code>Traits</code> internally become
<code>Base</code> classes of the concrete operation, so all of these are directly
accessible. To expose this information opaquely to transformations and analyses,
<a href=/docs/Interfaces/><code>interfaces</code></a>
may be used.</p><p>To query if a specific operation contains a specific trait, the <code>hasTrait&lt;></code>
method may be used. This takes as a template parameter the trait class, which is
the same as the one passed when attaching the trait to an operation.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>hasTrait</span><span class=o>&lt;</span><span class=n>MyTrait</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span> <span class=o>|</span><span class=o>|</span> <span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>hasTrait</span><span class=o>&lt;</span><span class=n>MyParametricTrait</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;</span><span class=o>:</span><span class=o>:</span><span class=n>Impl</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
</code></pre></div><h2 id=trait-list>Trait List</h2><p>MLIR provides a suite of traits that provide various functionalities that are
common across many different operations. Below is a list of some key traits that
may be used directly by any dialect. The format of the header for each trait
section goes as follows:</p><ul><li><code>Header</code><ul><li>(<code>C++ class</code> &ndash; <code>ODS class</code>(if applicable))</li></ul></li></ul><h3 id=broadcastable>Broadcastable</h3><ul><li><code>OpTrait::ResultsBroadcastableShape</code> &ndash; <code>ResultsBroadcastableShape</code></li></ul><p>This trait adds the property that the operation is known to have
<a href=https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>broadcast-compatible</a>
operands and its result types&rsquo; shape is the broadcast compatible with the shape
of the broadcasted operands. Specifically, starting from the most varying
dimension, each dimension pair of the two operands&rsquo; shapes should either be the
same or one of them is one. Also, the result shape should have the corresponding
dimension equal to the larger one, if known. Shapes are checked partially if
ranks or dimensions are not known. For example, an op with <code>tensor&lt;?x2xf32></code> and
<code>tensor&lt;2xf32></code> as operand types and <code>tensor&lt;3x2xf32></code> as the result type is
broadcast-compatible.</p><p>This trait requires that the operands are either vector or tensor types.</p><h3 id=commutative>Commutative</h3><ul><li><code>OpTrait::IsCommutative</code> &ndash; <code>Commutative</code></li></ul><p>This trait adds the property that the operation is commutative, i.e. <code>X op Y == Y op X</code></p><h3 id=function-like>Function-Like</h3><ul><li><code>OpTrait::FunctionLike</code></li></ul><p>This trait provides APIs for operations that behave like functions. In
particular:</p><ul><li>Ops must be symbols, i.e. also have the <code>Symbol</code> trait;</li><li>Ops have a single region with multiple blocks that corresponds to the body
of the function;</li><li>the absence of a region corresponds to an external function;</li><li>arguments of the first block of the region are treated as function
arguments;</li><li>they can have argument and result attributes that are stored in dictionary
attributes on the operation itself.</li></ul><p>This trait does <em>NOT</em> provide type support for the functions, meaning that
concrete Ops must handle the type of the declared or defined function.
<code>getTypeAttrName()</code> is a convenience function that returns the name of the
attribute that can be used to store the function type, but the trait makes no
assumption based on it.</p><h3 id=hasparent>HasParent</h3><ul><li><code>OpTrait::HasParent&lt;typename ParentOpType></code> &ndash; <code>HasParent&lt;string op></code></li></ul><p>This trait provides APIs and verifiers for operations that can only be nested
within regions that are attached to operations of <code>ParentOpType</code>.</p><h3 id=isolatedfromabove>IsolatedFromAbove</h3><ul><li><code>OpTrait::IsIsolatedFromAbove</code> &ndash; <code>IsolatedFromAbove</code></li></ul><p>This trait signals that the regions of an operations are known to be isolated
from above. This trait asserts that the regions of an operation will not
capture, or reference, SSA values defined above the region scope. This means
that the following is invalid if <code>foo.region_op</code> is defined as
<code>IsolatedFromAbove</code>:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%result</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>10</span> <span class=p>:</span> <span class=k>i32</span>
foo<span class=p>.</span>region_op <span class=p>{</span>
  foo<span class=p>.</span>yield <span class=nv>%result</span> <span class=p>:</span> <span class=k>i32</span>
<span class=p>}</span>
</code></pre></div><p>This trait is an important structural property of the IR, and enables operations
to have
<a href=/docs/WritingAPass/>passes</a>
scheduled under them.</p><h3 id=nosideeffect>NoSideEffect</h3><ul><li><code>OpTrait::HasNoSideEffect</code> &ndash; <code>NoSideEffect</code></li></ul><p>This trait signifies that the operation is pure and has no visible side effects.</p><h3 id=single-block-with-implicit-terminator>Single Block with Implicit Terminator</h3><ul><li><code>OpTrait::SingleBlockImplicitTerminator&lt;typename TerminatorOpType></code> :
<code>SingleBlockImplicitTerminator&lt;string op></code></li></ul><p>This trait provides APIs and verifiers for operations with regions that have a
single block that must terminate with <code>TerminatorOpType</code>.</p><h3 id=symbol>Symbol</h3><ul><li><code>OpTrait::Symbol</code> &ndash; <code>Symbol</code></li></ul><p>This trait is used for operations that define a
<a href=/docs/SymbolsAndSymbolTables/#symbol><code>Symbol</code></a>
.</p><h3 id=symboltable>SymbolTable</h3><ul><li><code>OpTrait::SymbolTable</code> &ndash; <code>SymbolTable</code></li></ul><p>This trait is used for operations that define a
<a href=/docs/SymbolsAndSymbolTables/#symbol-table><code>SymbolTable</code></a>
.</p><h3 id=terminator>Terminator</h3><ul><li><code>OpTrait::IsTerminator</code> &ndash; <code>Terminator</code></li></ul><p>This trait provides verification and functionality for operations that are known
to be
<a href=/docs/LangRef/#terminator-operations>terminators</a>
.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Interfaces/ title="Introduction to MLIR Interfaces"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Introduction to MLIR Interfaces</a>
<a class="nav nav-next" href=/docs/RationaleLinalgDialect/ title="Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations">Next - Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/OpenMPOps/>Dialect 'omp' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li class=active><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>