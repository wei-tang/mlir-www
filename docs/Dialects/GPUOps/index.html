<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect 'gpu' definition - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/GPUOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Dialect 'gpu' definition</h1><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#gpuall_reduce-gpuallreduceop>gpu.all_reduce (gpu::AllReduceOp)</a></li><li><a href=#gpubarrier-gpubarrierop>gpu.barrier (gpu::BarrierOp)</a></li><li><a href=#gpublock_dim-gpublockdimop>gpu.block_dim (gpu::BlockDimOp)</a></li><li><a href=#gpublock_id-gpublockidop>gpu.block_id (gpu::BlockIdOp)</a></li><li><a href=#gpufunc-gpugpufuncop>gpu.func (gpu::GPUFuncOp)</a></li><li><a href=#gpumodule-gpugpumoduleop>gpu.module (gpu::GPUModuleOp)</a></li><li><a href=#gpugrid_dim-gpugriddimop>gpu.grid_dim (gpu::GridDimOp)</a></li><li><a href=#gpulaunch_func-gpulaunchfuncop>gpu.launch_func (gpu::LaunchFuncOp)</a></li><li><a href=#gpulaunch-gpulaunchop>gpu.launch (gpu::LaunchOp)</a></li><li><a href=#gpumodule_end-gpumoduleendop>gpu.module_end (gpu::ModuleEndOp)</a></li><li><a href=#gpureturn-gpureturnop>gpu.return (gpu::ReturnOp)</a></li><li><a href=#gpushuffle-gpushuffleop>gpu.shuffle (gpu::ShuffleOp)</a></li><li><a href=#gputerminator-gputerminatorop>gpu.terminator (gpu::TerminatorOp)</a></li><li><a href=#gputhread_id-gputhreadidop>gpu.thread_id (gpu::ThreadIdOp)</a></li><li><a href=#gpuyield-gpuyieldop>gpu.yield (gpu::YieldOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=gpuall_reduce-gpuallreduceop>gpu.all_reduce (gpu::AllReduceOp)</h3><p>Reduce values among workgroup.</p><h4 id=description>Description:</h4><p>The &ldquo;all_reduce&rdquo; op reduces the value of every work item across a local
workgroup. The result is equal for all work items of a workgroup.</p><p>For example, both</p><pre><code>  %1 = &quot;gpu.all_reduce&quot;(%0) ({}) { op = &quot;add&quot; } : (f32) -&gt; (f32)
  %2 = &quot;gpu.all_reduce&quot;(%0) ({
  ^bb(%lhs : f32, %rhs : f32):
    %sum = addf %lhs, %rhs : f32
    &quot;gpu.yield&quot;(%sum) : (f32) -&gt; ()
  }) : (f32) -&gt; (f32)
</code></pre><p>compute the sum of each work item&rsquo;s %0 value. The first version specifies
the accumulation as operation, whereas the second version specifies the
accumulation as code region. The accumulation operation must either be
<code>add</code> or <code>mul</code>.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><h4 id=operands>Operands:</h4><ol><li><code>value</code>: any type</li></ol><h4 id=attributes>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>op</code></td><td align=center><code>StringAttr</code></td><td>built-in reduction operations supported by gpu.allreduce. attribute</td></tr></tbody></table><h4 id=results>Results:</h4><ol><li>«unnamed»: any type</li></ol><h3 id=gpubarrier-gpubarrierop>gpu.barrier (gpu::BarrierOp)</h3><p>Synchronizes all work items of a workgroup.</p><h4 id=description-1>Description:</h4><p>The &ldquo;barrier&rdquo; op synchronizes all work items of a workgroup. It is used
to coordinate communication between the work items of the workgroup.</p><pre><code>  gpu.barrier
</code></pre><p>waits until all work items in the workgroup have reached this point
and all memory accesses made by these work items prior to the op are
visible to all work items in the workgroup. Data hazards between work items
accessing the same memory can be avoided by synchronizing work items
in-between these accesses.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><h4 id=operands-1>Operands:</h4><h4 id=attributes-1>Attributes:</h4><h4 id=results-1>Results:</h4><h3 id=gpublock_dim-gpublockdimop>gpu.block_dim (gpu::BlockDimOp)</h3><h4 id=description-2>Description:</h4><h4 id=operands-2>Operands:</h4><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dimension</code></td><td align=center><code>StringAttr</code></td><td>string attribute attribute</td></tr></tbody></table><h4 id=results-2>Results:</h4><ol><li>«unnamed»: index</li></ol><h3 id=gpublock_id-gpublockidop>gpu.block_id (gpu::BlockIdOp)</h3><h4 id=description-3>Description:</h4><h4 id=operands-3>Operands:</h4><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dimension</code></td><td align=center><code>StringAttr</code></td><td>string attribute attribute</td></tr></tbody></table><h4 id=results-3>Results:</h4><ol><li>«unnamed»: index</li></ol><h3 id=gpufunc-gpugpufuncop>gpu.func (gpu::GPUFuncOp)</h3><p>Function executable on a GPU</p><h4 id=description-4>Description:</h4><p>Defines a function that can be executed on a GPU. This supports memory
attribution and its body has a particular execution model.</p><p>GPU functions are either kernels (as indicated by the <code>kernel</code> attribute) or
regular functions. The former can be launched from the host side, while the
latter are device side only.</p><p>The memory attribution defines SSA values that correspond to memory buffers
allocated in the memory hierarchy of the GPU (see below).</p><p>The operation has one attached region that corresponds to the body of the
function. The region arguments consist of the function arguments without
modification, followed by buffers defined in memory annotations. The body of
a GPU function, when launched, is executed by multiple work items. There are
no guarantees on the order in which work items execute, or on the connection
between them. In particular, work items are not necessarily executed in
lock-step. Synchronization ops such as &ldquo;gpu.barrier&rdquo; should be used to
coordinate work items. Declarations of GPU functions, i.e. not having the
body region, are not supported.</p><p>Syntax:</p><pre><code>op ::= `gpu.func` symbol-ref-id `(` argument-list `)` (`-&gt;`
function-result-list)?
       memory-attribution `kernel`? function-attributes? region

memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
    workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span><span class=p>)</span>
    private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;</span><span class=p>)</span>
    kernel
    attributes <span class=p>{</span>qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>{</span>
  gpu<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>The generic form illustrates the concept</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=s>&#34;gpu.func&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>sym_name<span class=p>:</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> kernel<span class=p>,</span> qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>(</span><span class=p>{</span>
<span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span><span class=p>,</span>
     <span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;gpu.return&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=p>}</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
</code></pre></div><p>Note the non-default memory spaces used in memref types in memory
attribution.</p><h4 id=operands-4>Operands:</h4><h4 id=attributes-4>Attributes:</h4><h4 id=results-4>Results:</h4><h3 id=gpumodule-gpugpumoduleop>gpu.module (gpu::GPUModuleOp)</h3><p>A top level compilation unit containing code to be run on a GPU.</p><h4 id=description-5>Description:</h4><p>GPU module contains code that is intended to be run on a GPU. A host device
can launch this code through a gpu.launc_func that creates a fully
qualified symbol through the gpu.module&rsquo;s symbol and a gpu.func symbol
contained in the gpu.module.</p><p>The module&rsquo;s top-level scope is modeled by a single region with a single
block. GPU modules are required to have a name that is used for symbol
resolution by the gpu.launch_func operation.</p><p>Using an op with a region to define a GPU module enables &ldquo;embedding&rdquo; GPU
modules with SIMT execution models in other dialects in a clean manner and
allows filtering of code regions to execute passes on only code intended to
or not intended to be run on the separate device.</p><pre><code>  gpu.module @symbol_name {
  gpu.func {}
    ...
  gpu.module_end
}

</code></pre><h4 id=operands-5>Operands:</h4><h4 id=attributes-5>Attributes:</h4><h4 id=results-5>Results:</h4><h3 id=gpugrid_dim-gpugriddimop>gpu.grid_dim (gpu::GridDimOp)</h3><h4 id=description-6>Description:</h4><h4 id=operands-6>Operands:</h4><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dimension</code></td><td align=center><code>StringAttr</code></td><td>string attribute attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><ol><li>«unnamed»: index</li></ol><h3 id=gpulaunch_func-gpulaunchfuncop>gpu.launch_func (gpu::LaunchFuncOp)</h3><p>Launches a function as a GPU kerneel</p><h4 id=description-7>Description:</h4><p>Launch a kernel function on the specified grid of thread blocks.
<code>gpu.launch</code> operations are lowered to <code>gpu.launch_func</code> operations by
outlining the kernel body into a function in a dedicated module, which
reflects the separate compilation process. The kernel function is required
to have the <code>gpu.kernel</code> attribute. The module containing the kernel
function is required to have the <code>gpu.kernel_module</code> attribute and must be
named. And finally, the module containing the kernel module (which thus
cannot be the top-level module) is required to have the
<code>gpu.container_module</code> attribute. The <code>gpu.launch_func</code> operation has a
string attribute named <code>kernel</code> to specify the name of the kernel function
to launch and an attribute named <code>kernel_module</code> to specify the name of the
module containing that kernel function.</p><p>The operation takes at least six operands, with the first three operands
being grid sizes along x,y,z dimensions and the following three being block
sizes along x,y,z dimensions. When a lower-dimensional kernel is required,
unused sizes must be explicitly set to <code>1</code>. The remaining operands are
passed as arguments to the kernel function.</p><p>A custom syntax for this operation is currently not available.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module attributes <span class=p>{</span>gpu<span class=p>.</span>container_module<span class=p>}</span> <span class=p>{</span>

  <span class=c>// This module creates a separate compilation unit for the GPU compiler.
</span><span class=c></span>  module <span class=nf>@kernels</span> attributes <span class=p>{</span>gpu<span class=p>.</span>kernel_module<span class=p>}</span> <span class=p>{</span>
    <span class=kt>func</span> <span class=nf>@kernel_1</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>)</span>
        attributes <span class=p>{</span> <span class=nl>nvvm.kernel =</span> true <span class=p>}</span> <span class=p>{</span>

      <span class=c>// Operations that produce block/thread IDs and dimensions are
</span><span class=c></span>      <span class=c>// injected when outlining the `gpu.launch` body to a function called
</span><span class=c></span>      <span class=c>// by `gpu.launch_func`.
</span><span class=c></span>      <span class=nv>%tIdX</span> <span class=p>=</span> <span class=s>&#34;gpu.thread_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%tIdY</span> <span class=p>=</span> <span class=s>&#34;gpu.thread_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;y&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%tIdZ</span> <span class=p>=</span> <span class=s>&#34;gpu.thread_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;z&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>

      <span class=nv>%bDimX</span> <span class=p>=</span> <span class=s>&#34;gpu.block_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%bDimY</span> <span class=p>=</span> <span class=s>&#34;gpu.block_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;y&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%bDimZ</span> <span class=p>=</span> <span class=s>&#34;gpu.block_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;z&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>

      <span class=nv>%bIdX</span> <span class=p>=</span> <span class=s>&#34;gpu.block_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%bIdY</span> <span class=p>=</span> <span class=s>&#34;gpu.block_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;y&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%bIdZ</span> <span class=p>=</span> <span class=s>&#34;gpu.block_id&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;z&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>

      <span class=nv>%gDimX</span> <span class=p>=</span> <span class=s>&#34;gpu.grid_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%gDimY</span> <span class=p>=</span> <span class=s>&#34;gpu.grid_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;y&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
      <span class=nv>%gDimZ</span> <span class=p>=</span> <span class=s>&#34;gpu.grid_dim&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>dimension =</span> <span class=s>&#34;z&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>

      <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
      <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=s>&#34;gpu.launch_func&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span>  <span class=c>// Grid sizes.
</span><span class=c></span>                    <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span>  <span class=c>// Block sizes.
</span><span class=c></span>                    <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span>      <span class=c>// Arguments passed to the kernel.
</span><span class=c></span>        <span class=p>{</span> <span class=nl>kernel_module =</span> <span class=nf>@kernels</span><span class=p>,</span>    <span class=c>// Module containing the kernel.
</span><span class=c></span>          <span class=nl>kernel =</span> <span class=s>&#34;kernel_1&#34;</span> <span class=p>}</span>        <span class=c>// Kernel function.
</span><span class=c></span>        <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>)</span>
          <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-7>Operands:</h4><ol><li><code>gridSizeX</code>: integer, index or LLVM dialect equivalent</li><li><code>gridSizeY</code>: integer, index or LLVM dialect equivalent</li><li><code>gridSizeZ</code>: integer, index or LLVM dialect equivalent</li><li><code>blockSizeX</code>: integer, index or LLVM dialect equivalent</li><li><code>blockSizeY</code>: integer, index or LLVM dialect equivalent</li><li><code>blockSizeZ</code>: integer, index or LLVM dialect equivalent</li><li><code>operands</code>: any type</li></ol><h4 id=attributes-7>Attributes:</h4><h4 id=results-7>Results:</h4><h3 id=gpulaunch-gpulaunchop>gpu.launch (gpu::LaunchOp)</h3><p>GPU kernel launch operation</p><h4 id=description-8>Description:</h4><p>Launch a kernel on the specified grid of thread blocks. The body of the
kernel is defined by the single region that this operation contains. The
operation takes six operands, with first three operands being grid sizes
along x,y,z dimensions and the following three arguments being block sizes
along x,y,z dimension. When a lower-dimensional kernel is required,
unused sizes must be explicitly set to <code>1</code>.</p><p>The body region has <em>twelve</em> arguments, grouped as follows:</p><ul><li>three arguments that contain block identifiers along x,y,z dimensions;</li><li>three arguments that contain thread identifiers along x,y,z dimensions;</li><li>operands of the <code>gpu.launch</code> operation as is (i.e. the operands for
grid and block sizes).</li></ul><p>Syntax:</p><pre><code>operation ::= `gpu.launch` `block` `(` ssa-id-list `)` `in` ssa-reassignment
                         `threads` `(` ssa-id-list `)` `in` ssa-reassignment
                           region attr-dict?
ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span><span class=c></span>  <span class=c>// immediately usable inside body region.
</span><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%val1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
<span class=p>}</span>

<span class=c>// Generic syntax explains how the pretty syntax maps to the IR structure.
</span><span class=c></span><span class=s>&#34;gpu.launch&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span>  <span class=c>// Grid sizes.
</span><span class=c></span>             <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>)</span>   <span class=c>// Block sizes.
</span><span class=c></span>
    <span class=p>{</span><span class=err>/</span><span class=p>*</span>attributes<span class=p>*</span><span class=err>/</span><span class=p>}</span>
    <span class=c>// All sizes and identifiers have &#34;index&#34; size.
</span><span class=c></span>    <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
<span class=c>// The operation passes block and thread identifiers, followed by grid and
</span><span class=c></span><span class=c>// block sizes.
</span><span class=c></span><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%num_bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%num_tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.load&#34;</span><span class=p>(</span><span class=nv>%val1</span><span class=p>,</span> <span class=nv>%bx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><p>Rationale: using operation/block arguments gives analyses a clear way of
understanding that a value has additional semantics (e.g., we will need to
know what value corresponds to threadIdx.x for coalescing). We can recover
these properties by analyzing the operations producing values, but it is
easier just to have that information by construction.</p><h4 id=operands-8>Operands:</h4><ol><li><code>gridSizeX</code>: index</li><li><code>gridSizeY</code>: index</li><li><code>gridSizeZ</code>: index</li><li><code>blockSizeX</code>: index</li><li><code>blockSizeY</code>: index</li><li><code>blockSizeZ</code>: index</li></ol><h4 id=attributes-8>Attributes:</h4><h4 id=results-8>Results:</h4><h3 id=gpumodule_end-gpumoduleendop>gpu.module_end (gpu::ModuleEndOp)</h3><p>A pseudo op that marks the end of a gpu.module.</p><h4 id=description-9>Description:</h4><p>This op terminates the only block inside the only region of a <code>gpu.module</code>.</p><h4 id=operands-9>Operands:</h4><h4 id=attributes-9>Attributes:</h4><h4 id=results-9>Results:</h4><h3 id=gpureturn-gpureturnop>gpu.return (gpu::ReturnOp)</h3><p>Terminator for GPU functions.</p><h4 id=description-10>Description:</h4><p>A terminator operation for regions that appear in the body of <code>gpu.func</code>
functions. The operands to the <code>gpu.return</code> are the result values returned
by an incovation of the <code>gpu.func</code>.</p><h4 id=operands-10>Operands:</h4><ol><li><code>operands</code>: any type</li></ol><h4 id=attributes-10>Attributes:</h4><h4 id=results-10>Results:</h4><h3 id=gpushuffle-gpushuffleop>gpu.shuffle (gpu::ShuffleOp)</h3><p>Shuffles values within a subgroup.</p><h4 id=description-11>Description:</h4><p>The &ldquo;shuffle&rdquo; op moves values to a different invocation within the same
subgroup.</p><p>For example</p><pre><code>  %1, %2 = gpu.shuffle %0, %offset, %width xor : f32
</code></pre><p>for lane k returns the value from lane <code>k ^ offset</code> and <code>true</code> if that lane
is smaller than %width. Otherwise it returns an unspecified value and
<code>false</code>. A lane is the index of an invocation relative to its subgroup.</p><p>The width specifies the number of invocations that participate in the
shuffle. The width needs to be the same for all invocations that participate
in the shuffle. Exactly the first <code>width</code> invocations of a subgroup need to
execute this op in convergence.</p><h4 id=operands-11>Operands:</h4><ol><li><code>value</code>: any type</li><li><code>offset</code>: 32-bit signless integer</li><li><code>width</code>: 32-bit signless integer</li></ol><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mode</code></td><td align=center><code>StringAttr</code></td><td>Indexing modes supported by gpu.shuffle. attribute</td></tr></tbody></table><h4 id=results-11>Results:</h4><ol><li><code>result</code>: any type</li><li><code>valid</code>: 1-bit signless integer</li></ol><h3 id=gputerminator-gputerminatorop>gpu.terminator (gpu::TerminatorOp)</h3><p>Terminator for GPU launch regions.</p><h4 id=description-12>Description:</h4><p>A terminator operation for regions that appear in the body of <code>gpu.launch</code>
operation. These regions are not expected to return any value so the
terminator takes no operands.</p><h4 id=operands-12>Operands:</h4><h4 id=attributes-12>Attributes:</h4><h4 id=results-12>Results:</h4><h3 id=gputhread_id-gputhreadidop>gpu.thread_id (gpu::ThreadIdOp)</h3><h4 id=description-13>Description:</h4><h4 id=operands-13>Operands:</h4><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dimension</code></td><td align=center><code>StringAttr</code></td><td>string attribute attribute</td></tr></tbody></table><h4 id=results-13>Results:</h4><ol><li>«unnamed»: index</li></ol><h3 id=gpuyield-gpuyieldop>gpu.yield (gpu::YieldOp)</h3><p>GPU yield operation</p><h4 id=description-14>Description:</h4><p>&ldquo;gpu.yield&rdquo; is a special terminator operation for blocks inside regions
in gpu ops. It returns values to the immediately enclosing gpu op.</p><p>Example:</p><pre><code class=language-gpu.yield data-lang=gpu.yield></code></pre><h4 id=operands-14>Operands:</h4><ol><li><code>values</code>: any type</li></ol><h4 id=attributes-14>Attributes:</h4><h4 id=results-14>Results:</h4><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/FxpMathOps/ title="Dialect 'fxpmath' definition"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect 'fxpmath' definition</a>
<a class="nav nav-next" href=/docs/Dialects/LinalgDoc/ title="Dialect 'linalg' definition">Next - Dialect 'linalg' definition <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li class=active><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/OpenMPOps/>Dialect 'omp' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/ShapeOps/>Dialect 'shape' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>