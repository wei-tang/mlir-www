<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'quant' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/QuantDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'quant' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#type-definition>Type definition</a><ul><li><a href=#uniformquantizedtype>UniformQuantizedType</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#quantconst_fake_quant-quantconstfakequant>quant.const_fake_quant (quant::ConstFakeQuant)</a></li><li><a href=#quantconst_fake_quant_per_axis-quantconstfakequantperaxis>quant.const_fake_quant_per_axis (quant::ConstFakeQuantPerAxis)</a></li><li><a href=#quantcoupled_ref-quantcoupledrefop>quant.coupled_ref (quant::CoupledRefOp)</a></li><li><a href=#quantdcast-quantdequantizecastop>quant.dcast (quant::DequantizeCastOp)</a></li><li><a href=#quantqcast-quantquantizecastop>quant.qcast (quant::QuantizeCastOp)</a></li><li><a href=#quantregion-quantquantizeregionop>quant.region (quant::QuantizeRegionOp)</a></li><li><a href=#quantreturn-quantreturnop>quant.return (quant::ReturnOp)</a></li><li><a href=#quantstats-quantstatisticsop>quant.stats (quant::StatisticsOp)</a></li></ul></li></ul></nav><h2 id=type-definition>Type definition</h2><h3 id=uniformquantizedtype>UniformQuantizedType</h3><h2 id=operation-definition>Operation definition</h2><h3 id=quantconst_fake_quant-quantconstfakequant><code>quant.const_fake_quant</code> (quant::ConstFakeQuant)</h3><p>Simulates the effect of uniform quantization with const range.</p><p>Given a const min, max, num_bits and narrow_range attribute, applies the
same uniform quantization simulation as is done by the TensorFlow
fake_quant_with_min_max_args op. See the fakeQuantAttrsToType() utility
method and the quant-convert-simulated-quantization pass for further details.</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>min</code></td><td align=center>FloatAttr</td><td>32-bit float attribute</td></tr><tr><td align=center><code>max</code></td><td align=center>FloatAttr</td><td>32-bit float attribute</td></tr><tr><td align=center><code>num_bits</code></td><td align=center>IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>narrow_range</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>is_signed</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>tensor of 32-bit float values</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>tensor of 32-bit float values</td></tr></tbody></table><h3 id=quantconst_fake_quant_per_axis-quantconstfakequantperaxis><code>quant.const_fake_quant_per_axis</code> (quant::ConstFakeQuantPerAxis)</h3><p>Simulates the effect of per axis uniform quantization with const range.</p><p>Given a const min, max, num_bits and narrow_range attribute, applies the
same per axis uniform quantization simulation as is done by the TensorFlow
fake_quant_with_min_max_vars_per_channel op. See the fakeQuantAttrsToType()
utility method and the quant-convert-simulated-quantization pass for further
details.</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>min</code></td><td align=center>ArrayAttr</td><td>32-bit float array attribute</td></tr><tr><td align=center><code>max</code></td><td align=center>ArrayAttr</td><td>32-bit float array attribute</td></tr><tr><td align=center><code>axis</code></td><td align=center>IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>num_bits</code></td><td align=center>IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>narrow_range</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>is_signed</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>tensor of 32-bit float values</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>tensor of 32-bit float values</td></tr></tbody></table><h3 id=quantcoupled_ref-quantcoupledrefop><code>quant.coupled_ref</code> (quant::CoupledRefOp)</h3><p>Indicates that one point of the computation is coupled to another.</p><p>Ordinarily, relationships between ops for the purposes of determining
compatible quantized types is explicit based on the use-def chain. However,
in some situations, a use may be separated from its def by arbitrary
external connections. In such a case, during analysis, all coupled_ref
nodes in a module which share a coupledKey will be considered to be
directly connected as via an identity op for the purpose of type inference.</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>coupledKey</code></td><td align=center>StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h3 id=quantdcast-quantdequantizecastop><code>quant.dcast</code> (quant::DequantizeCastOp)</h3><h4 id=operands-3>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h3 id=quantqcast-quantquantizecastop><code>quant.qcast</code> (quant::QuantizeCastOp)</h3><h4 id=operands-4>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>primitive/tensor/vector of real valued primitive (float or quantized type)</td></tr></tbody></table><h3 id=quantregion-quantquantizeregionop><code>quant.region</code> (quant::QuantizeRegionOp)</h3><pre><code>The `region operation wraps high-precision ops as a logical low-precision
quantized kernel.
</code></pre><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input_specs</code></td><td align=center>ArrayAttr</td><td>type array attribute</td></tr><tr><td align=center><code>output_specs</code></td><td align=center>ArrayAttr</td><td>type array attribute</td></tr><tr><td align=center><code>logical_kernel</code></td><td align=center>StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>any type</td></tr></tbody></table><h3 id=quantreturn-quantreturnop><code>quant.return</code> (quant::ReturnOp)</h3><pre><code>The `return` operation terminates a quantize region and returns values.
</code></pre><h4 id=operands-6>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>tensor of any type values</td></tr></tbody></table><h3 id=quantstats-quantstatisticsop><code>quant.stats</code> (quant::StatisticsOp)</h3><p>Identity op which associates statistics with the value.</p><p>Associates statistics about the runtime ranges of values observed for
evaluations of this node.</p><p>Statistics about the entire type are reported in the &lsquo;layerStats&rsquo; attribute
and those for each axis, in the (optional) <code>axisStats</code> attribute. The
interpretation of each is determined by the last dimension of its shape.
Currently, only dim=2 is supported, which is interpreted as [min, max].</p><p><code>layerStats</code> must be a rank 1 tensor: [2]
<code>axisStats</code> must be a rank 2 tensor: [N, 2], where N=the slice size
splitted by the <code>axis</code> dimension. For example:</p>, axis=3 => N=2
, axis=2 => N=6
#### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`layerStats` | ElementsAttr | constant vector/tensor attribute
`axisStats` | ElementsAttr | constant vector/tensor attribute
`axis` | IntegerAttr | 64-bit signless integer attribute
#### Operands:
| Operand | Description |
| :-----: | ----------- |
`arg` | primitive/tensor/vector of real valued primitive (float or quantized type)
#### Results:
| Result | Description |
| :----: | ----------- |
&#171;unnamed&#187; | primitive/tensor/vector of real valued primitive (float or quantized type)
### `quant.stats_ref` (quant::StatisticsRefOp)
Indicates that statistics are resolved by reference.
This op acts as an identity that, when encountered at runtime, should result
in statistics being collected about about the value of its operand/result.
Such statistics will be stored with the provided key, allowing this node
to later be converted to a 'stats' op if statistics with that key have been
encountered.
#### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`statsKey` | StringAttr | string attribute
#### Operands:
| Operand | Description |
| :-----: | ----------- |
`arg` | primitive/tensor/vector of real valued primitive (float or quantized type)
#### Results:
| Result | Description |
| :----: | ----------- |
&#171;unnamed&#187; | primitive/tensor/vector of real valued primitive (float or quantized type)
### `quant.scast` (quant::StorageCastOp)
#### Operands:
| Operand | Description |
| :-----: | ----------- |
`arg` | quant_RealOrStorageValueType
#### Results:
| Result | Description |
| :----: | ----------- |
&#171;unnamed&#187; | quant_RealOrStorageValueType<div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/OpenMPDialect/ title="'omp' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'omp' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/ROCDLDialect/ title="'rocdl' Dialect">Next - 'rocdl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/AffineDialect/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPUDialect/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/LinalgDialect/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li class=active><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SPIRVDialect/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>