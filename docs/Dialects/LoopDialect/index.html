<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'loop' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/LoopDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'loop' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#loopfor-forop>loop.for (ForOp)</a></li><li><a href=#loopif-ifop>loop.if (IfOp)</a></li><li><a href=#loopparallel-parallelop>loop.parallel (ParallelOp)</a></li><li><a href=#loopreduce-reduceop>loop.reduce (ReduceOp)</a></li><li><a href=#loopreducereturn-reducereturnop>loop.reduce.return (ReduceReturnOp)</a></li><li><a href=#loopyield-yieldop>loop.yield (YieldOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=loopfor-forop><code>loop.for</code> (ForOp)&nbsp;<a class=headline-hash href=#loopfor-forop>¶</a></h3><p>for operation</p><p>The &ldquo;loop.for&rdquo; operation represents a loop taking 3 SSA value as operands
that represent the lower bound, upper bound and step respectively. The
operation defines an SSA value for its induction variable. It has one
region capturing the loop body. The induction variable is represented as an
argument of this region. This SSA value always has type index, which is the
size of the machine word. The step is a value of type index, required to be
positive.
The lower and upper bounds specify a half-open range: the range includes
the lower bound but does not include the upper bound.</p><p>The body region must contain exactly one block that terminates with
&ldquo;loop.yield&rdquo;. Calling ForOp::build will create such a region and insert
the terminator implicitly if none is defined, so will the parsing even in
cases when it is absent from the custom format. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>loop<span class=p>.</span>for <span class=nv>%iv</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=c>// body
</span><span class=c></span><span class=p>}</span>
</code></pre></div><p><code>loop.for</code> can also operate on loop-carried variables and returns the final
values after loop termination. The initial values of the variables are
passed as additional SSA operands to the &ldquo;loop.for&rdquo; following the 3 loop
control SSA values mentioned above (lower bound, upper bound and step). The
operation region has equivalent arguments for each variable representing
the value of the variable at the current iteration.</p><p>The region must terminate with a &ldquo;loop.yield&rdquo; that passes all the current
iteration variables to the next iteration, or to the &ldquo;loop.for&rdquo; result, if
at the last iteration. Note, that when the loop-carried variables are
present, calling ForOp::build will not insert the terminator implicitly.
The caller must insert &ldquo;loop.yield&rdquo; in that case.</p><p>&ldquo;loop.for&rdquo; results hold the final values after the last iteration.
For example, to sum-reduce a memref:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@reduce</span><span class=p>(</span><span class=nv>%buffer</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%lb</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
             <span class=nv>%ub</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%step</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Initial sum set to 0.
</span><span class=c></span>  <span class=nv>%sum_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=c>// iter_args binds initial values to the loop&#39;s region arguments.
</span><span class=c></span>  <span class=nv>%sum</span> <span class=p>=</span> loop<span class=p>.</span>for <span class=nv>%iv</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span>
      iter_args<span class=p>(</span><span class=nv>%sum_iter</span> <span class=p>=</span> <span class=nv>%sum_0</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%t</span> <span class=p>=</span> load <span class=nv>%buffer</span><span class=p>[</span><span class=nv>%iv</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%sum_next</span> <span class=p>=</span> addf <span class=nv>%sum_iter</span><span class=p>,</span> <span class=nv>%t</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=c>// Yield current iteration sum to next iteration %sum_iter or to %sum
</span><span class=c></span>    <span class=c>// if final iteration.
</span><span class=c></span>    loop<span class=p>.</span>yield <span class=nv>%sum_next</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%sum</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><p>If the &ldquo;loop.for&rdquo; defines any values, a yield must be explicitly present.
The number and types of the &ldquo;loop.for&rdquo; results must match the initial
values in the &ldquo;iter_args&rdquo; binding and the yield operands.</p><p>Another example with a nested &ldquo;loop.if&rdquo; (see &ldquo;loop.if&rdquo; for details) to
perform conditional reduction:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@conditional_reduce</span><span class=p>(</span><span class=nv>%buffer</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%lb</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
                         <span class=nv>%ub</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%step</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%sum_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=nv>%sum</span> <span class=p>=</span> loop<span class=p>.</span>for <span class=nv>%iv</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span>
      iter_args<span class=p>(</span><span class=nv>%sum_iter</span> <span class=p>=</span> <span class=nv>%sum_0</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%t</span> <span class=p>=</span> load <span class=nv>%buffer</span><span class=p>[</span><span class=nv>%iv</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%cond</span> <span class=p>=</span> cmpf <span class=s>&#34;ugt&#34;</span><span class=p>,</span> <span class=nv>%t</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=nv>%sum_next</span> <span class=p>=</span> loop<span class=p>.</span>if <span class=nv>%cond</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%new_sum</span> <span class=p>=</span> addf <span class=nv>%sum_iter</span><span class=p>,</span> <span class=nv>%t</span> <span class=p>:</span> <span class=k>f32</span>
      loop<span class=p>.</span>yield <span class=nv>%new_sum</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=p>}</span> else <span class=p>{</span>
      loop<span class=p>.</span>yield <span class=nv>%sum_iter</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=p>}</span>
    loop<span class=p>.</span>yield <span class=nv>%sum_next</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%sum</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lowerBound</code></td><td>index</td></tr><tr><td align=center><code>upperBound</code></td><td>index</td></tr><tr><td align=center><code>step</code></td><td>index</td></tr><tr><td align=center><code>initArgs</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=loopif-ifop><code>loop.if</code> (IfOp)&nbsp;<a class=headline-hash href=#loopif-ifop>¶</a></h3><p>if-then-else operation</p><p>The <code>loop.if</code> operation represents an if-then-else construct for
conditionally executing two regions of code. The operand to an if operation
is a boolean value. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>loop<span class=p>.</span>if <span class=nv>%b</span>  <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span> else <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p><code>loop.if</code> may also return results that are defined in its regions. The
values defined are determined by which execution path is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span> <span class=p>=</span> loop<span class=p>.</span>if <span class=nv>%b</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%x_true</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=nv>%y_true</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  loop<span class=p>.</span>yield <span class=nv>%x_true</span><span class=p>,</span> <span class=nv>%y_true</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span>
<span class=p>}</span> else <span class=p>{</span>
  <span class=nv>%x_false</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=nv>%y_false</span> <span class=p>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  loop<span class=p>.</span>yield <span class=nv>%x_false</span><span class=p>,</span> <span class=nv>%y_false</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><p><code>loop.if</code> regions are always terminated with &ldquo;loop.yield&rdquo;. If &ldquo;loop.if&rdquo;
defines no values, the &ldquo;loop.yield&rdquo; can be left out, and will be inserted
implicitly. Otherwise, it must be explicit.
Also, if &ldquo;loop.if&rdquo; defines one or more values, the &lsquo;else&rsquo; block cannot be
omitted.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>loop<span class=p>.</span>if <span class=nv>%b</span>  <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=loopparallel-parallelop><code>loop.parallel</code> (ParallelOp)&nbsp;<a class=headline-hash href=#loopparallel-parallelop>¶</a></h3><p>parallel for operation</p><p>The &ldquo;loop.parallel&rdquo; operation represents a loop nest taking 4 groups of SSA
values as operands that represent the lower bounds, upper bounds, steps and
initial values, respectively. The operation defines a variadic number of
SSA values for its induction variables. It has one region capturing the
loop body. The induction variables are represented as an argument of this
region. These SSA values always have type index, which is the size of the
machine word. The steps are values of type index, required to be positive.
The lower and upper bounds specify a half-open range: the range includes
the lower bound but does not include the upper bound. The initial values
have the same types as results of &ldquo;loop.parallel&rdquo;. If there are no results,
the keyword <code>init</code> can be omitted.</p><p>Semantically we require that the iteration space can be iterated in any
order, and the loop body can be executed in parallel. If there are data
races, the behavior is undefined.</p><p>The parallel loop operation supports reduction of values produced by
individual iterations into a single result. This is modeled using the
loop.reduce operation (see loop.reduce for details). Each result of a
loop.parallel operation is associated with an initial value operand and
reduce operation that is an immediate child. Reductions are matched to
result and initial values in order of their appearance in the body.
Consequently, we require that the body region has the same number of
results and initial values as it has reduce operations.</p><p>The body region must contain exactly one block that terminates with
&ldquo;loop.yield&rdquo; without operands. Parsing ParallelOp will create such a region
and insert the terminator when it is absent from the custom format.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>loop<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%iv</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=nv>%lb</span><span class=p>)</span> to <span class=p>(</span><span class=nv>%ub</span><span class=p>)</span> step <span class=p>(</span><span class=nv>%step</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span> <span class=p>{</span>
  <span class=nv>%zero</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
  loop<span class=p>.</span>reduce<span class=p>(</span><span class=nv>%zero</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>{</span>
    <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%lhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span><span class=p>:</span>
      <span class=nv>%res</span> <span class=p>=</span> addf <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span>
      loop<span class=p>.</span>reduce<span class=p>.</span><span class=kt>return</span> <span class=nv>%res</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lowerBound</code></td><td>index</td></tr><tr><td align=center><code>upperBound</code></td><td>index</td></tr><tr><td align=center><code>step</code></td><td>index</td></tr><tr><td align=center><code>initVals</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=loopreduce-reduceop><code>loop.reduce</code> (ReduceOp)&nbsp;<a class=headline-hash href=#loopreduce-reduceop>¶</a></h3><p>reduce operation for parallel for</p><p>&ldquo;loop.reduce&rdquo; is an operation occurring inside &ldquo;loop.parallel&rdquo; operations.
It consists of one block with two arguments which have the same type as the
operand of &ldquo;loop.reduce&rdquo;.</p><p>&ldquo;loop.reduce&rdquo; is used to model the value for reduction computations of a
&ldquo;loop.parallel&rdquo; operation. It has to appear as an immediate child of a
&ldquo;loop.parallel&rdquo; and is associated with a result value of its parent
operation.</p><p>Association is in the order of appearance in the body where the first
result of a parallel loop operation corresponds to the first &ldquo;loop.reduce&rdquo;
in the operation&rsquo;s body region. The reduce operation takes a single
operand, which is the value to be used in the reduction.</p><p>The reduce operation contains a region whose entry block expects two
arguments of the same type as the operand. As the iteration order of the
parallel loop and hence reduction order is unspecified, the result of
reduction may be non-deterministic unless the operation is associative and
commutative.</p><p>The result of the reduce operation&rsquo;s body must have the same type as the
operands and associated result value of the parallel loop operation.
Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%operand</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1.0</span> <span class=p>:</span> <span class=k>f32</span>
loop<span class=p>.</span>reduce<span class=p>(</span><span class=nv>%operand</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>{</span>
  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%lhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span><span class=p>:</span>
    <span class=nv>%res</span> <span class=p>=</span> addf <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span>
    loop<span class=p>.</span>reduce<span class=p>.</span><span class=kt>return</span> <span class=nv>%res</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>any type</td></tr></tbody></table><h3 id=loopreducereturn-reducereturnop><code>loop.reduce.return</code> (ReduceReturnOp)&nbsp;<a class=headline-hash href=#loopreducereturn-reducereturnop>¶</a></h3><p>terminator for reduce operation</p><p>Syntax:</p><pre><code>operation ::= `loop.reduce.return` $result attr-dict `:` type($result)
</code></pre><p>&ldquo;loop.reduce.return&rdquo; is a special terminator operation for the block inside
&ldquo;loop.reduce&rdquo;. It terminates the region. It should have the same type as
the operand of &ldquo;loop.reduce&rdquo;. Example for the custom format:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>loop<span class=p>.</span>reduce<span class=p>.</span><span class=kt>return</span> <span class=nv>%res</span> <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=loopyield-yieldop><code>loop.yield</code> (YieldOp)&nbsp;<a class=headline-hash href=#loopyield-yieldop>¶</a></h3><p>loop yield and termination operation</p><p>&ldquo;loop.yield&rdquo; yields an SSA value from a loop dialect op region and
terminates the regions. The semantics of how the values are yielded is
defined by the parent operation.
If &ldquo;loop.yield&rdquo; has any operands, the operands must match the parent
operation&rsquo;s results.
If the parent operation defines no values, then the &ldquo;loop.yield&rdquo; may be
left out in the custom syntax and the builders will insert one implicitly.
Otherwise, it has to be present in the syntax to indicate which values are
yielded.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/LLVM/ title="'llvm' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'llvm' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/NVVMDialect/ title="'nvvm' Dialect">Next - 'nvvm' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li class=active><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Interfaces/>MLIR Interfaces</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Traits/>MLIR Operation Traits</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>