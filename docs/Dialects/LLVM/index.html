<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'llvm' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/LLVM/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'llvm' Dialect</h1><p>This dialect wraps the LLVM IR types and instructions into MLIR types and
operations. It provides several additional operations that are necessary to
cover for the differences in the IR structure (e.g., MLIR does not have <code>phi</code>
operations and LLVM IR does not have a <code>constant</code> operation).</p><p>In this document, we use &ldquo;LLVM IR&rdquo; to designate the
<a href=https://llvm.org/docs/LangRef.html>intermediate representation of LLVM</a>
and
&ldquo;LLVM IR <em>dialect</em>&rdquo; to refer to the MLIR dialect reflecting LLVM instructions
and types.</p><p><nav id=TableOfContents><ul><li><a href=#context-and-module-association>Context and Module Association</a></li><li><a href=#types>Types</a></li><li><a href=#operations>Operations</a><ul><li><a href=#llvm-functions>LLVM functions</a></li><li><a href=#llvm-ir-operations>LLVM IR operations</a></li><li><a href=#auxiliary-mlir-operations>Auxiliary MLIR operations</a></li></ul></li></ul></nav><h2 id=context-and-module-association>Context and Module Association</h2><p>The LLVM IR dialect object <em>contains</em> an LLVM Context and an LLVM Module that it
uses to define, print, parse and manage LLVM IR types. These objects can be
obtained from the dialect object using <code>.getLLVMContext()</code> and
<code>getLLVMModule()</code>. All LLVM IR objects that interact with the LLVM IR dialect
must exist in the dialect&rsquo;s context.</p><h2 id=types>Types</h2><p>The LLVM IR dialect defines a single MLIR type, <code>LLVM::LLVMType</code>, that can wrap
any existing LLVM IR type. Its syntax is as follows</p><pre><code>type ::= `!llvm&lt;&quot;` llvm-canonical-type `&quot;&gt;
llvm-canonical-type ::= &lt;canonical textual representation defined by LLVM&gt;
</code></pre><p>For example, one can use primitive types <code>!llvm.i32</code>, pointer types
<code>!llvm&lt;"i8*"></code>, vector types <code>!llvm&lt;"&lt;4 x float>"></code> or structure types
<code>!llvm&lt;"{i32, float}"></code>. The parsing and printing of the canonical form is
delegated to the LLVM assembly parser and printer.</p><p>LLVM IR dialect types contain an <code>llvm::Type*</code> object that can be obtained by
calling <code>.getUnderlyingType()</code> and used in LLVM API calls directly. These
objects are allocated within the LLVM context associated with the LLVM IR
dialect and may be linked to the properties of the associated LLVM module.</p><p>LLVM IR dialect type can be constructed from any <code>llvm::Type*</code> that is
associated with the LLVM context of the dialect. In this document, we use the
term &ldquo;wrapped LLVM IR type&rdquo; to refer to the LLVM IR dialect type containing a
specific LLVM IR type.</p><h2 id=operations>Operations</h2><p>All operations in the LLVM IR dialect have a custom form in MLIR. The mnemonic
of an operation is that used in LLVM IR prefixed with &ldquo;<code>llvm.</code>&rdquo;.</p><h3 id=llvm-functions>LLVM functions</h3><p>MLIR functions are defined by an operation that is not built into the IR itself.
The LLVM IR dialect provides an <code>llvm.func</code> operation to define functions
compatible with LLVM IR. These functions have wrapped LLVM IR function type but
use MLIR syntax to express it. They are required to have exactly one result
type. LLVM function operation is intended to capture additional properties of
LLVM functions, such as linkage and calling convention, that may be modeled
differently by the built-in MLIR function.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// The type of @bar is !llvm&lt;&#34;i64 (i64)&#34;&gt;
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=p>}</span>

<span class=c>// Type type of @foo is !llvm&lt;&#34;void (i64)&#34;&gt;
</span><span class=c></span><span class=c>// !llvm.void type is omitted
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

<span class=c>// A function with `internal` linkage.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> internal <span class=nf>@internal_func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

</code></pre></div><h4 id=attribute-pass-through>Attribute pass-through</h4><p>An LLVM IR dialect function provides a mechanism to forward function-level
attributes to LLVM IR using the <code>passthrough</code> attribute. This is an array
attribute containing either string attributes or array attributes. In the former
case, the value of the string is interpreted as the name of LLVM IR function
attribute. In the latter case, the array is expected to contain exactly two
string attributes, the first corresponding to the name of LLVM IR function
attribute, and the second corresponding to its value. Note that even integer
LLVM IR function attributes have their value represented in the string form.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@func</span><span class=p>(</span><span class=p>)</span> attributes <span class=p>{</span>
  <span class=nl>passthrough =</span> <span class=p>[</span><span class=s>&#34;noinline&#34;</span><span class=p>,</span>           <span class=c>// value-less attribute
</span><span class=c></span>                 <span class=p>[</span><span class=s>&#34;alignstack&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span><span class=p>]</span><span class=p>,</span>  <span class=c>// integer attribute with value
</span><span class=c></span>                 <span class=p>[</span><span class=s>&#34;other&#34;</span><span class=p>,</span> <span class=s>&#34;attr&#34;</span><span class=p>]</span><span class=p>]</span>    <span class=c>// attribute unknown to LLVM
</span><span class=c></span><span class=p>}</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>If the attribute is not known to LLVM IR, it will be attached as a string
attribute.</p><h3 id=llvm-ir-operations>LLVM IR operations</h3><p>The following operations are currently supported. The semantics of these
operations corresponds to the semantics of the similarly-named LLVM IR
instructions.</p><h4 id=integer-binary-arithmetic-operations>Integer binary arithmetic operations</h4><p>Take two arguments of wrapped LLVM IR integer type, produce one value of the
same type.</p><ul><li><code>add</code></li><li><code>sub</code></li><li><code>mul</code></li><li><code>udiv</code></li><li><code>sdiv</code></li><li><code>urem</code></li><li><code>srem</code></li></ul><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer addition.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// Unsigned integer division.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>udiv <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
</code></pre></div><h4 id=floating-point-binary-arithmetic-operations>Floating point binary arithmetic operations</h4><p>Take two arguments of wrapped LLVM IR floating point type, produce one value of
the same type.</p><ul><li><code>fadd</code></li><li><code>fsub</code></li><li><code>fmul</code></li><li><code>fdiv</code></li><li><code>frem</code></li></ul><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Float addition.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>fadd <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float

<span class=c>// Float division.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>fdiv <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float
</code></pre></div><h4 id=memory-related-operations>Memory-related operations</h4><ul><li><code>&lt;r> = alloca &lt;size> x &lt;type></code></li><li><code>&lt;r> = getelementptr &lt;address>[&lt;index> (, &lt;index>)+]</code></li><li><code>&lt;r> = load &lt;address></code></li><li><code>store &lt;value>, &lt;address></code></li></ul><p>In these operations, <code>&lt;size></code> must be a value of wrapped LLVM IR integer type,
<code>&lt;address></code> must be a value of wrapped LLVM IR pointer type, and <code>&lt;value></code> must
be a value of wrapped LLVM IR type that corresponds to the pointer type of
<code>&lt;address></code>.</p><p>The <code>index</code> operands are integer values whose semantics is identical to the
non-pointer arguments of LLVM IR&rsquo;s <code>getelementptr</code>.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocate an array of 4 floats on stack
</span><span class=c></span><span class=nv>%c4</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>4</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>alloca <span class=nv>%c4</span> <span class=p>x</span> <span class=p>!</span>llvm<span class=p>.</span>float <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>

<span class=c>// Get the second element of the array (note 0-based indexing).
</span><span class=c></span><span class=nv>%c1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%c1</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span>
                                   <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>

<span class=c>// Store a constant into this element.
</span><span class=c></span><span class=nv>%cf</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float
llvm<span class=p>.</span>store <span class=nv>%cf</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>

<span class=c>// Load the value from this element.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;float*&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operations-on-values-of-aggregate-type>Operations on values of aggregate type.</h4><ul><li><code>&lt;value> = extractvalue &lt;struct>[&lt;index> (, &lt;index>)+]</code></li><li><code>&lt;struct> = insertvalue &lt;value>, &lt;struct>[&lt;index> (, &lt;index>)+]</code></li></ul><p>In these operations, <code>&lt;struct></code> must be a value of wrapped LLVM IR structure
type and <code>&lt;value></code> must be a value that corresponds to one of the (nested)
structure element types.</p><p>Note the use of integer literals to designate subscripts, which is made possible
by <code>extractvalue</code> and <code>insertvalue</code> must have constant subscripts. Internally,
they are modeled as array attributes.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Get the value third element of the second element of a structure.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%s</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, {i1, i8, i16}&#34;</span><span class=p>&gt;</span>

<span class=c>// Insert the value to the third element of the second element of a structure.
</span><span class=c></span><span class=c>// Note that this returns a new structure-typed value.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%0</span><span class=p>,</span> <span class=nv>%s</span><span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, {i1, i8, i16}&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=terminator-operations>Terminator operations.</h4><p>Branch operations:</p><ul><li><code>br [&lt;successor>(&lt;operands>)]</code></li><li><code>cond_br &lt;condition> [&lt;true-successor>(&lt;true-operands>),</code>
<code>&lt;false-successor>(&lt;false-operands>)]</code></li></ul><p>In order to comply with MLIR design, branch operations in the LLVM IR dialect
pass arguments to basic blocks. Successors must be valid block MLIR identifiers
and operand lists for each of them must have the same types as the arguments of
the respective blocks. <code>&lt;condition></code> must be a wrapped LLVM IR <code>i1</code> type.</p><p>Since LLVM IR uses the name of the predecessor basic block to identify the
sources of a PHI node, it is invalid for two entries of the PHI node to indicate
different values coming from the same block. Therefore, <code>cond_br</code> in the LLVM IR
dialect disallows its successors to be the same block <em>if</em> this block has
arguments.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Branch without arguments.
</span><span class=c></span><span class=nl>^bb0</span><span class=p>:</span>
  llvm<span class=p>.</span>br <span class=nl>^bb0
</span><span class=nl>
</span><span class=nl></span><span class=c>// Branch and pass arguments.
</span><span class=c></span><span class=nl>^bb1</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span><span class=p>:</span>
  llvm<span class=p>.</span>br <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%arg</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span>

<span class=c>// Conditionally branch and pass arguments to one of the blocks.
</span><span class=c></span>llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb0</span><span class=p>,</span> <span class=nv>%bb1</span><span class=p>(</span><span class=nv>%arg</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span>

<span class=c>// It&#39;s okay to use the same block without arguments, but probably useless.
</span><span class=c></span>llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb0</span><span class=p>,</span> <span class=nl>^bb0
</span><span class=nl>
</span><span class=nl></span><span class=c>// ERROR: Passing different arguments to the same block in a conditional branch.
</span><span class=c></span>llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span>

</code></pre></div><p>Call operations:</p><ul><li><code>&lt;r> = call(&lt;operands>)</code></li><li><code>call(&lt;operands>)</code></li></ul><p>In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect implements
this behavior by providing a variadic <code>call</code> operation for 0- and 1-result
functions. Even though MLIR supports multi-result functions, LLVM IR dialect
disallows them.</p><p>The <code>call</code> instruction supports both direct and indirect calls. Direct calls
start with a function name (<code>@</code>-prefixed) and indirect calls start with an SSA
value (<code>%</code>-prefixed). The direct callee, if present, is stored as a function
attribute <code>callee</code>. The trailing type of the instruction is always the MLIR
function type, which may be different from the indirect callee that has the
wrapped LLVM IR function type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Direct call without arguments and with one result.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span>

<span class=c>// Direct call with arguments and without a result.
</span><span class=c></span>llvm<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>

<span class=c>// Indirect call with an argument and without a result.
</span><span class=c></span>llvm<span class=p>.</span>call <span class=nv>%1</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
</code></pre></div><h4 id=miscellaneous-operations>Miscellaneous operations.</h4><p>Integer comparisons: <code>icmp "predicate" &lt;lhs>, &lt;rhs></code>. The following predicate
values are supported:</p><ul><li><code>eq</code> - equality comparison;</li><li><code>ne</code> - inequality comparison;</li><li><code>slt</code> - signed less-than comparison</li><li><code>sle</code> - signed less-than-or-equal comparison</li><li><code>sgt</code> - signed greater-than comparison</li><li><code>sge</code> - signed greater-than-or-equal comparison</li><li><code>ult</code> - unsigned less-than comparison</li><li><code>ule</code> - unsigned less-than-or-equal comparison</li><li><code>ugt</code> - unsigned greater-than comparison</li><li><code>uge</code> - unsigned greater-than-or-equal comparison</li></ul><p>Bitwise reinterpretation: <code>bitcast &lt;value></code>.</p><p>Selection: <code>select &lt;condition>, &lt;lhs>, &lt;rhs></code>.</p><h3 id=auxiliary-mlir-operations>Auxiliary MLIR operations</h3><p>These operations do not have LLVM IR counterparts but are necessary to map LLVM
IR into MLIR. They should be prefixed with <code>llvm.mlir</code>.</p><h4 id=llvmmliraddressof><code>llvm.mlir.addressof</code></h4><p>Creates an SSA value containing a pointer to a global variable or constant
defined by <code>llvm.mlir.global</code>. The global value can be defined after its first
referenced. If the global value is a constant, storing into it is not allowed.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Get the address of a global.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>

  <span class=c>// Use it as a regular pointer.
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
<span class=p>}</span>

<span class=c>// Define the global.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@const</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
</code></pre></div><h4 id=llvmmlirconstant><code>llvm.mlir.constant</code></h4><p>Unlike LLVM IR, MLIR does not have first-class constant values. Therefore, all
constants must be created as SSA values before being used in other operations.
<code>llvm.mlir.constant</code> creates such values for scalars and vectors. It has a
mandatory <code>value</code> attribute, which may be an integer, floating point attribute;
dense or sparse attribute containing integers or floats. The type of the
attribute is one the corresponding MLIR standard types. It may be omitted for
<code>i64</code> and <code>f64</code> types that are implied. The operation produces a new SSA value
of the specified LLVM IR dialect type. The type of that value <em>must</em> correspond
to the attribute type converted to LLVM IR.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant, internal i32 is mandatory
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// It&#39;s okay to omit i64.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=c>// Floating point constant.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float

<span class=c>// Splat dense vector constant.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;&lt;4 x float&gt;&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=llvmmlirglobal><code>llvm.mlir.global</code></h4><p>Since MLIR allows for arbitrary operations to be present at the top level,
global variables are defined using the <code>llvm.mlir.global</code> operation. Both global
constants and variables can be defined, and the value may also be initialized in
both cases.</p><p>There are two forms of initialization syntax. Simple constants that can be
represented as MLIR attributes can be given in-line:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float
</code></pre></div><p>This initialization and type syntax is similar to <code>llvm.mlir.constant</code> and may
use two types: one for MLIR attribute and another for the LLVM value. These
types must be compatible.</p><p>More complex constants that cannot be represented as MLIR attributes can be
given in an initializer region:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// This global is initialized with the equivalent of:
</span><span class=c></span><span class=c>//   i32* getelementptr (i32* @g2, i32 2)
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
  <span class=c>// The initializer region must end with `llvm.return`.
</span><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Only one of the initializer attribute or initializer region may be provided.</p><p><code>llvm.mlir.global</code> must appear at top-level of the enclosing module. It uses an
@-identifier for its value, which will be uniqued by the module with respect to
other @-identifiers in it.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Global values use @-identifiers.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@cst</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// Non-constant values must also be initialized.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float

<span class=c>// Strings are expected to be of wrapped LLVM i8 array type and do not
</span><span class=c></span><span class=c>// automatically include the trailing zero.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@string</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;[3 x i8]&#34;</span><span class=p>&gt;</span>

<span class=c>// For strings globals, the trailing type may be omitted.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@no_trailing_type</span><span class=p>(</span><span class=s>&#34;foo bar&#34;</span><span class=p>)</span>

<span class=c>// A complex initializer is constructed with an initializer region.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i32*&#34;</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><h4 id=llvmmlirnull><code>llvm.mlir.null</code></h4><p>Unlike LLVM IR, MLIR does not have first-class null pointers. They must be
explicitly created as SSA values using <code>llvm.mlir.null</code>. This operation has
operands or attributes, and returns a null value of a wrapped LLVM IR pointer
type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Null pointer to i8 value.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span>

<span class=c>// Null pointer to a function with signature void() value.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;void()*&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=llvmmlirundef><code>llvm.mlir.undef</code></h4><p>Unlike LLVM IR, MLIR does not have first-class undefined values. Such values
must be created as SSA values using <code>llvm.mlir.undef</code>. This operation has no
operands or attributes. It creates an undefined value of the specified LLVM IR
dialect type wrapping an LLVM IR structure type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create a structure with a 32-bit integer followed by a float.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{i32, float}&#34;</span><span class=p>&gt;</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Linalg/ title="'linalg' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'linalg' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/LoopDialect/ title="'loop' Dialect">Next - 'loop' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li class=active><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>