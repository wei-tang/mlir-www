<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'std' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/Standard/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'std' Dialect</h1><p>This dialect provides documentation for operations within the Standard dialect.</p><p>Note: This dialect is a collection of operations for several different concepts,
and should be split into multiple more-focused dialects accordingly.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#stdabsf-absfop>std.absf (AbsFOp)</a></li><li><a href=#stdaddf-addfop>std.addf (AddFOp)</a></li><li><a href=#stdaddi-addiop>std.addi (AddIOp)</a></li><li><a href=#stdalloc-allocop>std.alloc (AllocOp)</a></li><li><a href=#stdalloca-allocaop>std.alloca (AllocaOp)</a></li><li><a href=#stdand-andop>std.and (AndOp)</a></li><li><a href=#stdassume_alignment-assumealignmentop>std.assume_alignment (AssumeAlignmentOp)</a></li><li><a href=#stdatomic_rmw-atomicrmwop>std.atomic_rmw (AtomicRMWOp)</a></li><li><a href=#stdbr-branchop>std.br (BranchOp)</a></li><li><a href=#stdcall_indirect-callindirectop>std.call_indirect (CallIndirectOp)</a></li><li><a href=#stdcall-callop>std.call (CallOp)</a></li><li><a href=#stdceilf-ceilfop>std.ceilf (CeilFOp)</a></li><li><a href=#stdcmpf-cmpfop>std.cmpf (CmpFOp)</a></li><li><a href=#stdcmpi-cmpiop>std.cmpi (CmpIOp)</a></li><li><a href=#stdcond_br-condbranchop>std.cond_br (CondBranchOp)</a></li><li><a href=#stdconstant-constantop>std.constant (ConstantOp)</a></li><li><a href=#stdcopysign-copysignop>std.copysign (CopySignOp)</a></li><li><a href=#stdcos-cosop>std.cos (CosOp)</a></li><li><a href=#stddealloc-deallocop>std.dealloc (DeallocOp)</a></li><li><a href=#stddim-dimop>std.dim (DimOp)</a></li><li><a href=#stddivf-divfop>std.divf (DivFOp)</a></li><li><a href=#stdexp2-exp2op>std.exp2 (Exp2Op)</a></li><li><a href=#stdexp-expop>std.exp (ExpOp)</a></li><li><a href=#stdextract_element-extractelementop>std.extract_element (ExtractElementOp)</a></li><li><a href=#stdfpext-fpextop>std.fpext (FPExtOp)</a></li><li><a href=#stdfptrunc-fptruncop>std.fptrunc (FPTruncOp)</a></li><li><a href=#stdindex_cast-indexcastop>std.index_cast (IndexCastOp)</a></li><li><a href=#stdload-loadop>std.load (LoadOp)</a></li><li><a href=#stdlog10-log10op>std.log10 (Log10Op)</a></li><li><a href=#stdlog2-log2op>std.log2 (Log2Op)</a></li><li><a href=#stdlog-logop>std.log (LogOp)</a></li><li><a href=#stdmemref_cast-memrefcastop>std.memref_cast (MemRefCastOp)</a></li><li><a href=#stdmulf-mulfop>std.mulf (MulFOp)</a></li><li><a href=#stdmuli-muliop>std.muli (MulIOp)</a></li><li><a href=#stdnegf-negfop>std.negf (NegFOp)</a></li><li><a href=#stdor-orop>std.or (OrOp)</a></li><li><a href=#stdprefetch-prefetchop>std.prefetch (PrefetchOp)</a></li><li><a href=#stdrank-rankop>std.rank (RankOp)</a></li><li><a href=#stdremf-remfop>std.remf (RemFOp)</a></li><li><a href=#stdreturn-returnop>std.return (ReturnOp)</a></li><li><a href=#stdrsqrt-rsqrtop>std.rsqrt (RsqrtOp)</a></li><li><a href=#stdsitofp-sitofpop>std.sitofp (SIToFPOp)</a></li><li><a href=#stdselect-selectop>std.select (SelectOp)</a></li><li><a href=#stdshift_left-shiftleftop>std.shift_left (ShiftLeftOp)</a></li><li><a href=#stdsexti-signextendiop>std.sexti (SignExtendIOp)</a></li><li><a href=#stddivi_signed-signeddiviop>std.divi_signed (SignedDivIOp)</a></li><li><a href=#stdremi_signed-signedremiop>std.remi_signed (SignedRemIOp)</a></li><li><a href=#stdshift_right_signed-signedshiftrightop>std.shift_right_signed (SignedShiftRightOp)</a></li><li><a href=#stdsplat-splatop>std.splat (SplatOp)</a></li><li><a href=#stdsqrt-sqrtop>std.sqrt (SqrtOp)</a></li><li><a href=#stdstore-storeop>std.store (StoreOp)</a></li><li><a href=#stdsubf-subfop>std.subf (SubFOp)</a></li><li><a href=#stdsubi-subiop>std.subi (SubIOp)</a></li><li><a href=#stdsubview-subviewop>std.subview (SubViewOp)</a></li><li><a href=#stdtanh-tanhop>std.tanh (TanhOp)</a></li><li><a href=#stdtensor_cast-tensorcastop>std.tensor_cast (TensorCastOp)</a></li><li><a href=#stdtensor_load-tensorloadop>std.tensor_load (TensorLoadOp)</a></li><li><a href=#stdtensor_store-tensorstoreop>std.tensor_store (TensorStoreOp)</a></li><li><a href=#stdtrunci-truncateiop>std.trunci (TruncateIOp)</a></li><li><a href=#stddivi_unsigned-unsigneddiviop>std.divi_unsigned (UnsignedDivIOp)</a></li><li><a href=#stdremi_unsigned-unsignedremiop>std.remi_unsigned (UnsignedRemIOp)</a></li><li><a href=#stdshift_right_unsigned-unsignedshiftrightop>std.shift_right_unsigned (UnsignedShiftRightOp)</a></li><li><a href=#stdview-viewop>std.view (ViewOp)</a></li><li><a href=#stdxor-xorop>std.xor (XOrOp)</a></li><li><a href=#stdzexti-zeroextendiop>std.zexti (ZeroExtendIOp)</a></li><li><a href=#dma_start-operation>&lsquo;dma_start&rsquo; operation</a></li><li><a href=#dma_wait-operation>&lsquo;dma_wait&rsquo; operation</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=stdabsf-absfop><code>std.absf</code> (AbsFOp)</h3><p>floating point absolute-value operation</p><p>The <code>absf</code> operation computes the absolute value. It takes one operand and
returns one result of the same type. This type may be a float scalar type,
a vector whose element type is float, or a tensor of floats.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar absolute value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> absf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise absolute value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> absf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise absolute value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> absf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdaddf-addfop><code>std.addf</code> (AddFOp)</h3><p>floating point addition operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.addf` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>addf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdaddi-addiop><code>std.addi</code> (AddIOp)</h3><p>integer addition operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.addi` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>addi</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar
type, a vector whose element type is integer, or a tensor of integers. It
has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-2>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdalloc-allocop><code>std.alloc</code> (AllocOp)</h3><p>memory allocation operation</p><p>The <code>alloc</code> operation allocates a region of memory, as specified by its
memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the ssa value &lsquo;%d&rsquo; is
bound to the second dimension of the memref (which is dynamic).</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%d</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of symbol operands are bound to the symbols of the
memrefs affine map. In the example below, the ssa value &lsquo;%s&rsquo; is bound to
the symbol &lsquo;s0&rsquo; in the affine map specified in the allocs memref type.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span><span class=p>[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span>
                          affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>)</span><span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>This operation returns a single ssa value of memref type, which can be used
by subsequent load and store operations.</p><p>The optional <code>alignment</code> attribute may be specified to ensure that the
region of memory that will be indexed is aligned at the specified byte
boundary.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span><span class=p>[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>{</span><span class=nl>alignment =</span> <span class=m>8</span><span class=p>}</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>)</span><span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>index</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>memref of any type values</td></tr></tbody></table><h3 id=stdalloca-allocaop><code>std.alloca</code> (AllocaOp)</h3><p>stack memory allocation operation</p><p>The <code>alloca</code> operation allocates memory on the stack, to be automatically
released when the stack frame is discarded. The amount of memory allocated
is specified by its memref and additional operands. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloca<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the SSA value &lsquo;%d&rsquo; is
bound to the second dimension of the memref (which is dynamic).</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloca<span class=p>(</span><span class=nv>%d</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of symbol operands are bound to the symbols of the
memref&rsquo;s affine map. In the example below, the SSA value &lsquo;%s&rsquo; is bound to
the symbol &lsquo;s0&rsquo; in the affine map specified in the allocs memref type.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloca<span class=p>(</span><span class=p>)</span><span class=p>[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span>
                           affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>)</span><span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><p>This operation returns a single SSA value of memref type, which can be used
by subsequent load and store operations. An optional alignment attribute, if
specified, guarantees alignment at least to that boundary. If not specified,
an alignment on any convenient boundary compatible with the type will be
chosen.</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>memref of any type values</td></tr></tbody></table><h3 id=stdand-andop><code>std.and</code> (AndOp)</h3><p>integer binary and</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.and` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>and</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise and.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> and <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> and <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> and <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-5>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdassume_alignment-assumealignmentop><code>std.assume_alignment</code> (AssumeAlignmentOp)</h3><p>assertion that gives alignment information to the input memref</p><p>Syntax:</p><pre><code>operation ::= `std.assume_alignment` $memref `,` $alignment attr-dict `:` type($memref)
</code></pre><p>The <code>assume_alignment</code> operation takes a memref and an integer of alignment
value, and internally annotates the buffer with the given alignment. If
the buffer isn&rsquo;t aligned to the given alignment, the behavior is undefined.</p><p>This operation doesn&rsquo;t affect the semantics of a correct program. It&rsquo;s for
optimization only, and the optimization is best-effort.</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>IntegerAttr</td><td>32-bit signless integer attribute whose value is positive</td></tr></tbody></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=stdatomic_rmw-atomicrmwop><code>std.atomic_rmw</code> (AtomicRMWOp)</h3><p>atomic read-modify-write operation</p><p>Syntax:</p><pre><code>operation ::= `std.atomic_rmw` $kind $value `,` $memref `[` $indices `]` attr-dict `:` `(` type($value) `,`
              type($memref) `)` `-&gt;` type($result)
</code></pre><p>The <code>atomic_rmw</code> operation provides a way to perform a read-modify-write
sequence that is free from data races. The kind enumeration specifies the
modification to perform. The value operand represents the new value to be
applied during the modification. The memref operand represents the buffer
that the read and write will be performed against, as accessed by the
specified indices. The arity of the indices is the rank of the memref. The
result represents the latest value that was stored.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> atomic_rmw <span class=s>&#34;addf&#34;</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</code></pre></div><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>kind</code></td><td align=center>IntegerAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless integer or floating-point</td></tr><tr><td align=center><code>memref</code></td><td>memref of signless integer or floating-point values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or floating-point</td></tr></tbody></table><h3 id=stdbr-branchop><code>std.br</code> (BranchOp)</h3><p>branch operation</p><p>Syntax:</p><pre><code>operation ::= `std.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
</code></pre><p>The <code>br</code> operation represents a branch operation in a function.
The operation takes variable number of operands and produces no results.
The operand number and types for each successor must match the arguments of
the block successor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nl>^bb2</span><span class=p>:</span>
  <span class=nv>%2</span> <span class=p>=</span> call <span class=nf>@someFn</span><span class=p>(</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%3</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
</code></pre></div><h4 id=operands-8>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>destOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors>Successors:</h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=stdcall_indirect-callindirectop><code>std.call_indirect</code> (CallIndirectOp)</h3><p>indirect call operation</p><p>Syntax:</p><pre><code>operation ::= `std.call_indirect` $callee `(` $operands `)` attr-dict `:` type($callee)
</code></pre><p>The <code>call_indirect</code> operation represents an indirect call to a value of
function type. Functions are first class types in MLIR, and may be passed as
arguments and merged together with block arguments. The operands and result
types of the call must match the specified function type.</p><p>Function values can be created with the
<a href=#constant-operation><code>constant</code> operation</a>
.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%31</span> <span class=p>=</span> call_indirect <span class=nv>%15</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
        <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-9>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>callee</code></td><td>function type</td></tr><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=stdcall-callop><code>std.call</code> (CallOp)</h3><p>call operation</p><p>Syntax:</p><pre><code>operation ::= `std.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>call</code> operation represents a direct call to a function that is within
the same symbol scope as the call. The operands and result types of the
call must match the specified function type. The callee is encoded as a
symbol reference attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%2</span> <span class=p>=</span> call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</code></pre></div><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>callee</code></td><td align=center>FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdceilf-ceilfop><code>std.ceilf</code> (CeilFOp)</h3><p>ceiling of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.ceilf` ssa-use `:` type
</code></pre><p>The <code>ceilf</code> operation computes the ceiling of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar ceiling value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> ceilf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise ceiling value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> ceilf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise ceiling value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> ceilf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-11>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdcmpf-cmpfop><code>std.cmpf</code> (CmpFOp)</h3><p>floating-point comparison operation</p><p>Syntax:</p><pre><code>operation ::= `std.cmpf` $predicate `,` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpf</code> operation compares its two operands according to the float
comparison rules and the predicate specified by the respective attribute.
The predicate defines the type of comparison: (un)orderedness, (in)equality
and signed less/greater than (or equal to) as well as predicates that are
always true or false. The operands must have the same type, and this type
must be a float type, or a vector or tensor thereof. The result is an i1,
or a vector/tensor thereof having the same shape as the inputs. Unlike cmpi,
the operands are always treated as signed. The u prefix indicates
<em>unordered</em> comparison, not unsigned comparison, so &ldquo;une&rdquo; means unordered or
not equal. For the sake of readability by humans, custom assembly form for
the operation uses a string-typed attribute for the predicate. The value of
this attribute corresponds to lower-cased name of the predicate constant,
e.g., &ldquo;one&rdquo; means &ldquo;ordered not equal&rdquo;. The string representation of the
attribute is merely a syntactic sugar and is converted to an integer
attribute by the parser.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%r1</span> <span class=p>=</span> cmpf <span class=s>&#34;oeq&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
<span class=nv>%r2</span> <span class=p>=</span> cmpf <span class=s>&#34;ult&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>42x42x</span><span class=k>f64</span><span class=p>&gt;</span>
<span class=nv>%r3</span> <span class=p>=</span> <span class=s>&#34;std.cmpf&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>{</span>predicate<span class=p>:</span> <span class=m>0</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>f8<span class=p>,</span> f8<span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</code></pre></div><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td align=center>IntegerAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</td></tr></tbody></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=stdcmpi-cmpiop><code>std.cmpi</code> (CmpIOp)</h3><p>integer comparison operation</p><p>Syntax:</p><pre><code>operation ::= `std.cmpi` $predicate `,` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two
arguments can be integers, vectors or tensors thereof as long as their types
match. The operation produces an i1 for the former case, a vector or a
tensor of i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is
performed. The following comparisons are supported:</p><ul><li>equal (mnemonic: <code>"eq"</code>; integer value: <code>0</code>)</li><li>not equal (mnemonic: <code>"ne"</code>; integer value: <code>1</code>)</li><li>signed less than (mnemonic: <code>"slt"</code>; integer value: <code>2</code>)</li><li>signed less than or equal (mnemonic: <code>"sle"</code>; integer value: <code>3</code>)</li><li>signed greater than (mnemonic: <code>"sgt"</code>; integer value: <code>4</code>)</li><li>signed greater than or equal (mnemonic: <code>"sge"</code>; integer value: <code>5</code>)</li><li>unsigned less than (mnemonic: <code>"ult"</code>; integer value: <code>6</code>)</li><li>unsigned less than or equal (mnemonic: <code>"ule"</code>; integer value: <code>7</code>)</li><li>unsigned greater than (mnemonic: <code>"ugt"</code>; integer value: <code>8</code>)</li><li>unsigned greater than or equal (mnemonic: <code>"uge"</code>; integer value: <code>9</code>)</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or
tensor operands, the comparison is performed elementwise and the element of
the result indicates whether the comparison is true for the operand elements
with the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying
attribute has integer type (or rather enum class in C++ code) as seen from
the generic assembly form. String literals are used to improve readability
of the IR by humans.</p><p>This operation only applies to integer-like operands, but not floats. The
main reason being that comparison operations have diverging sets of
attributes: integers require sign specification while floats require various
floating point-related particularities, e.g., <code>-ffast-math</code> behavior,
IEEE754 compliance, etc
(
<a href=/docs/Rationale/#splitting-floating-point-vs-integer-operations>rationale</a>
).
The type of comparison is specified as attribute to avoid introducing ten
similar operations, taking into account that they are often implemented
using the same operation downstream
(
<a href=/docs/Rationale/#specifying-comparison-kind-as-attribute>rationale</a>
). The
separation between signed and unsigned order comparisons is necessary
because of integers being signless. The comparison operation must know how
to interpret values with the foremost bit being set: negatives in two&rsquo;s
complement or large positives
(
<a href=/docs/Rationale/#specifying-sign-in-integer-comparison-operations>rationale</a>
).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar &#34;signed less than&#34; comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;slt&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>

<span class=c>// Custom form of vector equality comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td align=center>IntegerAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</td></tr></tbody></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=stdcond_br-condbranchop><code>std.cond_br</code> (CondBranchOp)</h3><p>conditional branch operation</p><p>Syntax:</p><pre><code>operation ::= `std.cond_br` $condition `,`
              $trueDest (`(` $trueDestOperands^ `:` type($trueDestOperands) `)`)? `,`
              $falseDest (`(` $falseDestOperands^ `:` type($falseDestOperands) `)`)?
              attr-dict
</code></pre><p>The <code>cond_br</code> terminator operation represents a conditional branch on a
boolean (1-bit integer) value. If the bit is set, then the first destination
is jumped to; if it is false, the second destination is chosen. The count
and types of operands must align with the arguments in the corresponding
target blocks.</p><p>The MLIR conditional branch operation is not allowed to target the entry
block for a region. The two destinations of the conditional branch operation
are allowed to be the same.</p><p>The following example illustrates a function with a conditional branch
operation that targets the same block.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@select</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%b</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%flag</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
  <span class=c>// Both targets are the same, operands differ
</span><span class=c></span>  cond_br <span class=nv>%flag</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>

<span class=nl>^bb1</span><span class=p>(</span><span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span>
  <span class=kt>return</span> <span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-14>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>trueDestOperands</code></td><td>any type</td></tr><tr><td align=center><code>falseDestOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors-1>Successors:</h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=stdconstant-constantop><code>std.constant</code> (ConstantOp)</h3><p>constant</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.constant` attribute-value `:` type
</code></pre><p>The <code>constant</code> operation produces an SSA value equal to some constant
specified by an attribute. This is the way that MLIR uses to form simple
integer and floating point constants, as well as more exotic things like
references to functions and tensor/vector constants.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Reference to function @myfn.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=nf>@myfn</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic forms
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
<span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span><span class=nl>value =</span> <span class=nf>@myfn</span><span class=p>}</span>
   <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
</code></pre></div><p>MLIR does not allow direct references to functions in SSA operands because
the compiler is multithreaded, and disallowing SSA values to directly
reference a function simplifies this
(
<a href=/docs/Rationale/#multithreading-the-compiler>rationale</a>
).</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdcopysign-copysignop><code>std.copysign</code> (CopySignOp)</h3><p>A copysign operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.copysign` ssa-use `:` type
</code></pre><p>The <code>copysign</code> returns a value with the magnitude of the first operand and
the sign of the second operand. It takes two operands and returns one
result of the same type. This type may be a float scalar type, a vector
whose element type is float, or a tensor of floats. It has no standard
attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar copysign value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> copysign <span class=nv>%b</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise copysign value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> copysign <span class=nv>%g</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise copysign value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> copysign <span class=nv>%y</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-15>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdcos-cosop><code>std.cos</code> (CosOp)</h3><p>cosine of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.cos` ssa-use `:` type
</code></pre><p>The <code>cos</code> operation computes the cosine of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar cosine value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> cos <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise cosine value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> cos <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise cosine value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cos <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-16>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stddealloc-deallocop><code>std.dealloc</code> (DeallocOp)</h3><p>memory deallocation operation</p><p>Syntax:</p><pre><code>operation ::= `std.dealloc` $memref attr-dict `:` type($memref)
</code></pre><p>The <code>dealloc</code> operation frees the region of memory referenced by a memref
which was originally created by the <code>alloc</code> operation.
The <code>dealloc</code> operation should not be called on memrefs which alias an
alloc&rsquo;d memref (e.g. memrefs returned by <code>view</code> operations).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-17>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=stddim-dimop><code>std.dim</code> (DimOp)</h3><p>dimension index operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.dim` ssa-id `,` integer-literal `:` type
</code></pre><p>The <code>dim</code> operation takes a memref or tensor operand and a dimension index,
and returns an
<a href=/docs/LangRef/#index-type><code>index</code></a>
that is the size of that
dimension.</p><p>The <code>dim</code> operation is represented with a single integer attribute named
<code>index</code>, and the type specifies the type of the memref or tensor operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Always returns 4, can be constant folded:
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> dim <span class=nv>%A</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Returns the dynamic dimension of %A.
</span><span class=c></span><span class=nv>%y</span> <span class=p>=</span> dim <span class=nv>%A</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic form:
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
<span class=nv>%y</span> <span class=p>=</span> <span class=s>&#34;std.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
</code></pre></div><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>IntegerAttr</td><td>arbitrary integer attribute</td></tr></tbody></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memrefOrTensor</code></td><td>any tensor or memref type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=stddivf-divfop><code>std.divf</code> (DivFOp)</h3><p>floating point division operation</p><h4 id=operands-19>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdexp2-exp2op><code>std.exp2</code> (Exp2Op)</h3><p>base-2 exponential of the specified value</p><h4 id=operands-20>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdexp-expop><code>std.exp</code> (ExpOp)</h3><p>base-e exponential of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.exp` ssa-use `:` type
</code></pre><p>The <code>exp</code> operation takes one operand and returns one result of the same
type. This type may be a float scalar type, a vector whose element type is
float, or a tensor of floats. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar natural exponential.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> exp <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise natural exponential.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> exp <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise natural exponential.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> exp <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-21>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdextract_element-extractelementop><code>std.extract_element</code> (ExtractElementOp)</h3><p>element extract operation</p><p>Syntax:</p><pre><code>operation ::= `std.extract_element` $aggregate `[` $indices `]` attr-dict `:` type($aggregate)
</code></pre><p>The <code>extract_element</code> op reads a tensor or vector and returns one element
from it specified by an index list. The output of the &lsquo;extract_element&rsquo; is a
new value with the same type as the elements of the tensor or vector. The
arity of indices matches the rank of the accessed value (i.e., if a tensor
is of rank 3, then 3 indices are required for the extract. The indices
should all be of <code>index</code> type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%3</span> <span class=p>=</span> extract_element <span class=nv>%v</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%4</span> <span class=p>=</span> extract_element <span class=nv>%t</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%5</span> <span class=p>=</span> extract_element <span class=nv>%ut</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xi32<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-22>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>aggregate</code></td><td>vector of any type values or tensor of any type values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdfpext-fpextop><code>std.fpext</code> (FPExtOp)</h3><p>cast from floating-point to wider floating-point</p><p>Cast a floating-point value to a larger floating-point-typed value.
The destination type must to be strictly wider than the source type.
Only scalars are currently supported.</p><h4 id=operands-23>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfptrunc-fptruncop><code>std.fptrunc</code> (FPTruncOp)</h3><p>cast from floating-point to narrower floating-point</p><p>Truncate a floating-point value to a smaller floating-point-typed value.
The destination type must be strictly narrower than the source type.
If the value cannot be exactly represented, it is rounded using the default
rounding mode. Only scalars are currently supported.</p><h4 id=operands-24>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdindex_cast-indexcastop><code>std.index_cast</code> (IndexCastOp)</h3><p>cast between index and integer types</p><p>Casts between integer scalars and &lsquo;index&rsquo; scalars. Index is an integer of
platform-specific bit width. If casting to a wider integer, the value is
sign-extended. If casting to a narrower integer, the value is truncated.</p><h4 id=operands-25>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdload-loadop><code>std.load</code> (LoadOp)</h3><p>load operation</p><p>Syntax:</p><pre><code>operation ::= `std.load` $memref `[` $indices `]` attr-dict `:` type($memref)
</code></pre><p>The <code>load</code> op reads an element from a memref specified by an index list. The
output of load is a new value with the same type as the elements of the
memref. The arity of indices is the rank of the memref (i.e., if the memref
loaded from is of rank 3, then 3 indices are required for the load following
the memref identifier).</p><p>In an <code>affine.if</code> or <code>affine.for</code> body, the indices of a load are restricted
to SSA values bound to surrounding loop induction variables,
<a href=/docs/LangRef/#dimensions-and-symbols>symbols</a>
, results of a
<a href=#constant-operation><code>constant</code> operation</a>
, or the result of an
<code>affine.apply</code> operation that can in turn take as arguments all of the
aforementioned SSA values or the recursively result of such an
<code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>3</span><span class=p>*</span>d0<span class=p>)</span><span class=p>&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d1<span class=err>+</span><span class=m>1</span><span class=p>)</span><span class=p>&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%12</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>

<span class=c>// Example of an indirect load (treated as non-affine)
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>2</span><span class=p>*</span>d0 <span class=err>+</span> <span class=m>1</span><span class=p>)</span><span class=p>&gt;</span><span class=p>(</span><span class=nv>%12</span><span class=p>)</span>
<span class=nv>%13</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to
fully resolve a reference to an element of a memref, and (in affine
<code>affine.if</code> and <code>affine.for</code> operations) the compiler can follow use-def
chains (e.g. through
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operations) to precisely analyze references at compile-time using polyhedral
techniques. This is possible because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h4 id=operands-26>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdlog10-log10op><code>std.log10</code> (Log10Op)</h3><p>base-10 logarithm of the specified value</p><h4 id=operands-27>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdlog2-log2op><code>std.log2</code> (Log2Op)</h3><p>base-2 logarithm of the specified value</p><h4 id=operands-28>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdlog-logop><code>std.log</code> (LogOp)</h3><p>base-e logarithm of the specified value</p><h4 id=operands-29>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdmemref_cast-memrefcastop><code>std.memref_cast</code> (MemRefCastOp)</h3><p>memref cast operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.memref_cast` ssa-use `:` type `to` type
</code></pre><p>The <code>memref_cast</code> operation converts a memref from one type to an equivalent
type with a compatible shape. The source and destination types are
compatible if:
a. both are ranked memref types with the same element type, affine mappings,
address space, and rank but where the individual dimensions may add or
remove constant dimensions from the memref type.</p><p>If the cast converts any dimensions from an unknown to a known size, then it
acts as an assertion that fails at runtime of the dynamic dimensions
disagree with resultant destination size.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Assert that the input dynamic shape matches the destination static shape.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Erase static shape information, replacing it with dynamic information.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// The same holds true for offsets and strides.
</span><span class=c></span>
<span class=c>// Assert that the input dynamic shape matches the destination static stride.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=err>?</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=err>?</span><span class=p>,</span> <span class=err>?</span><span class=p>]</span><span class=p>&gt;</span> to
                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=m>5</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span><span class=p>&gt;</span>
<span class=c>// Erase static offset and stride information, replacing it with
</span><span class=c></span><span class=c>// dynamic information.
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=m>5</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span><span class=p>&gt;</span> to
                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=err>?</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=err>?</span><span class=p>,</span> <span class=err>?</span><span class=p>]</span><span class=p>&gt;</span>
</code></pre></div><p>b. either or both memref types are unranked with the same element type, and
address space.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>Cast to concrete shape<span class=p>.</span>
    <span class=nv>%4</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>

Erase rank information<span class=p>.</span>
    <span class=nv>%5</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-30>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=stdmulf-mulfop><code>std.mulf</code> (MulFOp)</h3><p>floating point multiplication operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.mulf` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>mulf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar multiplication.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> mulf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD pointwise vector multiplication, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> mulf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor pointwise multiplication.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> mulf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><h4 id=operands-31>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdmuli-muliop><code>std.muli</code> (MulIOp)</h3><p>integer multiplication operation</p><h4 id=operands-32>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdnegf-negfop><code>std.negf</code> (NegFOp)</h3><p>floating point negation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `negf` ssa-use `:` type
</code></pre><p>The <code>negf</code> operation computes the negation of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar negation value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> negf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise negation value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> negf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise negation value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> negf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-33>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdor-orop><code>std.or</code> (OrOp)</h3><p>integer binary or</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `or` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>or</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise or.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> or <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> or <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> or <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-34>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdprefetch-prefetchop><code>std.prefetch</code> (PrefetchOp)</h3><p>prefetch operation</p><p>The &ldquo;prefetch&rdquo; op prefetches data from a memref location described with
subscript indices similar to std.load, and with three attributes: a
read/write specifier, a locality hint, and a cache type specifier as shown
below:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>prefetch <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span><span class=p>,</span> read<span class=p>,</span> <span class=kt>loc</span>ality<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span><span class=p>,</span> data <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>400x400x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>The read/write specifier is either &lsquo;read&rsquo; or &lsquo;write&rsquo;, the locality hint
ranges from locality&lt;0> (no locality) to locality&lt;3> (extremely local keep
in cache). The cache type specifier is either &lsquo;data&rsquo; or &lsquo;instr&rsquo;
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isWrite</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>localityHint</code></td><td align=center>IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 3</td></tr><tr><td align=center><code>isDataCache</code></td><td align=center>BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-35>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=stdrank-rankop><code>std.rank</code> (RankOp)</h3><p>rank operation</p><p>Syntax:</p><pre><code>operation ::= `std.rank` operands attr-dict `:` type(operands)
</code></pre><p>The <code>rank</code> operation takes a tensor operand and returns its rank.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> rank <span class=nv>%0</span> <span class=p>:</span> <span class=k>index</span>
</code></pre></div><h4 id=operands-36>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>tensor of any type values</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=stdremf-remfop><code>std.remf</code> (RemFOp)</h3><p>floating point division remainder operation</p><h4 id=operands-37>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdreturn-returnop><code>std.return</code> (ReturnOp)</h3><p>return operation</p><p>Syntax:</p><pre><code>operation ::= `std.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>The <code>return</code> operation represents a return operation within a function.
The operation takes variable number of operands and produces no results.
The operand number and types must match the signature of the function
that contains the operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> f8<span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=kt>return</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> f8
<span class=p>}</span>
</code></pre></div><h4 id=operands-38>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=stdrsqrt-rsqrtop><code>std.rsqrt</code> (RsqrtOp)</h3><p>reciprocal of sqrt (1 / sqrt of the specified value)</p><p>The <code>rsqrt</code> operation computes the reciprocal of the square root. It takes
one operand and returns one result of the same type. This type may be a
float scalar type, a vector whose element type is float, or a tensor of
floats. It has no standard attributes.</p><h4 id=operands-39>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdsitofp-sitofpop><code>std.sitofp</code> (SIToFPOp)</h3><p>cast from integer type to floating-point</p><p>Cast from a value interpreted as signed integer to the corresponding
floating-point value. If the value cannot be exactly represented, it is
rounded using the default rounding mode. Only scalars are currently
supported.</p><h4 id=operands-40>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-35>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdselect-selectop><code>std.select</code> (SelectOp)</h3><p>select operation</p><p>Syntax:</p><pre><code>operation ::= `std.select` $condition `,` $true_value `,` $false_value attr-dict `:` type($result)
</code></pre><p>The <code>select</code> operation chooses one value based on a binary condition
supplied as its first operand. If the value of the first operand is <code>1</code>,
the second operand is chosen, otherwise the third operand is chosen.
The second and the third operand must have the same type.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em>
of all operands is identical. The choice is made for each element
individually based on the value at the same position as the element in the
condition operand.</p><p>The <code>select</code> operation combined with
<a href=#std-cmpi><code>cmpi</code></a>
can be used
to implement <code>min</code> and <code>max</code> with signed or unsigned comparison semantics.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar selection.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.select&#34;</span><span class=p>(</span><span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Vector selection is element-wise
</span><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> <span class=s>&#34;std.select&#34;</span><span class=p>(</span><span class=nv>%vcond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span><span class=p>)</span>
    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-41>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>bool-like</td></tr><tr><td align=center><code>true_value</code></td><td>signless-integer-like or floating-point-like</td></tr><tr><td align=center><code>false_value</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless-integer-like or floating-point-like</td></tr></tbody></table><h3 id=stdshift_left-shiftleftop><code>std.shift_left</code> (ShiftLeftOp)</h3><p>integer left-shift</p><p>The shift_left operation shifts an integer value to the left by a variable
amount. The low order bits are filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i8</span>                       <span class=c>// %1 is 0b00000101
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_left <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b00101000
</span></code></pre></div><h4 id=operands-42>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdsexti-signextendiop><code>std.sexti</code> (SignExtendIOp)</h3><p>integer sign extension operation</p><p>The integer sign extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with copies
of the most-significant bit of the input.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %1 is 0b101
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> sexti <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %2 is 0b111101
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %3 is 0b010
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> sexti <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %4 is 0b000010
</span><span class=c></span>
<span class=nv>%5</span> <span class=p>=</span> sexti <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-43>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><h3 id=stddivi_signed-signeddiviop><code>std.divi_signed</code> (SignedDivIOp)</h3><p>signed integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `divi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division. Rounds towards zero. Treats the leading bit as
sign, i.e. <code>6 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> divis <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> divis <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> divis <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-44>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdremi_signed-signedremiop><code>std.remi_signed</code> (SignedRemIOp)</h3><p>signed integer division remainder operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.remi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 % -2 = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remis <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remis <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remis <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-45>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdshift_right_signed-signedshiftrightop><code>std.shift_right_signed</code> (SignedShiftRightOp)</h3><p>signed integer right-shift</p><p>The shift_right_signed operation shifts an integer value to the right by
a variable amount. The integer is interpreted as signed. The high order
bits in the output are filled with copies of the most-significant bit
of the shifted value (which means that the sign of the value is preserved).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>                             <span class=c>// %1 is 0b10100000
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_right_signed <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b11110100
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>96</span> <span class=p>:</span> <span class=k>i8</span>                              <span class=c>// %4 is 0b01100000
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> shift_right_signed <span class=nv>%4</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %5 is 0b00001100
</span></code></pre></div><h4 id=operands-46>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdsplat-splatop><code>std.splat</code> (SplatOp)</h3><p>splat or broadcast operation</p><p>Syntax:</p><pre><code>operation ::= `std.splat` $input attr-dict `:` type($aggregate)
</code></pre><p>Broadcast the operand to all elements of the result vector or tensor. The
operand has to be of either integer or float type. When the result is a
tensor, it has to be statically shaped.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%s</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>128x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%v</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x16x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
tensors in the same way dynamically shaped memrefs are handled.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding
</span><span class=c></span><span class=c>// to the sizes of the two dynamic dimensions.
</span><span class=c></span><span class=nv>%m</span> <span class=p>=</span> <span class=s>&#34;foo&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%n</span> <span class=p>=</span> <span class=s>&#34;bar&#34;</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>[</span><span class=nv>%m</span><span class=p>,</span> <span class=nv>%n</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-47>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>integer or float type</td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>aggregate</code></td><td>vector of any type values or statically shaped tensor of any type values</td></tr></tbody></table><h3 id=stdsqrt-sqrtop><code>std.sqrt</code> (SqrtOp)</h3><p>sqrt of the specified value</p><p>The <code>sqrt</code> operation computes the square root. It takes one operand and
returns one result of the same type. This type may be a float scalar type, a
vector whose element type is float, or a tensor of floats. It has no standard
attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar square root value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> sqrt <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
<span class=c>// SIMD vector element-wise square root value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> sqrt <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Tensor element-wise square root value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> sqrt <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-48>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdstore-storeop><code>std.store</code> (StoreOp)</h3><p>store operation</p><p>Syntax:</p><pre><code>operation ::= `std.store` $value `,` $memref `[` $indices `]` attr-dict `:` type($memref)
</code></pre><p>Store a value to a memref location given by indices. The value stored should
have the same type as the elemental type of the memref. The number of
arguments provided within brackets need to match the rank of the memref.</p><p>In an affine context, the indices of a store are restricted to SSA values
bound to surrounding loop induction variables,
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>symbols</a>
, results of a
<a href=#constant-operation><code>constant</code> operation</a>
, or the result of an
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operation that can in turn
take as arguments all of the aforementioned SSA values or the recursively
result of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>store <span class=nv>%100</span><span class=p>,</span> <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=m>1023</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to
fully resolve a reference to an element of a memref, and (in polyhedral
<code>affine.if</code> and <code>affine.for</code> operations) the compiler can follow use-def
chains (e.g. through
<a href=/docs/Dialects/Affine/#affineapply-operation><code>affine.apply</code></a>
operations) to precisely analyze references at compile-time using polyhedral
techniques. This is possible because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h4 id=operands-49>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>any type</td></tr><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr><tr><td align=center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=stdsubf-subfop><code>std.subf</code> (SubFOp)</h3><p>floating point subtraction operation</p><h4 id=operands-50>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td align=center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdsubi-subiop><code>std.subi</code> (SubIOp)</h3><p>integer subtraction operation</p><h4 id=operands-51>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdsubview-subviewop><code>std.subview</code> (SubViewOp)</h3><p>memref subview operation</p><p>Syntax:</p><pre><code>operation ::= `std.subview` $source `[` $offsets `]` `[` $sizes `]` `[` $strides `]` attr-dict `:`
              type($source) `to` type($result)
</code></pre><p>The &ldquo;subview&rdquo; operation converts a memref type to another memref type
which represents a reduced-size view of the original memref as specified by
the operation&rsquo;s offsets, sizes and strides arguments.</p><p>The SubView operation supports the following arguments:
*) Memref: the &ldquo;base&rdquo; memref on which to create a &ldquo;view&rdquo; memref.
*) Offsets: zero or memref-rank number of dynamic offsets into the &ldquo;base&rdquo;
memref at which to create the &ldquo;view&rdquo; memref.
*) Sizes: zero or memref-rank dynamic size operands which specify the
dynamic sizes of the result &ldquo;view&rdquo; memref type.
*) Strides: zero or memref-rank number of dynamic strides which are applied
multiplicatively to the base memref strides in each dimension.</p><p>Note on the number of operands for offsets, sizes and strides: For
each of these, the number of operands must either be same as the
memref-rank number or empty. For the latter, those values will be
treated as constants.</p><p>Example 1:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d1<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Create a sub-view of &#34;base&#34; memref &#39;%0&#39; with offset arguments &#39;%c0&#39;,
</span><span class=c></span><span class=c>// dynamic sizes for each dimension, and stride arguments &#39;%c1&#39;.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span><span class=p>[</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>]</span><span class=p>[</span><span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d1<span class=p>)</span> <span class=p>&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=err>+</span> s0<span class=p>)</span><span class=p>&gt;</span>
</code></pre></div><p>Example 2:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Create a sub-view of &#34;base&#34; memref &#39;%0&#39; with dynamic offsets, sizes,
</span><span class=c></span><span class=c>// and strides.
</span><span class=c></span><span class=c>// Note that dynamic offsets are represented by the linearized dynamic
</span><span class=c></span><span class=c>// offset symbol &#39;s0&#39; in the subview memref layout map, and that the
</span><span class=c></span><span class=c>// dynamic strides operands, after being applied to the base memref
</span><span class=c></span><span class=c>// strides in each dimension, are represented in the view memref layout
</span><span class=c></span><span class=c>// map as symbols &#39;s1&#39;, &#39;s2&#39; and &#39;s3&#39;.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>,</span> <span class=nv>%k</span><span class=p>]</span><span class=p>[</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>,</span> <span class=nv>%size2</span><span class=p>]</span><span class=p>[</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)</span><span class=p>&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x</span><span class=k>f32</span><span class=p>,</span>
      <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>,</span> s2<span class=p>,</span> s3<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=p>*</span> s2 <span class=err>+</span> d2 <span class=p>*</span> s3 <span class=err>+</span> s0<span class=p>)</span><span class=p>&gt;</span>
</code></pre></div><p>Example 3:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Subview with constant offsets, sizes and strides.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> subview <span class=nv>%0</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)</span><span class=p>&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>16</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2 <span class=err>+</span> <span class=m>8</span><span class=p>)</span><span class=p>&gt;</span>
</code></pre></div><p>Example 4:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Subview with constant size, but dynamic offsets and
</span><span class=c></span><span class=c>// strides. The resulting memref has a static shape, but if the
</span><span class=c></span><span class=c>// base memref has an affine map to describe the layout, the result
</span><span class=c></span><span class=c>// memref also uses an affine map to describe the layout. The
</span><span class=c></span><span class=c>// strides of the result memref is computed as follows:
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// Let #map1 represents the layout of the base memref, and #map2
</span><span class=c></span><span class=c>// represents the layout of the result memref. A #mapsubview can be
</span><span class=c></span><span class=c>// constructed to map an index from the result memref to the base
</span><span class=c></span><span class=c>// memref (note that the description below uses more convenient
</span><span class=c></span><span class=c>// naming for symbols, while in affine maps, symbols are
</span><span class=c></span><span class=c>// represented as unsigned numbers that identify that symbol in the
</span><span class=c></span><span class=c>// given affine map.
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// #mapsubview = (d0, d1)[o0, o1, t0, t1] -&gt; (d0 * t0 + o0, d1 * t1 + o1)
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// where, o0, o1, ... are offsets, and t0, t1, ... are strides. Then,
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// #map2 = #map1.compose(#mapsubview)
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// If the layout map is represented as
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// #map1 = (d0, d1)[s0, s1, s2] -&gt; (d0 * s1 + d1 * s2 + s0)
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// then,
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// #map2 = (d0, d1)[s0, s1, s2, o0, o1, t0, t1] -&gt;
</span><span class=c></span><span class=c>//              (d0 * s1 * t0 + d1 * s2 * t1 + o0 * s1 + o1 * s2 + s0)
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// Representing this canonically
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// #map2 = (d0, d1)[r0, r1, r2] -&gt; (d0 * r1 + d1 * r2 + r0)
</span><span class=c></span><span class=c>//
</span><span class=c></span><span class=c>// where, r0 = o0 * s1 + o1 * s2 + s0, r1 = s1 * t0, r2 = s2 * t1.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>]</span> <span class=p>:</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>,</span> s2<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=p>*</span> s2 <span class=err>+</span> s0<span class=p>)</span><span class=p>&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>r0<span class=p>,</span> r1<span class=p>,</span> r2<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> r1 <span class=err>+</span> d1 <span class=p>*</span> r2 <span class=err>+</span> r0<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Note that the subview op does not guarantee that the result
</span><span class=c></span><span class=c>// memref is &#34;inbounds&#34; w.r.t to base memref. It is upto the client
</span><span class=c></span><span class=c>// to ensure that the subview is accessed in a manner that is
</span><span class=c></span><span class=c>// in-bounds.
</span></code></pre></div><p>}</p><h4 id=operands-52>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>source</code></td><td>memref of any type values</td></tr><tr><td align=center><code>offsets</code></td><td>index</td></tr><tr><td align=center><code>sizes</code></td><td>index</td></tr><tr><td align=center><code>strides</code></td><td>index</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=stdtanh-tanhop><code>std.tanh</code> (TanhOp)</h3><p>hyperbolic tangent of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.tanh` ssa-use `:` type
</code></pre><p>The <code>tanh</code> operation computes the hyperbolic tangent. It takes one operand
and returns one result of the same type. This type may be a float scalar
type, a vector whose element type is float, or a tensor of floats. It has
no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar hyperbolic tangent value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> tanh <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise hyperbolic tangent value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> tanh <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise hyperbolic tangent value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> tanh <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-53>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdtensor_cast-tensorcastop><code>std.tensor_cast</code> (TensorCastOp)</h3><p>tensor cast operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.tensor_cast` ssa-use `:` type `to` type
</code></pre><p>Convert a tensor from one type to an equivalent type without changing any
data elements. The source and destination types must both be tensor types
with the same element type. If both are ranked, then the rank should be the
same and static dimensions should match. The operation is invalid if
converting to a mismatching constant dimension.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Convert from unknown rank to rank 2 with unknown dimension sizes.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%2</span> <span class=p>=</span> <span class=kt>tensor</span>_cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span> to <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Convert to a type with more known dimensions.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Discard static dimension and rank information.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%5</span> <span class=p>=</span> <span class=s>&#34;std.tensor_cast&#34;</span><span class=p>(</span><span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=p>*</span>xf32<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-54>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>tensor of any type values</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>tensor of any type values</td></tr></tbody></table><h3 id=stdtensor_load-tensorloadop><code>std.tensor_load</code> (TensorLoadOp)</h3><p>tensor load operation</p><p>Syntax:</p><pre><code>operation ::= `std.tensor_load` $memref attr-dict `:` type($memref)
</code></pre><p>Create a tensor from a memref, making an independent copy of the element
data. The result value is a tensor whose shape and element type match the
memref operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Produces a value of tensor&lt;4x?xf32&gt; type.
</span><span class=c></span><span class=nv>%12</span> <span class=p>=</span> <span class=kt>tensor</span>_load <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-55>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>tensor of any type values</td></tr></tbody></table><h3 id=stdtensor_store-tensorstoreop><code>std.tensor_store</code> (TensorStoreOp)</h3><p>tensor store operation</p><p>Syntax:</p><pre><code>operation ::= `std.tensor_store` $tensor `,` $memref attr-dict `:` type($memref)
</code></pre><p>Stores the contents of a tensor into a memref. The first operand is a value
of tensor type, the second operand is a value of memref type. The shapes and
element types of these must match, and are specified by the memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%9</span> <span class=p>=</span> dim <span class=nv>%8</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%10</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%9</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
<span class=kt>tensor</span>_store <span class=nv>%8</span><span class=p>,</span> <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-56>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>tensor</code></td><td>tensor of any type values</td></tr><tr><td align=center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=stdtrunci-truncateiop><code>std.trunci</code> (TruncateIOp)</h3><p>integer truncation operation</p><p>The integer truncation operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be smaller than the input bit-width (N &lt; M).
The top-most (N - M) bits of the input are discarded.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>21</span> <span class=p>:</span> <span class=k>i5</span>           <span class=c>// %1 is 0b10101
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i4</span>       <span class=c>// %2 is 0b0101
</span><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i3</span>       <span class=c>// %3 is 0b101
</span><span class=c></span>
  <span class=nv>%5</span> <span class=p>=</span> trunci <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i16</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-57>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><h3 id=stddivi_unsigned-unsigneddiviop><code>std.divi_unsigned</code> (UnsignedDivIOp)</h3><p>unsigned integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.divi_unsigned` ssa-use `,` ssa-use `:` type
</code></pre><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as
the most significant, i.e. for <code>i16</code> given two&rsquo;s complement representation,
<code>6 / -2 = 6 / (2^16 - 2) = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> diviu <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> diviu <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> diviu <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-58>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-51>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdremi_unsigned-unsignedremiop><code>std.remi_unsigned</code> (UnsignedRemIOp)</h3><p>unsigned integer division remainder operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.remi_unsigned` ssa-use `,` ssa-use `:` type
</code></pre><p>Unsigned integer division remainder. Treats the leading bit as the most
significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remiu <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remiu <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remiu <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-59>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-52>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdshift_right_unsigned-unsignedshiftrightop><code>std.shift_right_unsigned</code> (UnsignedShiftRightOp)</h3><p>unsigned integer right-shift</p><p>The shift_right_unsigned operation shifts an integer value to the right by
a variable amount. The integer is interpreted as unsigned. The high order
bits are always filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>                               <span class=c>// %1 is 0b10100000
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_right_unsigned <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b00010100
</span></code></pre></div><h4 id=operands-60>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-53>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdview-viewop><code>std.view</code> (ViewOp)</h3><p>memref view operation</p><p>The &ldquo;view&rdquo; operation converts a 1-D memref with i8 element type,
to an N-D memref with arbitrary element type. In addition, the ViewOp
supports the following arguments:
*) A single dynamic offset operand can be specified which represents a
a dynamic offset within the base 1-D memref at which to create the
resulting memref view.
*) A dynamic size operand must be specified for each dynamic dimension
in the resulting view memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocate a flat 1D/i8 memref.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// ViewOp with static offset and sizes.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> view <span class=nv>%0</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// ViewOp with dynamic offset and one dynamic size.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> view <span class=nv>%0</span><span class=p>[</span><span class=nv>%offset_1024</span><span class=p>]</span><span class=p>[</span><span class=nv>%size0</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x4x</span><span class=k>f32</span><span class=p>,</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d1 <span class=err>+</span> s0<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// ViewOp creating 3D shape where two of the dim sizes are dynamic.
</span><span class=c></span><span class=c>// *) The dynamic offset specified in the ViewOp is applied to the
</span><span class=c></span><span class=c>//    base 1-D memref, and is represented by the symbol &#39;s0&#39; in the
</span><span class=c></span><span class=c>//    layout map of the ViewOp result memref type.
</span><span class=c></span><span class=c>// *) The dynamic size for the second dimension induces a dynamic
</span><span class=c></span><span class=c>//    stride for the first dimension, which is represented by the
</span><span class=c></span><span class=c>//    symbol &#39;s1&#39; in the layout map of the ViewOp result memref type.
</span><span class=c></span><span class=c>//    Note that this dynamic stride will be computed from the view
</span><span class=c></span><span class=c>//    shape and dynamic sizes.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> view <span class=nv>%0</span><span class=p>[</span><span class=nv>%offset_1024</span><span class=p>]</span><span class=p>[</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x4x</span><span class=k>f32</span><span class=p>,</span>
    <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span><span class=p>[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2 <span class=err>+</span> s0<span class=p>)</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-61>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>source</code></td><td>1D memref of 8-bit signless integer values</td></tr><tr><td align=center><code>operands</code></td><td>index</td></tr></tbody></table><h4 id=results-54>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>memref of any type values</td></tr></tbody></table><h3 id=stdxor-xorop><code>std.xor</code> (XOrOp)</h3><p>integer binary xor</p><p>The <code>xor</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise xor.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> xor <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> xor <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> xor <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-62>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td align=center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-55>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdzexti-zeroextendiop><code>std.zexti</code> (ZeroExtendIOp)</h3><p>integer zero extension operation</p><p>The integer zero extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %1 is 0b101
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> zexti <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %2 is 0b000101
</span><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %3 is 0b010
</span><span class=c></span>  <span class=nv>%4</span> <span class=p>=</span> zexti <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %4 is 0b000010
</span><span class=c></span>
  <span class=nv>%5</span> <span class=p>=</span> zexti <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-63>Operands:</h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-56>Results:</h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><h3 id=dma_start-operation>&lsquo;dma_start&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dma_start` ssa-use`[`ssa-use-list`]` `,`
               ssa-use`[`ssa-use-list`]` `,` ssa-use `,`
               ssa-use`[`ssa-use-list`]` (`,` ssa-use `,` ssa-use)?
              `:` memref-type `,` memref-type `,` memref-type
</code></pre><p>Starts a non-blocking DMA operation that transfers data from a source memref to
a destination memref. The operands include the source and destination memref&rsquo;s
each followed by its indices, size of the data transfer in terms of the number
of elements (of the elemental type of the memref), a tag memref with its
indices, and optionally two additional arguments corresponding to the stride (in
terms of number of elements) and the number of elements to transfer per stride.
The tag location is used by a dma_wait operation to check for completion. The
indices of the source memref, destination memref, and the tag memref have the
same restrictions as any load/store operation in an affine context (whenever DMA
operations appear in an affine context). See
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in affine contexts. This allows powerful static analysis and transformations in
the presence of such DMAs including rescheduling, pipelining / overlap with
computation, and checking for matching start/end operations. The source and
destination memref need not be of the same dimensionality, but need to have the
same elemental type.</p><p>For example, a <code>dma_start</code> operation that transfers 32 vector elements from a
memref <code>%src</code> at location <code>[%i, %j]</code> to memref <code>%dst</code> at <code>[%k, %l]</code> would be
specified as shown below.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%size</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>32</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%tag</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
<span class=nv>%idx</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span><span class=p>,</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>]</span><span class=p>,</span> <span class=nv>%size</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span> <span class=p>:</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40 x</span> <span class=m>8 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>0</span><span class=p>&gt;</span><span class=p>,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span><span class=p>,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><h3 id=dma_wait-operation>&lsquo;dma_wait&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dma_wait` ssa-use`[`ssa-use-list`]` `,` ssa-use `:` memref-type
</code></pre><p>Blocks until the completion of a DMA operation associated with the tag element
specified with a tag memref and its indices. The operands include the tag memref
followed by its indices and the number of elements associated with the DMA being
waited on. The indices of the tag memref have the same restrictions as
load/store indices.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>dma_wait <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span><span class=p>,</span> <span class=nv>%size</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;</span><span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)</span><span class=p>&gt;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/SPIR-V/ title="'spv' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'spv' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Vector/ title="'vector' Dialect">Next - 'vector' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li class=active><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>