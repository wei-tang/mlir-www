<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Writing a Pass - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/writingapass/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Writing a Pass</h1><p>[TOC]</p><p>Passes represent the basic infrastructure for transformation and optimization.
This document provides a quickstart to the pass infrastructure in MLIR and how
to use it.</p><p>See <a href=LangRef.md>MLIR specification</a> for more information about MLIR and its
core aspects, such as the IR structure and operations.</p><p>See <a href=QuickstartRewrites.md>MLIR Rewrites</a> for a quick start on graph rewriting
in MLIR. If your transformation involves pattern matching operation DAGs, this
is a great place to start.</p><h2 id=operation-pass>Operation Pass</h2><p>In MLIR, the main unit of abstraction and transformation is an
<a href=LangRef.md#operations>operation</a>. As such, the pass manager is designed to
work on instances of operations at different levels of nesting. The structure of
the <a href=#pass-manager>pass manager</a>, and the concept of nesting, is detailed
further below. All passes in MLIR derive from <code>OperationPass</code> and adhere to the
following restrictions; any noncompliance will lead to problematic behavior in
multithreaded and other advanced scenarios:</p><ul><li>Modify anything within the parent block/region/operation/etc, outside of the
current operation being operated on. This includes adding or removing
operations from the parent block.</li><li>Maintain pass state across invocations of <code>runOnOperation</code>. A pass may be
run on several different operations with no guarantee of execution order.<ul><li>When multithreading, a specific pass instance may not even execute on
all operations within the module. As such, a pass should not rely on
running on all operations.</li></ul></li><li>Modify the state of another operation not nested within the current
operation being operated on.<ul><li>Other threads may be operating on different operations within the module
simultaneously.</li></ul></li><li>Maintain any global mutable state, e.g. static variables within the source
file. All mutable state should be maintained by an instance of the pass.</li><li>Must be copy-constructible, multiple instances of the pass may be created by
the pass manager to process operations in parallel.</li><li>Inspect the IR of sibling operations. Other threads may be modifying these
operations in parallel.</li></ul><p>When creating an operation pass, there are two different types to choose from
depending on the usage scenario:</p><h3 id=operationpass-op-specific>OperationPass : Op-Specific</h3><p>An <code>op-specific</code> operation pass operates explicitly on a given operation type.
This operation type must adhere to the restrictions set by the pass manager for
pass execution.</p><p>To define an op-specific operation pass, a derived class must adhere to the
following:</p><ul><li>Inherit from the CRTP class <code>OperationPass</code> and provide the operation type
as an additional template parameter.</li><li>Override the virtual <code>void runOnOperation()</code> method.</li></ul><p>A simple pass may look like:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>namespace</span> <span class=p>{</span>
<span class=k>struct</span> <span class=nc>MyFunctionPass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OperationPass</span><span class=o>&lt;</span><span class=n>MyFunctionPass</span><span class=p>,</span> <span class=n>FuncOp</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=kt>void</span> <span class=nf>runOnOperation</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
    <span class=c1>// Get the current FuncOp operation being operated on.
</span><span class=c1></span>    <span class=n>FuncOp</span> <span class=n>f</span> <span class=o>=</span> <span class=n>getOperation</span><span class=p>();</span>

    <span class=c1>// Walk the operations within the function.
</span><span class=c1></span>    <span class=n>f</span><span class=p>.</span><span class=n>walk</span><span class=p>([](</span><span class=n>Operation</span> <span class=o>*</span><span class=n>inst</span><span class=p>)</span> <span class=p>{</span>
      <span class=p>....</span>
    <span class=p>});</span>
  <span class=p>}</span>
<span class=p>};</span>
<span class=p>}</span> <span class=c1>// end anonymous namespace
</span><span class=c1></span>
<span class=c1>// Register this pass to make it accessible to utilities like mlir-opt.
</span><span class=c1>// (Pass registration is discussed more below)
</span><span class=c1></span><span class=k>static</span> <span class=n>PassRegistration</span><span class=o>&lt;</span><span class=n>MyFunctionPass</span><span class=o>&gt;</span> <span class=n>pass</span><span class=p>(</span>
    <span class=s>&#34;flag-name-to-invoke-pass-via-mlir-opt&#34;</span><span class=p>,</span> <span class=s>&#34;Pass description here&#34;</span><span class=p>);</span>
</code></pre></div><h3 id=operationpass-op-agnostic>OperationPass : Op-Agnostic</h3><p>An <code>op-agnostic</code> pass operates on the operation type of the pass manager that it
is added to. This means that a pass that operates on several different operation
types in the same way only needs one implementation.</p><p>To create an operation pass, a derived class must adhere to the following:</p><ul><li>Inherit from the CRTP class <code>OperationPass</code>.</li><li>Override the virtual <code>void runOnOperation()</code> method.</li></ul><p>A simple pass may look like:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyOperationPass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OperationPass</span><span class=o>&lt;</span><span class=n>MyOperationPass</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=kt>void</span> <span class=nf>runOnOperation</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
    <span class=c1>// Get the current operation being operated on.
</span><span class=c1></span>    <span class=n>Operation</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=n>getOperation</span><span class=p>();</span>
    <span class=p>...</span>
  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><h2 id=analysis-management>Analysis Management</h2><p>An important concept, along with transformation passes, are analyses. These are
conceptually similar to transformation passes, except that they compute
information on a specific operation without modifying it. In MLIR, analyses are
not passes but free-standing classes that are computed lazily on-demand and
cached to avoid unnecessary recomputation. An analysis in MLIR must adhere to
the following:</p><ul><li>Provide a valid constructor taking an <code>Operation*</code>.</li><li>Must not modify the given operation.</li></ul><p>An analysis may provide additional hooks to control various behavior:</p><ul><li><code>bool isInvalidated(const AnalysisManager::PreservedAnalyses &amp;)</code></li></ul><p>Given a preserved analysis set, the analysis returns true if it should truly be
invalidated. This allows for more fine-tuned invalidation in cases where an
analysis wasn&rsquo;t explicitly marked preserved, but may be preserved (or
invalidated) based upon other properties such as analyses sets.</p><h3 id=querying-analyses>Querying Analyses</h3><p>The base <code>OperationPass</code> class provide utilities for querying and preserving
analyses for the current operation being processed.</p><ul><li>OperationPass automatically provides the following utilities for querying
analyses:<ul><li><code>getAnalysis&lt;&gt;</code><ul><li>Get an analysis for the current operation, constructing it if
necessary.</li></ul></li><li><code>getCachedAnalysis&lt;&gt;</code><ul><li>Get an analysis for the current operation, if it already exists.</li></ul></li><li><code>getCachedParentAnalysis&lt;&gt;</code><ul><li>Get an analysis for a given parent operation, if it exists.</li></ul></li><li><code>getCachedChildAnalysis&lt;&gt;</code><ul><li>Get an analysis for a given child operation, if it exists.</li></ul></li><li><code>getChildAnalysis&lt;&gt;</code><ul><li>Get an analysis for a given child operation, constructing it if
necessary.</li></ul></li></ul></li></ul><p>Using the example passes defined above, let&rsquo;s see some examples:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// An interesting analysis.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>MyOperationAnalysis</span> <span class=p>{</span>
  <span class=c1>// Compute this analysis with the provided operation.
</span><span class=c1></span>  <span class=n>MyOperationAnalysis</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>);</span>
<span class=p>};</span>

<span class=kt>void</span> <span class=n>MyOperationPass</span><span class=o>::</span><span class=n>runOnOperation</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// Query MyOperationAnalysis for the current operation.
</span><span class=c1></span>  <span class=n>MyOperationAnalysis</span> <span class=o>&amp;</span><span class=n>myAnalysis</span> <span class=o>=</span> <span class=n>getAnalysis</span><span class=o>&lt;</span><span class=n>MyOperationAnalysis</span><span class=o>&gt;</span><span class=p>();</span>

  <span class=c1>// Query a cached instance of MyOperationAnalysis for the current operation.
</span><span class=c1></span>  <span class=c1>// It will not be computed if it doesn&#39;t exist.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>optionalAnalysis</span> <span class=o>=</span> <span class=n>getCachedAnalysis</span><span class=o>&lt;</span><span class=n>MyOperationAnalysis</span><span class=o>&gt;</span><span class=p>();</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>optionalAnalysis</span><span class=p>)</span>
    <span class=p>...</span>

  <span class=c1>// Query a cached instance of MyOperationAnalysis for the parent operation of
</span><span class=c1></span>  <span class=c1>// the current operation. It will not be computed if it doesn&#39;t exist.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>optionalAnalysis</span> <span class=o>=</span> <span class=n>getCachedParentAnalysis</span><span class=o>&lt;</span><span class=n>MyOperationAnalysis</span><span class=o>&gt;</span><span class=p>();</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>optionalAnalysis</span><span class=p>)</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><h3 id=preserving-analyses>Preserving Analyses</h3><p>Analyses that are constructed after being queried by a pass are cached to avoid
unnecessary computation if they are requested again later. To avoid stale
analyses, all analyses are assumed to be invalidated by a pass. To avoid
invalidation, a pass must specifically mark analyses that are known to be
preserved.</p><ul><li><p>All Pass classes automatically provide the following utilities for
preserving analyses:</p><ul><li><code>markAllAnalysesPreserved</code></li><li><p><code>markAnalysesPreserved&lt;&gt;</code></p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>MyOperationPass</span><span class=o>::</span><span class=n>runOnOperation</span><span class=p>()</span> <span class=p>{</span>
<span class=c1>// Mark all analyses as preserved. This is useful if a pass can guarantee
</span><span class=c1>// that no transformation was performed.
</span><span class=c1></span><span class=n>markAllAnalysesPreserved</span><span class=p>();</span>

<span class=c1>// Mark specific analyses as preserved. This is used if some transformation
</span><span class=c1>// was performed, but some analyses were either unaffected or explicitly
</span><span class=c1>// preserved.
</span><span class=c1></span><span class=n>markAnalysesPreserved</span><span class=o>&lt;</span><span class=n>MyAnalysis</span><span class=p>,</span> <span class=n>MyAnalyses</span><span class=p>...</span><span class=o>&gt;</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></li></ul></li></ul><h2 id=pass-failure>Pass Failure</h2><p>Passes in MLIR are allowed to gracefully fail. This may happen if some invariant
of the pass was broken, potentially leaving the IR in some invalid state. If
such a situation occurs, the pass can directly signal a failure to the pass
manager. If a pass signaled a failure when executing, no other passes in the
pipeline will execute and the <code>PassManager::run</code> will return failure. Failure
signaling is provided in the form of a <code>signalPassFailure</code> method.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>MyPass</span><span class=o>::</span><span class=n>runOnOperation</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// Signal failure on a broken invariant.
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>some_broken_invariant</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>signalPassFailure</span><span class=p>();</span>
    <span class=k>return</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h2 id=pass-manager>Pass Manager</h2><p>Above we introduced the different types of passes and their constraints. Now
that we have our pass we need to be able to run it over a specific module. This
is where the pass manager comes into play. The <code>PassManager</code> class is used to
configure and run a pipeline. The <code>OpPassManager</code> class is used to schedule
passes to run at a specific level of nesting.</p><h3 id=oppassmanager>OpPassManager</h3><p>An <code>OpPassManager</code> is essentially a collection of passes to execute on an
operation of a given type. This operation type must adhere to the following
requirement:</p><ul><li><p>Must be registered and marked <code>IsolatedFromAbove</code>.</p><ul><li>Passes are expected to not modify operations at or above the current
operation being processed. If the operation is not isolated, it may
inadvertently modify the use-list of an operation it is not supposed to
modify.</li></ul></li></ul><p>Passes can be added to a pass manager via <code>addPass</code>. The pass must either be an
<code>op-specific</code> pass operating on the same operation type as <code>OpPassManager</code>, or
an <code>op-agnostic</code> pass.</p><p>An <code>OpPassManager</code> cannot be created directly, but must be explicitly nested
within another <code>OpPassManager</code> via the <code>nest&lt;&gt;</code> method. This method takes the
operation type that the nested pass manager will operate on. At the top-level, a
<code>PassManager</code> acts as an <code>OpPassManager</code> that operates on the
<a href=LangRef.md#module><code>module</code></a> operation. Nesting in this sense, corresponds to
the structural nesting within <a href=LangRef.md#regions>Regions</a> of the IR.</p><p>For example, the following <code>.mlir</code>:</p><pre><code>module {
  spv.module &quot;Logical&quot; &quot;GLSL450&quot; {
    func @foo() {
      ...
    }
  }
}
</code></pre><p>Has the nesting structure of:</p><pre><code>`module`
  `spv.module`
    `function`
</code></pre><p>Below is an example of constructing a pipeline that operates on the above
structure:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>PassManager</span> <span class=nf>pm</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>

<span class=c1>// Add a pass on the top-level module operation.
</span><span class=c1></span><span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyModulePass</span><span class=o>&gt;</span><span class=p>());</span>

<span class=c1>// Nest a pass manager that operates on spirv module operations nested directly
</span><span class=c1>// under the top-level module.
</span><span class=c1></span><span class=n>OpPassManager</span> <span class=o>&amp;</span><span class=n>nestedModulePM</span> <span class=o>=</span> <span class=n>pm</span><span class=p>.</span><span class=n>nest</span><span class=o>&lt;</span><span class=n>spirv</span><span class=o>::</span><span class=n>ModuleOp</span><span class=o>&gt;</span><span class=p>();</span>
<span class=n>nestedModulePM</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MySPIRVModulePass</span><span class=o>&gt;</span><span class=p>());</span>

<span class=c1>// Nest a pass manager that operates on functions within the nested SPIRV
</span><span class=c1>// module.
</span><span class=c1></span><span class=n>OpPassManager</span> <span class=o>&amp;</span><span class=n>nestedFunctionPM</span> <span class=o>=</span> <span class=n>nestedModulePM</span><span class=p>.</span><span class=n>nest</span><span class=o>&lt;</span><span class=n>FuncOp</span><span class=o>&gt;</span><span class=p>();</span>
<span class=n>nestedFunctionPM</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyFunctionPass</span><span class=o>&gt;</span><span class=p>());</span>

<span class=c1>// Run the pass manager on the top-level module.
</span><span class=c1></span><span class=n>Module</span> <span class=n>m</span> <span class=o>=</span> <span class=p>...;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>failed</span><span class=p>(</span><span class=n>pm</span><span class=p>.</span><span class=n>run</span><span class=p>(</span><span class=n>m</span><span class=p>)))</span>
    <span class=p>...</span> <span class=c1>// One of the passes signaled a failure.
</span></code></pre></div><p>The above pass manager would contain the following pipeline structure:</p><pre><code>OpPassManager&lt;ModuleOp&gt;
  MyModulePass
  OpPassManager&lt;spirv::ModuleOp&gt;
    MySPIRVModulePass
    OpPassManager&lt;FuncOp&gt;
      MyFunctionPass
</code></pre><p>These pipelines are then run over a single operation at a time. This means that,
for example, given a series of consecutive passes on FuncOp, it will execute all
on the first function, then all on the second function, etc. until the entire
program has been run through the passes. This provides several benefits:</p><ul><li>This improves the cache behavior of the compiler, because it is only
touching a single function at a time, instead of traversing the entire
program.</li><li>This improves multi-threading performance by reducing the number of jobs
that need to be scheduled, as well as increasing the efficiency of each job.
An entire function pipeline can be run on each function asynchronously.</li></ul><h2 id=pass-registration>Pass Registration</h2><p>Briefly shown in the example definitions of the various pass types is the
<code>PassRegistration</code> class. This is a utility to register derived pass classes so
that they may be created, and inspected, by utilities like mlir-opt. Registering
a pass class takes the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=n>PassRegistration</span><span class=o>&lt;</span><span class=n>MyPass</span><span class=o>&gt;</span> <span class=n>pass</span><span class=p>(</span><span class=s>&#34;command-line-arg&#34;</span><span class=p>,</span> <span class=s>&#34;description&#34;</span><span class=p>);</span>
</code></pre></div><ul><li><code>MyPass</code> is the name of the derived pass class.</li><li>&ldquo;command-line-arg&rdquo; is the argument to use on the command line to invoke the
pass from <code>mlir-opt</code>.</li><li>&ldquo;description&rdquo; is a description of the pass.</li></ul><p>For passes that cannot be default-constructed, <code>PassRegistration</code> accepts an
optional third argument that takes a callback to create the pass:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=n>PassRegistration</span><span class=o>&lt;</span><span class=n>MyParametricPass</span><span class=o>&gt;</span> <span class=n>pass</span><span class=p>(</span>
    <span class=s>&#34;command-line-arg&#34;</span><span class=p>,</span> <span class=s>&#34;description&#34;</span><span class=p>,</span>
    <span class=p>[]()</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=p>{</span>
      <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyParametricPass</span><span class=o>&gt;</span><span class=p>(</span><span class=cm>/*options*/</span><span class=p>);</span>
      <span class=cm>/*... non-trivial-logic to configure the pass ...*/</span><span class=p>;</span>
      <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
    <span class=p>});</span>
</code></pre></div><p>This variant of registration can be used, for example, to accept the
configuration of a pass from command-line arguments and pass it over to the pass
constructor. Make sure that the pass is copy-constructible in a way that does
not share data as the <a href=#pass-manager>pass manager</a> may create copies of the
pass to run in parallel.</p><h3 id=pass-pipeline-registration>Pass Pipeline Registration</h3><p>Described above is the mechanism used for registering a specific derived pass
class. On top of that, MLIR allows for registering custom pass pipelines in a
similar fashion. This allows for custom pipelines to be available to tools like
mlir-opt in the same way that passes are, which is useful for encapsulating
common pipelines like the &ldquo;-O1&rdquo; series of passes. Pipelines are registered via a
similar mechanism to passes in the form of <code>PassPipelineRegistration</code>. Compared
to <code>PassRegistration</code>, this class takes an additional parameter in the form of a
pipeline builder that modifies a provided <code>OpPassManager</code>.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>pipelineBuilder</span><span class=p>(</span><span class=n>OpPassManager</span> <span class=o>&amp;</span><span class=n>pm</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyPass</span><span class=o>&gt;</span><span class=p>());</span>
  <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyOtherPass</span><span class=o>&gt;</span><span class=p>());</span>
<span class=p>}</span>

<span class=c1>// Register an existing pipeline builder function.
</span><span class=c1></span><span class=k>static</span> <span class=n>PassPipelineRegistration</span><span class=o>&lt;&gt;</span> <span class=n>pipeline</span><span class=p>(</span>
  <span class=s>&#34;command-line-arg&#34;</span><span class=p>,</span> <span class=s>&#34;description&#34;</span><span class=p>,</span> <span class=n>pipelineBuilder</span><span class=p>);</span>

<span class=c1>// Register an inline pipeline builder.
</span><span class=c1></span><span class=k>static</span> <span class=n>PassPipelineRegistration</span><span class=o>&lt;&gt;</span> <span class=n>pipeline</span><span class=p>(</span>
  <span class=s>&#34;command-line-arg&#34;</span><span class=p>,</span> <span class=s>&#34;description&#34;</span><span class=p>,</span> <span class=p>[](</span><span class=n>OpPassManager</span> <span class=o>&amp;</span><span class=n>pm</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyPass</span><span class=o>&gt;</span><span class=p>());</span>
    <span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MyOtherPass</span><span class=o>&gt;</span><span class=p>());</span>
  <span class=p>});</span>
</code></pre></div><p>Pipeline registration also allows for simplified registration of
specifializations for existing passes:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=n>PassPipelineRegistration</span><span class=o>&lt;&gt;</span> <span class=n>foo10</span><span class=p>(</span>
    <span class=s>&#34;foo-10&#34;</span><span class=p>,</span> <span class=s>&#34;Foo Pass 10&#34;</span><span class=p>,</span> <span class=p>[]</span> <span class=p>{</span> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>FooPass</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span> <span class=p>}</span> <span class=p>);</span>
</code></pre></div><h3 id=textual-pass-pipeline-specification>Textual Pass Pipeline Specification</h3><p>In the previous sections, we showed how to register passes and pass pipelines
with a specific argument and description. Once registered, these can be used on
the command line to configure a pass manager. The limitation of using these
arguments directly is that they cannot build a nested pipeline. For example, if
our module has another module nested underneath, with just <code>-my-module-pass</code>
there is no way to specify that this pass should run on the nested module and
not the top-level module. This is due to the flattened nature of the command
line.</p><p>To circumvent this limitation, MLIR also supports a textual description of a
pass pipeline. This allows for explicitly specifying the structure of the
pipeline to add to the pass manager. This includes the nesting structure, as
well as the passes and pass pipelines to run. A textual pipeline is defined as a
series of names, each of which may in itself recursively contain a nested
pipeline description. The syntax for this specification is as follows:</p><div class=highlight><pre class=chroma><code class=language-ebnf data-lang=ebnf><span class=k>pipeline          </span><span class=err>::</span><span class=o>=</span> <span class=k>op-name </span><span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>pipeline-element </span><span class=p>(</span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>pipeline-element</span><span class=p>)</span><span class=err>*</span> <span class=err>`</span><span class=p>)</span><span class=err>`</span>
<span class=k>pipeline-element  </span><span class=err>::=</span> <span class=k>pipeline </span><span class=p>|</span> <span class=p>(</span><span class=k>pass-name </span><span class=p>|</span> <span class=k>pass-pipeline-name</span><span class=p>)</span> <span class=k>options</span><span class=ni>?
</span><span class=ni>options           ::= &#39;{&#39; (key (&#39;=&#39; value)?</span><span class=p>)</span><span class=err>+</span> <span class=s1>&#39;}&#39;</span></code></pre></div><ul><li><code>op-name</code><ul><li>This corresponds to the mnemonic name of an operation to run passes on,
e.g. <code>func</code> or <code>module</code>.</li></ul></li><li><code>pass-name</code> | <code>pass-pipeline-name</code><ul><li>This corresponds to the command-line argument of a registered pass or
pass pipeline, e.g. <code>cse</code> or <code>canonicalize</code>.</li></ul></li><li><code>options</code><ul><li>Options are pass specific key value pairs that are handled as described
in the <a href=#instance-specific-pass-options>instance specific pass options</a>
section.</li></ul></li></ul><p>For example, the following pipeline:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -cse -canonicalize -convert-std-to-llvm</code></pre></div><p>Can also be specified as (via the <code>-pass-pipeline</code> flag):</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse, canonicalize), convert-std-to-llvm&#39;</span></code></pre></div><p>In order to support round-tripping your pass to the textual representation using
<code>OpPassManager::printAsTextualPipeline(raw_ostream&amp;)</code>, override
<code>Pass::printAsTextualPipeline(raw_ostream&amp;)</code> to format your pass-name and
options in the format described above.</p><h3 id=instance-specific-pass-options>Instance Specific Pass Options</h3><p>Options may be specified for a parametric pass. Individual options are defined
using the <a href=https://llvm.org/docs/CommandLine.html>LLVM command line</a> flag
definition rules. These options will then be parsed at pass construction time
independently for each instance of the pass. To provide options for passes, the
<code>Option&lt;&gt;</code> and <code>OptionList&lt;&gt;</code> classes may be used:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyPass</span> <span class=p>...</span> <span class=p>{</span>
  <span class=c1>/// Make sure that we have a valid default constructor and copy constructor to
</span><span class=c1></span>  <span class=c1>/// make sure that the options are initialized properly.
</span><span class=c1></span>  <span class=n>MyPass</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
  <span class=n>MyPass</span><span class=p>(</span><span class=k>const</span> <span class=n>MyPass</span><span class=o>&amp;</span> <span class=n>pass</span><span class=p>)</span> <span class=p>{}</span>

  <span class=c1>// These just forward onto llvm::cl::list and llvm::cl::opt respectively.
</span><span class=c1></span>  <span class=n>Option</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>exampleOption</span><span class=p>{</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=s>&#34;flag-name&#34;</span><span class=p>,</span> <span class=n>llvm</span><span class=o>::</span><span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>)};</span>
  <span class=n>ListOption</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>exampleListOption</span><span class=p>{</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=s>&#34;list-flag-name&#34;</span><span class=p>,</span>
                                    <span class=n>llvm</span><span class=o>::</span><span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>)};</span>
<span class=p>};</span>
</code></pre></div><p>For pass pipelines, the <code>PassPipelineRegistration</code> templates take an additional
optional template parameter that is the Option struct definition to be used for
that pipeline. To use pipeline specific options, create a class that inherits
from <code>mlir::PassPipelineOptions</code> that contains the desired options. When using
<code>PassPipelineRegistration</code>, the constructor now takes a function with the
signature <code>void (OpPassManager &amp;pm, const MyPipelineOptions&amp;)</code> which should
construct the passes from the options and pass them to the pm:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyPipelineOptions</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PassPipelineOptions</span> <span class=p>{</span>
  <span class=c1>// These just forward onto llvm::cl::list and llvm::cl::opt respectively.
</span><span class=c1></span>  <span class=n>Option</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>exampleOption</span><span class=p>{</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=s>&#34;flag-name&#34;</span><span class=p>,</span> <span class=n>llvm</span><span class=o>::</span><span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>)};</span>
  <span class=n>ListOption</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>exampleListOption</span><span class=p>{</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=s>&#34;list-flag-name&#34;</span><span class=p>,</span>
                                    <span class=n>llvm</span><span class=o>::</span><span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;...&#34;</span><span class=p>)};</span>
<span class=p>};</span>


<span class=k>static</span> <span class=n>mlir</span><span class=o>::</span><span class=n>PassPipelineRegistration</span><span class=o>&lt;</span><span class=n>MyPipelineOptions</span><span class=o>&gt;</span> <span class=n>pipeline</span><span class=p>(</span>
    <span class=s>&#34;example-pipeline&#34;</span><span class=p>,</span> <span class=s>&#34;Run an example pipeline.&#34;</span><span class=p>,</span>
    <span class=p>[](</span><span class=n>OpPassManager</span> <span class=o>&amp;</span><span class=n>pm</span><span class=p>,</span> <span class=k>const</span> <span class=n>MyPipelineOptions</span> <span class=o>&amp;</span><span class=n>pipelineOptions</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// Initialize the pass manager.
</span><span class=c1></span>    <span class=p>});</span>
</code></pre></div><h2 id=pass-statistics>Pass Statistics</h2><p>Statistics are a way to keep track of what the compiler is doing and how
effective various transformations are. It is often useful to see what effect
specific transformations have on a particular program, and how often they
trigger. Pass statistics are instance specific which allow for taking this a
step further as you are able to see the effect of placing a particular
transformation at specific places within the pass pipeline. For example, they
help answer questions like <code>What happens if I run CSE again here?</code>.</p><p>Statistics can be added to a pass by using the &lsquo;Pass::Statistic&rsquo; class. This
class takes as a constructor arguments: the parent pass, a name, and a
description. This class acts like an unsigned integer, and may be incremented
and updated accordingly. These statistics use the same infrastructure as
<a href=http://llvm.org/docs/ProgrammersManual.html#the-statistic-class-stats-option><code>llvm::Statistic</code></a>
and thus have similar usage constraints. Collected statistics can be dumped by
the <a href=#pass-manager>pass manager</a> programmatically via
<code>PassManager::enableStatistics</code>; or via <code>-pass-statistics</code> and
<code>-pass-statistics-display</code> on the command line.</p><p>An example is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>MyPass</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OperationPass</span><span class=o>&lt;</span><span class=n>MyPass</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=n>Statistic</span> <span class=n>testStat</span><span class=p>{</span><span class=k>this</span><span class=p>,</span> <span class=s>&#34;testStat&#34;</span><span class=p>,</span> <span class=s>&#34;A test statistic&#34;</span><span class=p>};</span>

  <span class=kt>void</span> <span class=nf>runOnOperation</span><span class=p>()</span> <span class=p>{</span>
    <span class=p>...</span>

    <span class=c1>// Update our statistic after some invariant was hit.
</span><span class=c1></span>    <span class=o>++</span><span class=n>testStat</span><span class=p>;</span>

    <span class=p>...</span>
  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>The collected statistics may be aggregated in two types of views:</p><p>A pipeline view that models the structure of the pass manager, this is the
default view:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(my-pass,my-pass)&#39;</span> foo.mlir -pass-statistics

<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
                         ... Pass statistics report ...
<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
<span class=s1>&#39;func&#39;</span> Pipeline
  MyPass
    <span class=o>(</span>S<span class=o>)</span> <span class=m>15</span> testStat - A <span class=nb>test</span> statistic
  VerifierPass
  MyPass
    <span class=o>(</span>S<span class=o>)</span>  <span class=m>6</span> testStat - A <span class=nb>test</span> statistic
  VerifierPass
VerifierPass</code></pre></div><p>And a list view that aggregates all instances of a specific pass together:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(my-pass, my-pass)&#39;</span> foo.mlir -pass-statistics -pass-statistics-display<span class=o>=</span><span class=nv>list</span>

<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
                         ... Pass statistics report ...
<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
MyPass
  <span class=o>(</span>S<span class=o>)</span> <span class=m>21</span> testStat - A <span class=nb>test</span> statistic</code></pre></div><h2 id=pass-instrumentation>Pass Instrumentation</h2><p>MLIR provides a customizable framework to instrument pass execution and analysis
computation. This is provided via the <code>PassInstrumentation</code> class. This class
provides hooks into the PassManager that observe various pass events:</p><ul><li><code>runBeforePipeline</code><ul><li>This callback is run just before a pass pipeline, i.e. pass manager, is
executed.</li></ul></li><li><code>runAfterPipeline</code><ul><li>This callback is run right after a pass pipeline has been executed,
successfully or not.</li></ul></li><li><code>runBeforePass</code><ul><li>This callback is run just before a pass is executed.</li></ul></li><li><code>runAfterPass</code><ul><li>This callback is run right after a pass has been successfully executed.
If this hook is executed, runAfterPassFailed will not be.</li></ul></li><li><code>runAfterPassFailed</code><ul><li>This callback is run right after a pass execution fails. If this hook is
executed, runAfterPass will not be.</li></ul></li><li><code>runBeforeAnalysis</code><ul><li>This callback is run just before an analysis is computed.</li></ul></li><li><code>runAfterAnalysis</code><ul><li>This callback is run right after an analysis is computed.</li></ul></li></ul><p>PassInstrumentation objects can be registered directly with a
<a href=#pass-manager>PassManager</a> instance via the <code>addInstrumentation</code> method.
Instrumentations added to the PassManager are run in a stack like fashion, i.e.
the last instrumentation to execute a <code>runBefore*</code> hook will be the first to
execute the respective <code>runAfter*</code> hook. Below in an example instrumentation
that counts the number of times DominanceInfo is computed:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>DominanceCounterInstrumentation</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PassInstrumentation</span> <span class=p>{</span>
  <span class=kt>unsigned</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>;</span>

  <span class=n>DominanceCounterInstrumentation</span><span class=p>(</span><span class=kt>unsigned</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>)</span> <span class=o>:</span> <span class=n>count</span><span class=p>(</span><span class=n>count</span><span class=p>)</span> <span class=p>{}</span>
  <span class=kt>void</span> <span class=nf>runAfterAnalysis</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>,</span> <span class=n>AnalysisID</span> <span class=o>*</span><span class=n>id</span><span class=p>,</span> <span class=n>Operation</span> <span class=o>*</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>id</span> <span class=o>==</span> <span class=n>AnalysisID</span><span class=o>::</span><span class=n>getID</span><span class=o>&lt;</span><span class=n>DominanceInfo</span><span class=o>&gt;</span><span class=p>())</span>
      <span class=o>++</span><span class=n>count</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span> <span class=o>=</span> <span class=p>...;</span>
<span class=n>PassManager</span> <span class=nf>pm</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>

<span class=c1>// Add the instrumentation to the pass manager.
</span><span class=c1></span><span class=kt>unsigned</span> <span class=n>domInfoCount</span><span class=p>;</span>
<span class=n>pm</span><span class=p>.</span><span class=n>addInstrumentation</span><span class=p>(</span>
    <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>DominanceCounterInstrumentation</span><span class=o>&gt;</span><span class=p>(</span><span class=n>domInfoCount</span><span class=p>));</span>

<span class=c1>// Run the pass manager on a module operation.
</span><span class=c1></span><span class=n>ModuleOp</span> <span class=n>m</span> <span class=o>=</span> <span class=p>...;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>failed</span><span class=p>(</span><span class=n>pm</span><span class=p>.</span><span class=n>run</span><span class=p>(</span><span class=n>m</span><span class=p>)))</span>
    <span class=p>...</span>

<span class=n>llvm</span><span class=o>::</span><span class=n>errs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;DominanceInfo was computed &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>domInfoCount</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; times!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</code></pre></div><h3 id=standard-instrumentations>Standard Instrumentations</h3><p>MLIR utilizes the pass instrumentation framework to provide a few useful
developer tools and utilities. Each of these instrumentations are immediately
available to all users of the MLIR pass framework.</p><h4 id=pass-timing>Pass Timing</h4><p>The PassTiming instrumentation provides timing information about the execution
of passes and computation of analyses. This provides a quick glimpse into what
passes are taking the most time to execute, as well as how much of an effect
your pass has on the total execution time of the pipeline. Users can enable this
instrumentation directly on the PassManager via <code>enableTiming</code>. This
instrumentation is also made available in mlir-opt via the <code>-pass-timing</code> flag.
The PassTiming instrumentation provides several different display modes for the
timing results, each of which is described below:</p><h5 id=list-display-mode>List Display Mode</h5><p>In this mode, the results are displayed in a list sorted by total time with each
pass/analysis instance aggregated into one unique result. This view is useful
for getting an overview of what analyses/passes are taking the most time in a
pipeline. This display mode is available in mlir-opt via
<code>-pass-timing-display=list</code>.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -disable-pass-threading -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse,canonicalize)&#39;</span> -convert-std-to-llvm -pass-timing -pass-timing-display<span class=o>=</span><span class=nv>list</span>

<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
                      ... Pass execution timing report ...
<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
  Total Execution Time: <span class=m>0</span>.0203 seconds

   ---Wall Time---  --- Name ---
   <span class=m>0</span>.0047 <span class=o>(</span> <span class=m>55</span>.9%<span class=o>)</span>  Canonicalizer
   <span class=m>0</span>.0019 <span class=o>(</span> <span class=m>22</span>.2%<span class=o>)</span>  VerifierPass
   <span class=m>0</span>.0016 <span class=o>(</span> <span class=m>18</span>.5%<span class=o>)</span>  LLVMLoweringPass
   <span class=m>0</span>.0003 <span class=o>(</span>  <span class=m>3</span>.4%<span class=o>)</span>  CSE
   <span class=m>0</span>.0002 <span class=o>(</span>  <span class=m>1</span>.9%<span class=o>)</span>  <span class=o>(</span>A<span class=o>)</span> DominanceInfo
   <span class=m>0</span>.0084 <span class=o>(</span><span class=m>100</span>.0%<span class=o>)</span>  Total</code></pre></div><h5 id=pipeline-display-mode>Pipeline Display Mode</h5><p>In this mode, the results are displayed in a nested pipeline view that mirrors
the internal pass pipeline that is being executed in the pass manager. This view
is useful for understanding specifically which parts of the pipeline are taking
the most time, and can also be used to identify when analyses are being
invalidated and recomputed. This is the default display mode.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -disable-pass-threading -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse,canonicalize)&#39;</span> -convert-std-to-llvm -pass-timing

<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
                      ... Pass execution timing report ...
<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
  Total Execution Time: <span class=m>0</span>.0249 seconds

   ---Wall Time---  --- Name ---
   <span class=m>0</span>.0058 <span class=o>(</span> <span class=m>70</span>.8%<span class=o>)</span>  <span class=s1>&#39;func&#39;</span> Pipeline
   <span class=m>0</span>.0004 <span class=o>(</span>  <span class=m>4</span>.3%<span class=o>)</span>    CSE
   <span class=m>0</span>.0002 <span class=o>(</span>  <span class=m>2</span>.6%<span class=o>)</span>      <span class=o>(</span>A<span class=o>)</span> DominanceInfo
   <span class=m>0</span>.0004 <span class=o>(</span>  <span class=m>4</span>.8%<span class=o>)</span>    VerifierPass
   <span class=m>0</span>.0046 <span class=o>(</span> <span class=m>55</span>.4%<span class=o>)</span>    Canonicalizer
   <span class=m>0</span>.0005 <span class=o>(</span>  <span class=m>6</span>.2%<span class=o>)</span>    VerifierPass
   <span class=m>0</span>.0005 <span class=o>(</span>  <span class=m>5</span>.8%<span class=o>)</span>  VerifierPass
   <span class=m>0</span>.0014 <span class=o>(</span> <span class=m>17</span>.2%<span class=o>)</span>  LLVMLoweringPass
   <span class=m>0</span>.0005 <span class=o>(</span>  <span class=m>6</span>.2%<span class=o>)</span>  VerifierPass
   <span class=m>0</span>.0082 <span class=o>(</span><span class=m>100</span>.0%<span class=o>)</span>  Total</code></pre></div><h5 id=multi-threaded-pass-timing>Multi-threaded Pass Timing</h5><p>When multi-threading is enabled in the pass manager the meaning of the display
slightly changes. First, a new timing column is added, <code>User Time</code>, that
displays the total time spent across all threads. Secondly, the <code>Wall Time</code>
column displays the longest individual time spent amongst all of the threads.
This means that the <code>Wall Time</code> column will continue to give an indicator on the
perceived time, or clock time, whereas the <code>User Time</code> will display the total
cpu time.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse,canonicalize)&#39;</span> -convert-std-to-llvm -pass-timing

<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
                      ... Pass execution timing report ...
<span class=o>===</span>-------------------------------------------------------------------------<span class=o>===</span>
  Total Execution Time: <span class=m>0</span>.0078 seconds

   ---User Time---   ---Wall Time---  --- Name ---
   <span class=m>0</span>.0177 <span class=o>(</span> <span class=m>88</span>.5%<span class=o>)</span>     <span class=m>0</span>.0057 <span class=o>(</span> <span class=m>71</span>.3%<span class=o>)</span>  <span class=s1>&#39;func&#39;</span> Pipeline
   <span class=m>0</span>.0044 <span class=o>(</span> <span class=m>22</span>.0%<span class=o>)</span>     <span class=m>0</span>.0015 <span class=o>(</span> <span class=m>18</span>.9%<span class=o>)</span>    CSE
   <span class=m>0</span>.0029 <span class=o>(</span> <span class=m>14</span>.5%<span class=o>)</span>     <span class=m>0</span>.0012 <span class=o>(</span> <span class=m>15</span>.2%<span class=o>)</span>      <span class=o>(</span>A<span class=o>)</span> DominanceInfo
   <span class=m>0</span>.0038 <span class=o>(</span> <span class=m>18</span>.9%<span class=o>)</span>     <span class=m>0</span>.0015 <span class=o>(</span> <span class=m>18</span>.7%<span class=o>)</span>    VerifierPass
   <span class=m>0</span>.0089 <span class=o>(</span> <span class=m>44</span>.6%<span class=o>)</span>     <span class=m>0</span>.0025 <span class=o>(</span> <span class=m>31</span>.1%<span class=o>)</span>    Canonicalizer
   <span class=m>0</span>.0006 <span class=o>(</span>  <span class=m>3</span>.0%<span class=o>)</span>     <span class=m>0</span>.0002 <span class=o>(</span>  <span class=m>2</span>.6%<span class=o>)</span>    VerifierPass
   <span class=m>0</span>.0004 <span class=o>(</span>  <span class=m>2</span>.2%<span class=o>)</span>     <span class=m>0</span>.0004 <span class=o>(</span>  <span class=m>5</span>.4%<span class=o>)</span>  VerifierPass
   <span class=m>0</span>.0013 <span class=o>(</span>  <span class=m>6</span>.5%<span class=o>)</span>     <span class=m>0</span>.0013 <span class=o>(</span> <span class=m>16</span>.3%<span class=o>)</span>  LLVMLoweringPass
   <span class=m>0</span>.0006 <span class=o>(</span>  <span class=m>2</span>.8%<span class=o>)</span>     <span class=m>0</span>.0006 <span class=o>(</span>  <span class=m>7</span>.0%<span class=o>)</span>  VerifierPass
   <span class=m>0</span>.0200 <span class=o>(</span><span class=m>100</span>.0%<span class=o>)</span>     <span class=m>0</span>.0081 <span class=o>(</span><span class=m>100</span>.0%<span class=o>)</span>  Total</code></pre></div><h4 id=ir-printing>IR Printing</h4><p>When debugging it is often useful to dump the IR at various stages of a pass
pipeline. This is where the IR printing instrumentation comes into play. This
instrumentation allows for conditionally printing the IR before and after pass
execution by optionally filtering on the pass being executed. This
instrumentation can be added directly to the PassManager via the
<code>enableIRPrinting</code> method. <code>mlir-opt</code> provides a few useful flags for utilizing
this instrumentation:</p><ul><li><code>print-ir-before=(comma-separated-pass-list)</code><ul><li>Print the IR before each of the passes provided within the pass list.</li></ul></li><li><p><code>print-ir-before-all</code></p><ul><li><p>Print the IR before every pass in the pipeline.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse)&#39;</span> -print-ir-before<span class=o>=</span>cse

*** IR Dump Before CSE ***
func @simple_constant<span class=o>()</span> -&gt; <span class=o>(</span>i32, i32<span class=o>)</span> <span class=o>{</span>
%c1_i32 <span class=o>=</span> constant <span class=m>1</span> : i32
%c1_i32_0 <span class=o>=</span> constant <span class=m>1</span> : i32
<span class=k>return</span> %c1_i32, %c1_i32_0 : i32, i32
<span class=o>}</span></code></pre></div></li></ul></li><li><p><code>print-ir-after=(comma-separated-pass-list)</code></p><ul><li>Print the IR after each of the passes provided within the pass list.</li></ul></li><li><p><code>print-ir-after-all</code></p><ul><li><p>Print the IR after every pass in the pipeline.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse)&#39;</span> -print-ir-after<span class=o>=</span>cse

*** IR Dump After CSE ***
func @simple_constant<span class=o>()</span> -&gt; <span class=o>(</span>i32, i32<span class=o>)</span> <span class=o>{</span>
%c1_i32 <span class=o>=</span> constant <span class=m>1</span> : i32
<span class=k>return</span> %c1_i32, %c1_i32 : i32, i32
<span class=o>}</span></code></pre></div></li></ul></li><li><p><code>print-ir-after-change</code></p><ul><li>Only print the IR after a pass if the pass mutated the IR. This helps to
reduce the number of IR dumps for &ldquo;uninteresting&rdquo; passes.</li><li>Note: Changes are detected by comparing a hash of the operation before
and after the pass. This adds additional run-time to compute the hash of
the IR, and in some rare cases may result in false-positives depending
on the collision rate of the hash algorithm used.</li><li><p>Note: This option should be used in unison with one of the other
&lsquo;print-ir-after&rsquo; options above, as this option alone does not enable
printing.</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse,cse)&#39;</span> -print-ir-after<span class=o>=</span>cse -print-ir-after-change

*** IR Dump After CSE ***
func @simple_constant<span class=o>()</span> -&gt; <span class=o>(</span>i32, i32<span class=o>)</span> <span class=o>{</span>
%c1_i32 <span class=o>=</span> constant <span class=m>1</span> : i32
<span class=k>return</span> %c1_i32, %c1_i32 : i32, i32
<span class=o>}</span></code></pre></div></li></ul></li><li><p><code>print-ir-module-scope</code></p><ul><li>Always print the top-level module operation, regardless of pass type or
operation nesting level.</li><li><p>Note: Printing at module scope should only be used when multi-threading
is disabled(<code>-disable-pass-threading</code>)</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ mlir-opt foo.mlir -disable-pass-threading -pass-pipeline<span class=o>=</span><span class=s1>&#39;func(cse)&#39;</span> -print-ir-after<span class=o>=</span>cse -print-ir-module-scope

*** IR Dump After CSE ***  <span class=o>(</span><span class=s1>&#39;func&#39;</span> operation: @bar<span class=o>)</span>
func @bar<span class=o>(</span>%arg0: f32, %arg1: f32<span class=o>)</span> -&gt; f32 <span class=o>{</span>
...
<span class=o>}</span>

func @simple_constant<span class=o>()</span> -&gt; <span class=o>(</span>i32, i32<span class=o>)</span> <span class=o>{</span>
%c1_i32 <span class=o>=</span> constant <span class=m>1</span> : i32
%c1_i32_0 <span class=o>=</span> constant <span class=m>1</span> : i32
<span class=k>return</span> %c1_i32, %c1_i32_0 : i32, i32
<span class=o>}</span>

*** IR Dump After CSE ***  <span class=o>(</span><span class=s1>&#39;func&#39;</span> operation: @simple_constant<span class=o>)</span>
func @bar<span class=o>(</span>%arg0: f32, %arg1: f32<span class=o>)</span> -&gt; f32 <span class=o>{</span>
...
<span class=o>}</span>

func @simple_constant<span class=o>()</span> -&gt; <span class=o>(</span>i32, i32<span class=o>)</span> <span class=o>{</span>
%c1_i32 <span class=o>=</span> constant <span class=m>1</span> : i32
<span class=k>return</span> %c1_i32, %c1_i32 : i32, i32
<span class=o>}</span></code></pre></div></li></ul></li></ul><h2 id=crash-and-failure-reproduction>Crash and Failure Reproduction</h2><p>The <a href=#pass-manager>pass manager</a> in MLIR contains a builtin mechanism to
generate reproducibles in the even of a crash, or a
<a href=#pass-failure>pass failure</a>. This functionality can be enabled via
<code>PassManager::enableCrashReproducerGeneration</code> or via the command line flag
<code>pass-pipeline-crash-reproducer</code>. In either case, an argument is provided that
corresponds to the output <code>.mlir</code> file name that the reproducible should be
written to. The reproducible contains the configuration of the pass manager that
was executing, as well as the initial IR before any passes were run. A potential
reproducible may have the form:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>// configuration: -pass-pipeline=&#39;func(cse, canonicalize), inline&#39;
// note: verifyPasses=false

module {
  func @foo() {
    ...
  }
}</code></pre></div><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/WritingAPass.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/tutorials/toy/ch-7/ title="Chapter 7: Adding a Composite Type to Toy"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 7: Adding a Composite Type to Toy</a>
<a class="nav nav-next" href=/docs/dialects/ title=Dialects>Next - Dialects <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/users/>Users of MLIR</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/contributing/>How to Contribute</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Code Documentation</a><ul class=sub-menu><li><a href=/docs/dialects/>Dialects</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgdoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/linalg/>Linalg Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li></ul></li><li><a href=/docs/tutorials/toy/>Toy</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/edsc/>Background: declarative builders API</a></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/developerguide/>Developer Guide</a></li><li><a href=/docs/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/diagnostics/>Introduction and Usage Guide to MLIR&#39;s Diagnostics Infrastructure</a></li><li><a href=/docs/interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/genericdagrewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/glossary/>MLIR Glossary</a></li><li><a href=/docs/passes/>MLIR Passes</a></li><li><a href=/docs/quantization/>MLIR Quantization</a></li><li><a href=/docs/rationale/>MLIR Rationale</a></li><li><a href=/docs/langref/>MLIR Specification</a></li><li><a href=/docs/mlirforgraphalgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/rationalesimplifiedpolyhedralform/>MLIR: The case for a &lt;em&gt;simplified&lt;/em&gt; polyhedral form</a></li><li><a href=/docs/canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/quickstartrewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/testingguide/>Testing Guide</a></li><li><a href=/docs/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li><li class=active><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>