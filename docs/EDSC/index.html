<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Background: declarative builders API - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/EDSC/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Background: declarative builders API</h1><p>The main purpose of the declarative builders API is to provide an intuitive way
of constructing MLIR programmatically. In the majority of cases, the IR we wish
to construct exhibits structured control-flow. The Declarative builders in the
<code>EDSC</code> library (Embedded Domain Specific Constructs) provide an API to make MLIR
construction and manipulation very idiomatic, for the structured control-flow
case, in C++.</p><h2 id=scopedcontext>ScopedContext</h2><p><code>mlir::edsc::ScopedContext</code> provides an implicit thread-local context,
supporting a simple declarative API with globally accessible builders. These
declarative builders are available within the lifetime of a <code>ScopedContext</code>.</p><h2 id=valuehandle-and-indexhandle>ValueHandle and IndexHandle</h2><p><code>mlir::edsc::ValueHandle</code> and <code>mlir::edsc::IndexHandle</code> provide typed
abstractions around an <code>mlir::Value</code>. These abstractions are &ldquo;delayed&rdquo;, in the
sense that they allow separating declaration from definition. They may capture
IR snippets, as they are built, for programmatic manipulation. Intuitive
operators are provided to allow concise and idiomatic expressions.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ValueHandle</span> <span class=n>zero</span> <span class=o>=</span> <span class=n>std_constant_index</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=p>;</span>
<span class=n>IndexHandle</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>k</span><span class=p>;</span>
</code></pre></div><h2 id=intrinsics>Intrinsics</h2><p><code>mlir::edsc::ValueBuilder</code> is a generic wrapper for the <code>mlir::Builder::create</code>
method that operates on <code>ValueHandle</code> objects and return a single ValueHandle.
For instructions that return no values or that return multiple values, the
<code>mlir::edsc::InstructionBuilder</code> can be used. Named intrinsics are provided as
syntactic sugar to further reduce boilerplate.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>using</span> <span class=n>load</span> <span class=o>=</span> <span class=n>ValueBuilder</span><span class=o>&lt;</span><span class=n>LoadOp</span><span class=o>&gt;</span><span class=p>;</span>
<span class=k>using</span> <span class=n>store</span> <span class=o>=</span> <span class=n>InstructionBuilder</span><span class=o>&lt;</span><span class=n>StoreOp</span><span class=o>&gt;</span><span class=p>;</span>
</code></pre></div><h2 id=loopbuilder-and-affineloopnestbuilder>LoopBuilder and AffineLoopNestBuilder</h2><p><code>mlir::edsc::AffineLoopNestBuilder</code> provides an interface to allow writing
concise and structured loop nests.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>ScopedContext</span> <span class=nf>scope</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>ValueHandle</span> <span class=nf>i</span><span class=p>(</span><span class=n>indexType</span><span class=p>)</span><span class=p>,</span>
              <span class=n>j</span><span class=p>(</span><span class=n>indexType</span><span class=p>)</span><span class=p>,</span>
              <span class=n>lb</span><span class=p>(</span><span class=n>f</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=p>)</span><span class=p>,</span>
              <span class=n>ub</span><span class=p>(</span><span class=n>f</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getArgument</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>ValueHandle</span> <span class=nf>f7</span><span class=p>(</span><span class=n>std_constant_float</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>APFloat</span><span class=p>(</span><span class=mf>7.0f</span><span class=p>)</span><span class=p>,</span> <span class=n>f32Type</span><span class=p>)</span><span class=p>)</span><span class=p>,</span>
              <span class=n>f13</span><span class=p>(</span><span class=n>std_constant_float</span><span class=p>(</span><span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>APFloat</span><span class=p>(</span><span class=mf>13.0f</span><span class=p>)</span><span class=p>,</span> <span class=n>f32Type</span><span class=p>)</span><span class=p>)</span><span class=p>,</span>
              <span class=n>i7</span><span class=p>(</span><span class=n>constant_int</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span><span class=p>)</span><span class=p>,</span>
              <span class=n>i13</span><span class=p>(</span><span class=n>constant_int</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=n>lb</span><span class=p>,</span> <span class=n>ub</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span><span class=p>(</span><span class=p>[</span><span class=o>&amp;</span><span class=p>]</span><span class=p>{</span>
      <span class=n>lb</span> <span class=o>*</span> <span class=nf>index_type</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=n>ub</span><span class=p>;</span>
      <span class=n>lb</span> <span class=o>+</span> <span class=n>index_type</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>;</span>
      <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=o>&amp;</span><span class=n>j</span><span class=p>,</span> <span class=n>lb</span><span class=p>,</span> <span class=n>ub</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span><span class=p>(</span><span class=p>[</span><span class=o>&amp;</span><span class=p>]</span><span class=p>{</span>
          <span class=n>ceilDiv</span><span class=p>(</span><span class=n>index_type</span><span class=p>(</span><span class=mi>31</span><span class=p>)</span> <span class=o>*</span> <span class=n>floorDiv</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>j</span> <span class=o>*</span> <span class=n>index_type</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>,</span> <span class=n>index_type</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=p>)</span><span class=p>,</span>
                  <span class=n>index_type</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
          <span class=p>(</span><span class=p>(</span><span class=n>f7</span> <span class=o>+</span> <span class=n>f13</span><span class=p>)</span> <span class=o>/</span> <span class=n>f7</span><span class=p>)</span> <span class=o>%</span> <span class=n>f13</span> <span class=o>-</span> <span class=n>f7</span> <span class=o>*</span> <span class=n>f13</span><span class=p>;</span>
          <span class=p>(</span><span class=p>(</span><span class=n>i7</span> <span class=o>+</span> <span class=n>i13</span><span class=p>)</span> <span class=o>/</span> <span class=n>i7</span><span class=p>)</span> <span class=o>%</span> <span class=n>i13</span> <span class=o>-</span> <span class=n>i7</span> <span class=o>*</span> <span class=n>i13</span><span class=p>;</span>
      <span class=p>}</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span><span class=p>)</span><span class=p>;</span>
</code></pre></div><h2 id=indexedvalue>IndexedValue</h2><p><code>mlir::edsc::IndexedValue</code> provides an index notation around load and store
operations on abstract data types by overloading the C++ assignment and
parenthesis operators. The relevant loads and stores are emitted as appropriate.</p><h2 id=putting-it-all-together>Putting it all together</h2><p>With declarative builders, it becomes fairly concise to build rank and
type-agnostic custom operations even though MLIR does not yet have generic
types. Here is what a definition of a general pointwise add looks in
Tablegen with declarative builders.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>def</span> <span class=nl>AddOp</span> <span class=p>:</span> <span class=n>Op</span><span class=o>&lt;</span><span class=sa></span><span class=s>&#34;</span><span class=s>x.add</span><span class=s>&#34;</span><span class=o>&gt;</span><span class=p>,</span>
    <span class=n>Arguments</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ins</span> <span class=nl>Tensor</span><span class=p>:</span><span class=err>$</span><span class=n>A</span><span class=p>,</span> <span class=nl>Tensor</span><span class=p>:</span><span class=err>$</span><span class=n>B</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span>
    <span class=n>Results</span><span class=o>&lt;</span><span class=p>(</span><span class=n>outs</span> <span class=nl>Tensor</span><span class=p>:</span> <span class=err>$</span><span class=n>C</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=n>code</span> <span class=n>referenceImplementation</span> <span class=o>=</span> <span class=p>[</span><span class=p>{</span>
    <span class=k>auto</span> <span class=n>ivs</span> <span class=o>=</span> <span class=n>makeIndexHandles</span><span class=p>(</span><span class=n>view_A</span><span class=p>.</span><span class=n>rank</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=k>auto</span> <span class=n>pivs</span> <span class=o>=</span> <span class=n>makePIndexHandles</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span><span class=p>;</span>
    <span class=n>IndexedValue</span> <span class=nf>A</span><span class=p>(</span><span class=n>arg_A</span><span class=p>)</span><span class=p>,</span> <span class=n>B</span><span class=p>(</span><span class=n>arg_B</span><span class=p>)</span><span class=p>,</span> <span class=n>C</span><span class=p>(</span><span class=n>arg_C</span><span class=p>)</span><span class=p>;</span>
    <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=n>pivs</span><span class=p>,</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getLbs</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getUbs</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getSteps</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>(</span>
      <span class=p>[</span><span class=o>&amp;</span><span class=p>]</span><span class=p>{</span>
        <span class=n>C</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span> <span class=o>=</span> <span class=n>A</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span> <span class=o>+</span> <span class=n>B</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span>
      <span class=p>}</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span><span class=p>]</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Depending on the function signature on which this emitter is called, the
generated IR resembles the following, for a 4-D memref of <code>vector&lt;4xi8></code>:</p><pre><code>// CHECK-LABEL: func @t1(%lhs: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;, %rhs: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;, %result: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;) -&gt; () {
//       CHECK: affine.for {{.*}} = 0 to 3 {
//       CHECK:   affine.for {{.*}} = 0 to 4 {
//       CHECK:     affine.for {{.*}} = 0 to 5 {
//       CHECK:       affine.for {{.*}}= 0 to 6 {
//       CHECK:         {{.*}} = load %arg1[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
//       CHECK:         {{.*}} = load %arg0[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
//       CHECK:         {{.*}} = addi {{.*}} : vector&lt;4xi8&gt;
//       CHECK:         store {{.*}}, %arg2[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
</code></pre><p>or the following, for a 0-D <code>memref&lt;f32></code>:</p><pre><code>// CHECK-LABEL: func @t3(%lhs: memref&lt;f32&gt;, %rhs: memref&lt;f32&gt;, %result: memref&lt;f32&gt;) -&gt; () {
//       CHECK: {{.*}} = load %arg1[] : memref&lt;f32&gt;
//       CHECK: {{.*}} = load %arg0[] : memref&lt;f32&gt;
//       CHECK: {{.*}} = addf {{.*}}, {{.*}} : f32
//       CHECK: store {{.*}}, %arg2[] : memref&lt;f32&gt;
</code></pre><p>Similar APIs are provided to emit the lower-level <code>loop.for</code> op with
<code>LoopNestBuilder</code>. See the <code>builder-api-test.cpp</code> test for more usage examples.</p><p>Since the implementation of declarative builders is in C++, it is also available
to program the IR with an embedded-DSL flavor directly integrated in MLIR. We
make use of these properties in the tutorial.</p><p>Spoiler: MLIR also provides Python bindings for these builders, and a
full-fledged Python machine learning DSL with automatic differentiation
targeting MLIR was built as an early research collaboration.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Tutorials/QuickstartRewrites/ title="Quickstart tutorial to adding MLIR graph rewrite"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Quickstart tutorial to adding MLIR graph rewrite</a>
<a class="nav nav-next" href=/docs/ConversionToLLVMDialect/ title="Conversion to the LLVM Dialect">Next - Conversion to the LLVM Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li></ul></li><li class=active><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Interfaces/>MLIR Interfaces</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Traits/>MLIR Operation Traits</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>