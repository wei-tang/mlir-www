<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Glossary - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/getting_started/Glossary/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Glossary</h1><p>This glossary contains definitions of MLIR-specific terminology. It is intended
to be a quick reference document. For terms which are well-documented elsewhere,
definitions are kept brief and the header links to the more in-depth
documentation.</p><h4 id=blocklangrefmdblocks><a href=/docs/LangRef/#blocks>Block</a></h4><p>A sequential list of operations without control flow.</p><p>Also called a
<a href=https://en.wikipedia.org/wiki/Basic_block>basic block</a>
.</p><h4 id=conversion>Conversion</h4><p>The transformation of code represented in one dialect into a semantically
equivalent representation in another dialect (i.e. inter-dialect conversion) or
the same dialect (i.e. intra-dialect conversion).</p><p>In the context of MLIR, conversion is distinct from
<a href=#translation>translation</a>
.
Conversion refers to a transformation between (or within) dialects, but all
still within MLIR, whereas translation refers to a transformation between MLIR
and an external representation.</p><h4 id=declarative-rewrite-ruledeclarativerewritesmd-drr><a href=/docs/DeclarativeRewrites/>Declarative Rewrite Rule</a>
(DRR)</h4><p>A
<a href=https://en.wikipedia.org/wiki/Graph_rewriting>rewrite rule</a>
which can be
defined declaratively (e.g. through specification in a
<a href=https://llvm.org/docs/TableGen/>TableGen</a>
record). At compiler build time,
these rules are expanded into an equivalent <code>mlir::RewritePattern</code> subclass.</p><h4 id=dialectlangrefmddialects><a href=/docs/LangRef/#dialects>Dialect</a></h4><p>A dialect is a grouping of functionality which can be used to extend the MLIR
system.</p><p>A dialect creates a unique <code>namespace</code> within which new
<a href=#operation-op>operations</a>
,
<a href=/docs/LangRef/#attributes>attributes</a>
, and
<a href=/docs/LangRef/#type-system>types</a>
are defined. This is the fundamental method by
which to extend MLIR.</p><p>In this way, MLIR is a meta-IR: its extensible framework allows it to be
leveraged in many different ways (e.g. at different levels of the compilation
process). Dialects provide an abstraction for the different uses of MLIR while
recognizing that they are all a part of the meta-IR that is MLIR.</p><p>The tutorial provides an example of
<a href=/docs/Tutorials/Toy/Ch-2/#interfacing-with-mlir>interfacing with MLIR</a>
in this
way.</p><p>(Note that we have intentionally selected the term &ldquo;dialect&rdquo; instead of
&ldquo;language&rdquo;, as the latter would wrongly suggest that these different namespaces
define entirely distinct IRs.)</p><h4 id=export>Export</h4><p>To transform code represented in MLIR into a semantically equivalent
representation which is external to MLIR.</p><p>The tool that performs such a transformation is called an exporter.</p><p>See also:
<a href=#translation>translation</a>
.</p><h4 id=functionlangrefmdfunctions><a href=/docs/LangRef/#functions>Function</a></h4><p>An
<a href=#operation-op>operation</a>
with a name containing one
<a href=#region>region</a>
.</p><p>The region of a function is not allowed to implicitly capture values defined
outside of the function, and all external references must use function arguments
or attributes that establish a symbolic connection.</p><h4 id=import>Import</h4><p>To transform code represented in an external representation into a semantically
equivalent representation in MLIR.</p><p>The tool that performs such a transformation is called an importer.</p><p>See also:
<a href=#translation>translation</a>
.</p><h4 id=legalization>Legalization</h4><p>The process of transforming operations into a semantically equivalent
representation which adheres to the requirements set by the
<a href=/docs/DialectConversion/#conversion-target>conversion target</a>
.</p><p>That is, legalization is accomplished if and only if the new representation
contains only operations which are legal, as specified in the conversion target.</p><h4 id=lowering>Lowering</h4><p>The process of transforming a higher-level representation of an operation into a
lower-level, but semantically equivalent, representation.</p><p>In MLIR, this is typically accomplished through
<a href=/docs/DialectConversion/>dialect conversion</a>
. This provides a framework by which
to define the requirements of the lower-level representation, called the
<a href=/docs/DialectConversion/#conversion-target>conversion target</a>
, by specifying which
operations are legal versus illegal after lowering.</p><p>See also:
<a href=#legalization>legalization</a>
.</p><h4 id=modulelangrefmdmodule><a href=/docs/LangRef/#module>Module</a></h4><p>An
<a href=#operation-op>operation</a>
which contains a single region containing a single
block that is comprised of operations.</p><p>This provides an organizational structure for MLIR operations, and is the
expected top-level operation in the IR: the textual parser returns a Module.</p><h4 id=operationlangrefmdoperations-op><a href=/docs/LangRef/#operations>Operation</a>
(op)</h4><p>A unit of code in MLIR. Operations are the building blocks for all code and
computations represented by MLIR. They are fully extensible (there is no fixed
list of operations) and have application-specific semantics.</p><p>An operation can have zero or more
<a href=#region>regions</a>
. Note that this creates a
nested IR structure, as regions consist of blocks, which in turn, consist of a
list of operations.</p><p>In MLIR, there are two main classes related to operations: <code>Operation</code> and <code>Op</code>.
Operation is the actual opaque instance of the operation, and represents the
general API into an operation instance. An <code>Op</code> is the base class of a derived
operation, like <code>ConstantOp</code>, and acts as smart pointer wrapper around a
<code>Operation*</code></p><h4 id=regionlangrefmdregions><a href=/docs/LangRef/#regions>Region</a></h4><p>A
<a href=https://en.wikipedia.org/wiki/Control-flow_graph>CFG</a>
of MLIR
<a href=#block>blocks</a>
.</p><h4 id=round-trip>Round-trip</h4><p>The process of converting from a source format to a target format and then back
to the source format.</p><p>This is a good way of gaining confidence that the target format richly models
the source format. This is particularly relevant in the MLIR context, since
MLIR&rsquo;s multi-level nature allows for easily writing target dialects that model a
source format (such as TensorFlow GraphDef or another non-MLIR format)
faithfully and have a simple conversion procedure. Further cleanup/lowering can
be done entirely within the MLIR representation. This separation - making the
<a href=#import>importer</a>
as simple as possible and performing all further
cleanups/lowering in MLIR - has proven to be a useful design pattern.</p><h4 id=terminator-operationlangrefmdterminator-operations><a href=/docs/LangRef/#terminator-operations>Terminator operation</a></h4><p>An
<a href=#operation-op>operation</a>
which <em>must</em> terminate a
<a href=#block>block</a>
.
Terminator operations are a special category of operations.</p><h4 id=transitive-lowering>Transitive lowering</h4><p>An A->B->C
<a href=#lowering>lowering</a>
; that is, a lowering in which multiple patterns
may be applied in order to fully transform an illegal operation into a set of
legal ones.</p><p>This provides the flexibility that the
<a href=#conversion>conversion</a>
framework may
perform the lowering in multiple stages of applying patterns (which may utilize
intermediate patterns not in the conversion target) in order to fully legalize
an operation. This is accomplished through
<a href=/docs/DialectConversion/#modes-of-conversion>partial conversion</a>
.</p><h4 id=translation>Translation</h4><p>The transformation of code represented in an external (non-MLIR) representation
into a semantically equivalent representation in MLIR (i.e.
<a href=#import>importing</a>
), or the inverse (i.e.
<a href=#export>exporting</a>
).</p><p>In the context of MLIR, translation is distinct from
<a href=#conversion>conversion</a>
.
Translation refers to a transformation between MLIR and an external
representation, whereas conversion refers to a transformation within MLIR
(between or within dialects).</p><div class=edit-meta><br><a href=https://github.com/llvm/mlir-www//edit/master/website/content/getting_started/Glossary.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/getting_started/openprojects/ title="Open Projects"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Open Projects</a>
<a class="nav nav-next" href=/getting_started/TestingGuide/ title="Testing Guide">Next - Testing Guide <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class="parent has-sub-menu"><a href=/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li class=active><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class=has-sub-menu><a href=/docs/>Code Documentation<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/FxpMathDialect/>'fxpmath' Dialect</a></li><li><a href=/docs/Dialects/LoopDialect/>'loop' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIRVDialect/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Affine/>`affine` Dialect</a></li><li><a href=/docs/Dialects/GPU/>`gpu` Dialect</a></li><li><a href=/docs/Dialects/Linalg/>`linalg` Dialect</a></li><li><a href=/docs/Dialects/LLVM/>`llvm` Dialect</a></li><li><a href=/docs/Dialects/Standard/>`std` Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>