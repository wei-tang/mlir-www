<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MLIR</title><link>https://mlir.llvm.org/</link><description>Recent content on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title>Users of MLIR</title><link>https://mlir.llvm.org/users/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/users/</guid><description> Flang: the LLVM Fortran compiler The high level IR of the Fortran compiler is modeled using MLIR.
TensorFlow</description></item><item><title>FAQ</title><link>https://mlir.llvm.org/getting_started/faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/faq/</guid><description>TODO</description></item><item><title>How to Contribute</title><link>https://mlir.llvm.org/getting_started/contributing/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/contributing/</guid><description>Everyone is welcome to contribute to MLIR. There are several ways of getting involved and contributing including reporting bugs, improving documentation and tutorials.
Community Guidelines Please be mindful of the LLVM Code of Conduct, which pledges to foster an open and welcoming environment.
Contributing code We don&amp;rsquo;t accept pull-request on GitHub, instead we use Phabricator.
Once a patch is approved on Phabricator and pass continuous integration checks, it can be pushed directly to the master branch of the repository.</description></item><item><title>Developer Guide</title><link>https://mlir.llvm.org/getting_started/developerguide/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/developerguide/</guid><description>This document attempts to describe a few developer policies used in MLIR (such as coding standards used) as well as development approach (such as, testing methods).
Style guide MLIR follows the LLVM style guide. We also adhere to the following (which deviate from or are not specified in the LLVM style guide):
Adopts camelBack; Except for IR units (Region, Block, and Operation), non-nullable output arguments are passed by non-const reference in general.</description></item><item><title>Glossary</title><link>https://mlir.llvm.org/getting_started/glossary/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/glossary/</guid><description>This glossary contains definitions of MLIR-specific terminology. It is intended to be a quick reference document. For terms which are well-documented elsewhere, definitions are kept brief and the header links to the more in-depth documentation.
Block A sequential list of operations without control flow.
Also called a basic block.
Conversion The transformation of code represented in one dialect into a semantically equivalent representation in another dialect (i.e. inter-dialect conversion) or the same dialect (i.</description></item><item><title>Testing Guide</title><link>https://mlir.llvm.org/getting_started/testingguide/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/testingguide/</guid><description>Testing is an integral part of any software infrastructure. In general, all commits to the MLIR repository should include an accompanying test of some form. Commits that include no functional changes, such as API changes like symbol renaming, should be tagged with NFC(no functional changes). This signals to the reviewer why the change doesn&amp;rsquo;t/shouldn&amp;rsquo;t include a test.
MLIR generally separates testing into two main categories, Check tests and Unit tests.</description></item><item><title>Affine Dialect</title><link>https://mlir.llvm.org/docs/dialects/affine/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/affine/</guid><description>This dialect provides a powerful abstraction for affine operations and analyses.
[TOC]
Polyhedral Structures MLIR uses techniques from polyhedral compilation to make dependence analysis and loop transformations efficient and reliable. This section introduces some of the core concepts that are used throughout the document.
Dimensions and Symbols Dimensions and symbols are the two kinds of identifiers that can appear in the polyhedral structures, and are always of index type. Dimensions are declared in parentheses and symbols are declared in square brackets.</description></item><item><title>Background: declarative builders API</title><link>https://mlir.llvm.org/docs/edsc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/edsc/</guid><description>The main purpose of the declarative builders API is to provide an intuitive way of constructing MLIR programmatically. In the majority of cases, the IR we wish to construct exhibits structured control-flow. Declarative builders provide an API to make MLIR construction and manipulation very idiomatic, for the structured control-flow case, in C++.
ScopedContext mlir::edsc::ScopedContext provides an implicit thread-local context, supporting a simple declarative API with globally accessible builders. These declarative builders are available within the lifetime of a ScopedContext.</description></item><item><title>Chapter 1: Toy Tutorial Introduction</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-1/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-1/</guid><description>[TOC]
This tutorial runs through the implementation of a basic toy language on top of MLIR. The goal of this tutorial is to introduce the concepts of MLIR; in particular, how dialects can help easily support language specific constructs and transformations while still offering an easy path to lower to LLVM or other codegen infrastructure. This tutorial is based on the model of the LLVM Kaleidoscope Tutorial.
This tutorial assumes you have cloned and built MLIR; if you have not yet done so, see Getting started with MLIR.</description></item><item><title>Chapter 2: Emitting Basic MLIR</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-2/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-2/</guid><description>[TOC]
Now that we&amp;rsquo;re familiar with our language and the AST, let&amp;rsquo;s see how MLIR can help to compile Toy.
Introduction: Multi-Level Intermediate Representation Other compilers, like LLVM (see the Kaleidoscope tutorial), offer a fixed set of predefined types and (usually low-level / RISC-like) instructions. It is up to the frontend for a given language to perform any language-specific type-checking, analysis, or transformation before emitting LLVM IR. For example, Clang will use its AST to perform not only static analysis but also transformations, such as C++ template instantiation through AST cloning and rewrite.</description></item><item><title>Chapter 3: High-level Language-Specific Analysis and Transformation</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-3/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-3/</guid><description>[TOC]
Creating a dialect that closely represents the semantics of an input language enables analyses, transformations and optimizations in MLIR that require high-level language information and are generally performed on the language AST. For example, clang has a fairly heavy mechanism for performing template instantiation in C++.
We divide compiler transformations into two categories: local and global. In this chapter, we focus on how to leverage the Toy Dialect and its high-level semantics to perform local pattern-match transformations that would be difficult in LLVM.</description></item><item><title>Chapter 4: Enabling Generic Transformation with Interfaces</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-4/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-4/</guid><description>[TOC]
Background: Grappling with an Extensible IR Through dialects, MLIR allows for the representation of many different levels of abstraction; the Toy dialect that we have previously defined is one such example. Though these different dialects may represent different abstractions, there is often a set of common transformations and analyses that we would like to perform. The problem that arises is that naively implementing each transformation for each dialect leads to large amounts of code duplication, as the internal algorithms are generally very similar, if not the same.</description></item><item><title>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-5/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-5/</guid><description>[TOC]
At this point, we are eager to generate actual code and see our Toy language take life. We will use LLVM to generate code, but just showing the LLVM builder interface here wouldn&amp;rsquo;t be very exciting. Instead, we will show how to perform progressive lowering through a mix of dialects coexisting in the same function.
To make it more interesting, in this chapter we will consider that we want to reuse existing optimizations implemented in a dialect optimizing affine transformations: Affine.</description></item><item><title>Chapter 6: Lowering to LLVM and CodeGeneration</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-6/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-6/</guid><description>[TOC]
In the previous chapter, we introduced the dialect conversion framework and partially lowered many of the Toy operations to affine loop nests for optimization. In this chapter, we will finally lower to LLVM for code generation.
For this lowering, we will again use the dialect conversion framework to perform the heavy lifting. However, this time, we will be performing a full conversion to the LLVM dialect. Thankfully, we have already lowered all but one of the toy operations, with the last being toy.</description></item><item><title>Chapter 7: Adding a Composite Type to Toy</title><link>https://mlir.llvm.org/docs/tutorials/toy/ch-7/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/toy/ch-7/</guid><description>[TOC]
In the previous chapter, we demonstrated an end-to-end compilation flow from our Toy front-end to LLVM IR. In this chapter, we will extend the Toy language to support a new composite struct type.
Defining a struct in Toy The first thing we need to define is the interface of this type in our toy source language. The general syntax of a struct type in Toy is as follows:</description></item><item><title>Conversion to the LLVM Dialect</title><link>https://mlir.llvm.org/docs/conversiontollvmdialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/conversiontollvmdialect/</guid><description>Conversion from the Standard to the LLVM Dialect can be performed by the specialized dialect conversion pass by running
mlir-opt -convert-std-to-llvm &amp;lt;filename.mlir&amp;gt; It performs type and operation conversions for a subset of operations from standard dialect (operations on scalars and vectors, control flow operations) as described in this document. We use the terminology defined by the LLVM IR Dialect description throughout this document.
[TOC]
Type Conversion Scalar Types Scalar types are converted to their LLVM counterparts if they exist.</description></item><item><title>Developer Guide</title><link>https://mlir.llvm.org/docs/developerguide/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/developerguide/</guid><description>This document attempts to describe a few developer policies used in MLIR (such as coding standards used) as well as development approach (such as, testing methods).
Style guide MLIR follows the LLVM style guide. We also adhere to the following (which deviate from or are not specified in the LLVM style guide):
Adopts camelBack; Except for IR units (Region, Block, and Operation), non-nullable output arguments are passed by non-const reference in general.</description></item><item><title>Dialect &#39;affine&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/affineops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/affineops/</guid><description>[TOC]
Operation definition affine.for (AffineForOp) for operation
Description: The &amp;ldquo;affine.for&amp;rdquo; operation represents an affine loop nest, defining an SSA value for its induction variable. It has one region capturing the loop body. The induction variable is represented as a argument of this region. This SSA value always has type index, which is the size of the machine word. The stride, represented by step, is a positive constant integer which defaults to &amp;ldquo;1&amp;rdquo; if not present.</description></item><item><title>Dialect &#39;fxpmath&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/fxpmathops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/fxpmathops/</guid><description>[TOC]
Operation definition fxpmath.clampis (fxpmath::ClampISOp) Clamps a signed-integer like argument to a min/max range.
Description: Element-wise equivalent to: r = std::min(clamp_max, std::max(e, clamp_min))
Operands: operand: integer-like Attributes: Attribute MLIR Type Description clamp_min IntegerAttr arbitrary integer attribute attribute clamp_max IntegerAttr arbitrary integer attribute attribute Results: &amp;laquo;unnamed&amp;raquo;: integer-like fxpmath.convertis (fxpmath::ConvertISOp) Does an element-wise conversion from a signed integer to signed integer</description></item><item><title>Dialect &#39;gpu&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/gpuops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/gpuops/</guid><description>[TOC]
Operation definition gpu.all_reduce (gpu::AllReduceOp) Reduce values among workgroup.
Description: The &amp;ldquo;all_reduce&amp;rdquo; op reduces the value of every work item across a local workgroup. The result is equal for all work items of a workgroup.
For example, both
%1 = &amp;quot;gpu.all_reduce&amp;quot;(%0) ({}) { op = &amp;quot;add&amp;quot; } : (f32) -&amp;gt; (f32) %2 = &amp;quot;gpu.all_reduce&amp;quot;(%0) ({ ^bb(%lhs : f32, %rhs : f32): %sum = addf %lhs, %rhs : f32 &amp;quot;gpu.</description></item><item><title>Dialect &#39;linalg&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/linalgdoc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/linalgdoc/</guid><description>The linalg dialect groups together a set of types, operations and transformations that are useful to implement a structured abstraction where ops can lower to scalar load/store and operations or to more general library calls.
The linalg dialect manipulates the following types and operations:
Core data types and special ops. The following abstractions are used by the linalg dialect:
Views The current implementation uses the strided memref abstraction. In the future other abstractions than strided memref will be used.</description></item><item><title>Dialect &#39;loop&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/loopops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/loopops/</guid><description>[TOC]
Operation definition loop.for (ForOp) for operation
Description: The &amp;ldquo;loop.for&amp;rdquo; operation represents a loop nest taking 3 SSA value as operands that represent the lower bound, upper bound and step respectively. The operation defines an SSA value for its induction variable. It has one region capturing the loop body. The induction variable is represented as an argument of this region. This SSA value always has type index, which is the size of the machine word.</description></item><item><title>Dialect &#39;nvvm&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/nvvmops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/nvvmops/</guid><description>[TOC]
Operation definition nvvm.barrier0 (NVVM::Barrier0Op) Description: Operands: Attributes: Results: nvvm.read.ptx.sreg.ntid.x (NVVM::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ntid.y (NVVM::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ntid.z (NVVM::BlockDimZOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ctaid.x (NVVM::BlockIdXOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ctaid.y (NVVM::BlockIdYOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.</description></item><item><title>Dialect &#39;quant&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/quantops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/quantops/</guid><description>[TOC]
Operation definition quant.const_fake_quant (quant::ConstFakeQuant) Simulates the effect of uniform quantization with const range.
Description: Given a const min, max, num_bits and narrow_range attribute, applies the same uniform quantization simulation as is done by the TensorFlow fake_quant_with_min_max_args op. See the fakeQuantAttrsToType() utility method and the quant-convert-simulated-quantization pass for futher details.
Operands: inputs: tensor of 32-bit float values Attributes: Attribute MLIR Type Description min FloatAttr 32-bit float attribute attribute max FloatAttr 32-bit float attribute attribute num_bits IntegerAttr 64-bit integer attribute attribute narrow_range BoolAttr bool attribute attribute is_signed BoolAttr bool attribute attribute Results: outputs: tensor of 32-bit float values quant.</description></item><item><title>Dialect &#39;rocdl&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/rocdlops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/rocdlops/</guid><description>[TOC]
Operation definition rocdl.workgroup.dim.x (ROCDL::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.y (ROCDL::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.z (ROCDL::BlockDimZOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.x (ROCDL::BlockIdXOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.y (ROCDL::BlockIdYOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.z (ROCDL::BlockIdZOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.</description></item><item><title>Dialect &#39;spv&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/spirvops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/spirvops/</guid><description>The SPIR-V dialect in MLIR.
SPIR-V is the Khronos Group&amp;rsquo;s binary intermediate language for representing graphical-shader stages and compute kernels for multiple Khronos APIs, including OpenCL, OpenGL, and Vulkan. See https://www.khronos.org/registry/spir-v for more details.
This dialect aims to be a simple proxy for the SPIR-V binary format to enable straightforward and lightweight conversion from/to the binary format. Ops in this dialect should stay at the same semantic level and try to be a mechanical mapping to the corresponding SPIR-V instructions; but they may deviate representationally to allow using MLIR mechanisms.</description></item><item><title>Dialect &#39;vector&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/vectorops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/vectorops/</guid><description>[TOC]
Operation definition vector.broadcast (vector::BroadcastOp) broadcast operation
Description: Broadcasts the scalar or k-D vector value in the source operand to a n-D result vector such that the broadcast makes sense, i.e., the source operand is duplicated to match the given rank and sizes in the result vector. The legality rules are: * the source operand must have the same element type as the result type * a k-D vector can be broadcast to a n-D vector if * k &amp;lt;= n, and * the sizes in the trailing dimensions n-k &amp;lt; i &amp;lt;= n with j=i+k-n match exactly as s_j = t_i or s_j = 1:</description></item><item><title>Dialect Conversion</title><link>https://mlir.llvm.org/docs/dialectconversion/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialectconversion/</guid><description>This document describes a framework in MLIR in which to perform operation conversions between, and within dialects. This framework allows for transforming illegal operations to those supported by a provided conversion target, via a set of pattern-based operation rewriting patterns.
[TOC]
To utilize the framework, a few things must be provided:
A Conversion Target A set of Rewrite Patterns A Type Converter (Optional) Modes of Conversion When applying a conversion to a set of operations, there are several conversion modes that can be selected from:</description></item><item><title>GPU Dialect</title><link>https://mlir.llvm.org/docs/dialects/gpu/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/gpu/</guid><description>Note: this dialect is more likely to change than others in the near future; use with caution.
This dialect provides middle-level abstractions for launching GPU kernels following a programming model similar to that of CUDA or OpenCL. It provides abstractions for kernel invocations (and may eventually provide those for device management) that are not present at the lower level (e.g., as LLVM IR intrinsics for GPUs). Its goal is to abstract away device- and driver-specific manipulations to launch a GPU kernel and provide a simple path towards GPU execution from MLIR.</description></item><item><title>Introduction and Usage Guide to MLIR&#39;s Diagnostics Infrastructure</title><link>https://mlir.llvm.org/docs/diagnostics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/diagnostics/</guid><description>[TOC]
This document presents an introduction to using and interfacing with MLIR&amp;rsquo;s diagnostics infrastructure.
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc.
Source Locations Source location information is extremely important for any compiler, because it provides a baseline for debuggability and error-reporting. MLIR provides several different location types depending on the situational need.
CallSite Location callsite-location ::= &#39;callsite&#39; &#39;(&#39; location &#39;at&#39; location &#39;)&#39; An instance of this location allows for representing a directed stack of location usages.</description></item><item><title>Introduction to MLIR Interfaces</title><link>https://mlir.llvm.org/docs/interfaces/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/interfaces/</guid><description>MLIR is generic and very extensible; it allows for opaquely representing many different dialects that have their own operations, attributes, types, and so on. This allows for dialects to be very expressive in their semantics and for MLIR to capture many different levels of abstraction. The downside to this is that transformations and analyses must be extremely conservative about the operations that they encounter, and must special-case the different dialects that they support.</description></item><item><title>Introduction to MLIR Operation Traits</title><link>https://mlir.llvm.org/docs/traits/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/traits/</guid><description>[TOC]
MLIR allows for a truly open operation ecosystem, as any dialect may define operations that suit a specific level of abstraction. Traits are a mechanism in which to abstract implementation details and properties that are common across many different operations. Traits may be used to specify special properties and constraints of the operation, including whether the operation has side effects or whether its output has the same type as the input.</description></item><item><title>Linalg Dialect</title><link>https://mlir.llvm.org/docs/dialects/linalg/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/linalg/</guid><description>To generate the documentation:
mlir-tblgen --gen-op-doc -I /path/to/mlir/include \ /path/to/mlir/include/mlir/Dialect/Linalg/IR/LinalgDoc.</description></item><item><title>LLVM IR Dialect</title><link>https://mlir.llvm.org/docs/dialects/llvm/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/llvm/</guid><description>This dialect wraps the LLVM IR types and instructions into MLIR types and operations. It provides several additional operations that are necessary to cover for the differences in the IR structure (e.g., MLIR does not have phi operations and LLVM IR does not have a constant operation).
In this document, we use &amp;ldquo;LLVM IR&amp;rdquo; to designate the intermediate representation of LLVM and &amp;ldquo;LLVM IR dialect&amp;rdquo; to refer to the MLIR dialect reflecting LLVM instructions and types.</description></item><item><title>MLIR Generic DAG Rewriter Infrastructure</title><link>https://mlir.llvm.org/docs/genericdagrewriter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/genericdagrewriter/</guid><description>Introduction and Motivation The goal of a compiler IR is to represent code - at various levels of abstraction which pose different sets of tradeoffs in terms of representational capabilities and ease of transformation. However, the ability to represent code is not itself very useful - you also need to be able to implement those transformations.
There are many different sorts of compiler transformations, but this document focuses on a particularly important class of transformation that comes up repeatedly at scale, and is important for the immediate goals of MLIR: that of pattern matching on a set of operations and replacing with another set.</description></item><item><title>MLIR Glossary</title><link>https://mlir.llvm.org/docs/glossary/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/glossary/</guid><description>This glossary contains definitions of MLIR-specific terminology. It is intended to be a quick reference document. For terms which are well-documented elsewhere, definitions are kept brief and the header links to the more in-depth documentation.
Block A sequential list of operations without control flow.
Also called a basic block.
Conversion The transformation of code represented in one dialect into a semantically equivalent representation in another dialect (i.e. inter-dialect conversion) or the same dialect (i.</description></item><item><title>MLIR Passes</title><link>https://mlir.llvm.org/docs/passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/passes/</guid><description>This document describes the available MLIR passes and their contracts.
[TOC]
Affine control lowering (-lower-affine) Convert operations related to affine control into a graph of blocks using operations from the standard dialect.
Loop statements are converted to a subgraph of blocks (initialization, condition checking, subgraph of body blocks) with loop induction variable being passed as the block argument of the condition checking block. Conditional statements are converted to a subgraph of blocks (chain of condition checking with short-circuit logic, subgraphs of &amp;lsquo;then&amp;rsquo; and &amp;lsquo;else&amp;rsquo; body blocks).</description></item><item><title>MLIR Quantization</title><link>https://mlir.llvm.org/docs/quantization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/quantization/</guid><description>This document outlines the design of the MLIR quantization system. While the term &amp;ldquo;quantization&amp;rdquo; is highly overloaded, in this case, it refers to a fairly narrow scope of techniques in use to enable conversion of floating-point computations to corresponding and plausible variants expressed in integer math for inference, as has historically been supported by low-bit depth inference engines such as TFLite, various accelerator hardware, and many DSPs.
Much of this is inspired by the approach taken in this paper with many extensions and adaptations folded in.</description></item><item><title>MLIR Rationale</title><link>https://mlir.llvm.org/docs/rationale/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/rationale/</guid><description>This document is intended to capture some of the alternatives considered and open debates in the design of MLIR, along with the rationale for certain decisions we made. This is not intended to be a &amp;ldquo;finely groomed&amp;rdquo; document - we prefer the ability to dump in interesting tidbits without worrying too much about their consistency or readability.
[TOC]
Abstract MLIR is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL), but which introduces notions from the polyhedral loop optimization works as first class concepts.</description></item><item><title>MLIR Specification</title><link>https://mlir.llvm.org/docs/langref/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/langref/</guid><description>MLIR (Multi-Level IR) is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL), but which introduces notions from polyhedral loop optimization as first-class concepts. This hybrid design is optimized to represent, analyze, and transform high level dataflow graphs as well as target-specific code generated for high performance data parallel systems. Beyond its representational capabilities, its single continuous design provides a framework to lower from dataflow graphs to high-performance target-specific code.</description></item><item><title>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</title><link>https://mlir.llvm.org/docs/mlirforgraphalgorithms/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/mlirforgraphalgorithms/</guid><description>The existing documentation about MLIR focuses on long term vision, how its pieces fit together, and the benefits of modular and composable infrastructure in the vast and distant future. While this viewpoint appeals to some, it causes concern for others who are more concerned about the &amp;ldquo;here and now&amp;rdquo; - why does it make sense to make a &amp;ldquo;revolutionary&amp;rdquo; change when any individual problem can be fixed in place?</description></item><item><title>MLIR: The case for a &lt;em&gt;simplified&lt;/em&gt; polyhedral form</title><link>https://mlir.llvm.org/docs/rationalesimplifiedpolyhedralform/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/rationalesimplifiedpolyhedralform/</guid><description>MLIR embraces polyhedral compiler techniques for their many advantages representing and transforming dense numerical kernels, but it uses a form that differs significantly from other polyhedral frameworks.
Disclaimer / Warning
This document is a very early design proposal (which has since been accepted) that explored the tradeoffs of using this simplified form vs the traditional polyhedral schedule list form. At some point, this document could be dusted off and written as a proper academic paper, but until now, it is better to included it in this crafty form than not to.</description></item><item><title>Operation Canonicalization in MLIR</title><link>https://mlir.llvm.org/docs/canonicalization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/canonicalization/</guid><description>Canonicalization is an important part of compiler IR design: it makes it easier to implement reliable compiler transformations and to reason about what is better or worse in the code, and it forces interesting discussions about the goals of a particular level of IR. Dan Gohman wrote an article exploring these issues; it is worth reading if you&amp;rsquo;re not familiar with these concepts.
Most compilers have canonicalization passes, and sometimes they have many different ones (e.</description></item><item><title>Quickstart tutorial to adding MLIR graph rewrite</title><link>https://mlir.llvm.org/docs/quickstartrewrites/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/quickstartrewrites/</guid><description>This document will present a quickstart to adding graph rewrites. We shall start by defining an operation, showing multiple ways to define the rewrite using patterns, as well as defining the rewrite using a graph walker (note: using patterns and the rewrite engine is preferred, showing the walker is for demonstration purposes).
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc. See Table-driven Operation Definition and Declarative Rewrite Rule for the detailed explanation of all available mechanisms for defining operations and rewrites in a table-driven manner.</description></item><item><title>Quickstart tutorial to defining custom dialect attributes and types</title><link>https://mlir.llvm.org/docs/definingattributesandtypes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/definingattributesandtypes/</guid><description>This document is a quickstart to defining dialect specific extensions to the attribute and type system. The main part of the tutorial focuses on defining types, but the instructions are nearly identical for defining attributes.
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc.
Types Types in MLIR (like attributes, locations, and many other things) are value-typed. This means that instances of Type should be passed around by-value, as opposed to by-pointer or by-reference.</description></item><item><title>SPIR-V Dialect</title><link>https://mlir.llvm.org/docs/dialects/spir-v/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/spir-v/</guid><description>This document describes the design of the SPIR-V dialect in MLIR. It lists various design choices we made for modeling different SPIR-V mechanisms, and their rationale.
This document also explains in a high-level manner how different components are organized and implemented in the code and gives steps to follow for extending them.
This document assumes familiarity with SPIR-V. SPIR-V is the Khronos Groupâ€™s binary intermediate language for representing graphics shaders and compute kernels.</description></item><item><title>Standard Dialect</title><link>https://mlir.llvm.org/docs/dialects/standard/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/standard/</guid><description>This dialect provides documentation for operations within the Standard dialect.
Note: This dialect is a collection of operations for several different concepts, and should be split into multiple more-focused dialects accordingly.
[TOC]
TODO: shape, which returns a 1D tensor, and can take an unknown rank tensor as input.
TODO: rank, which returns an index.
Terminator operations Terminator operations are required at the end of each block. They may contain a list of successors, i.</description></item><item><title>Table-driven Declarative Rewrite Rule (DRR)</title><link>https://mlir.llvm.org/docs/declarativerewrites/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/declarativerewrites/</guid><description>In addition to subclassing the mlir::RewritePattern C++ class, MLIR also supports defining rewrite rules in a declarative manner. Similar to Op Definition Specification (ODS), this is achieved via TableGen, which is a language to maintain records of domain-specific information. The rewrite rules are specified concisely in a TableGen record, which will be expanded into an equivalent mlir::RewritePattern subclass at compiler build time.
This manual explains in detail all of the available mechanisms for defining rewrite rules in such a declarative manner.</description></item><item><title>Table-driven Operation Definition Specification (ODS)</title><link>https://mlir.llvm.org/docs/opdefinitions/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/opdefinitions/</guid><description>In addition to specializing the mlir::Op C++ template, MLIR also supports defining operations in a table-driven manner. This is achieved via TableGen, which is both a generic language and its tooling to maintain records of domain-specific information. Facts regarding an operation are specified concisely into a TableGen record, which will be expanded into an equivalent mlir::Op C++ template specialization at compiler build time.
This manual explains in detail all the available mechanisms for defining operations in such a table-driven manner.</description></item><item><title>Testing Guide</title><link>https://mlir.llvm.org/docs/testingguide/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/testingguide/</guid><description>Testing is an integral part of any software infrastructure. In general, all commits to the MLIR repository should include an accompanying test of some form. Commits that include no functional changes, such as API changes like symbol renaming, should be tagged with NFC(no functional changes). This signals to the reviewer why the change doesn&amp;rsquo;t/shouldn&amp;rsquo;t include a test.
MLIR generally separates testing into two main categories, Check tests and Unit tests.</description></item><item><title>Usage of &#39;Const&#39; in MLIR, for core IR types</title><link>https://mlir.llvm.org/docs/usageofconst/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/usageofconst/</guid><description>aka, where&amp;rsquo;d const go?
The MLIR data structures that represent the IR itself (Instruction, Block, etc) form a graph-based data structure, and the compiler analyses and passes frequently walk this graph (e.g. traversing from defs to users). The early design of MLIR adopted the const model of LLVM, which is familiar and well understood (even though the LLVM implementation is flawed in many ways).
The design team since decided to change to a different module, which eschews const entirely for the core IR types: you should never see a const method on Operation, should never see the type const Value, and you shouldn&amp;rsquo;t feel bad about this.</description></item><item><title>Vector Dialect</title><link>https://mlir.llvm.org/docs/dialects/vector/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/vector/</guid><description>This dialect provides mid-level abstraction for the MLIR super-vectorizer.
[TOC]
Operations mlir-tblgen --gen-op-doc -I /path/to/mlir/include \ /path/to/mlir/include/mlir/Dialect/VectorOps/VectorOps.</description></item><item><title>Writing a Pass</title><link>https://mlir.llvm.org/docs/writingapass/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/writingapass/</guid><description>[TOC]
Passes represent the basic infrastructure for transformation and optimization. This document provides a quickstart to the pass infrastructure in MLIR and how to use it.
See MLIR specification for more information about MLIR and its core aspects, such as the IR structure and operations.
See MLIR Rewrites for a quick start on graph rewriting in MLIR. If your transformation involves pattern matching operation DAGs, this is a great place to start.</description></item></channel></rss>